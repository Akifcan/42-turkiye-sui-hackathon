import {
  Field,
  ReadonlyWalletAccount,
  StandardConnect,
  StandardDisconnect,
  StandardEvents,
  WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED,
  WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND,
  WalletStandardError,
  _normFnElement,
  bytesToNumberBE,
  createCurve,
  createHasher as createHasher2,
  ensureBytes,
  getWallets,
  hmac,
  inRange,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mitt_default,
  mnemonicToSeedSync,
  mod,
  numberToBytesBE,
  pow2,
  print,
  require_poseidon_lite,
  safeCaptureStackTrace,
  sha256,
  sha2562,
  sha384,
  sha512,
  sha5122
} from "./chunk-N6OGLQB6.js";
import {
  Chi,
  HashMD,
  Maj,
  abytes,
  ahash,
  anumber,
  array,
  bigint,
  blake2b,
  boolean,
  bytesToHex,
  check,
  clean,
  concatBytes,
  createHasher,
  hexToBytes,
  integer,
  is,
  isBytes,
  lazy,
  literal,
  nullable,
  nullish,
  number,
  object,
  optional,
  parse,
  pipe,
  randomBytes,
  record,
  rotl,
  string,
  transform,
  tuple,
  union,
  unknown,
  utf8ToBytes
} from "./chunk-VLQPYVRM.js";
import {
  base58,
  bech32,
  createBase58check
} from "./chunk-72EW4VGG.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/EnokiClient/index.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _version;
var _apiUrl;
var _apiKey;
var _EnokiClient_instances;
var fetch_fn;
var DEFAULT_API_URL = "https://api.enoki.mystenlabs.com";
var ZKLOGIN_HEADER = "zklogin-jwt";
var EnokiClientError = class extends Error {
  constructor(status, response) {
    let errors;
    try {
      const parsedResponse = JSON.parse(response);
      errors = parsedResponse.errors;
    } catch {
    }
    const cause = errors?.[0] ? new Error(errors[0].message) : void 0;
    super(`Request to Enoki API failed (status: ${status})`, {
      cause
    });
    this.errors = [];
    this.errors = errors ?? [];
    this.name = "EnokiClientError";
    this.status = status;
    this.code = errors?.[0]?.code ?? "unknown_error";
  }
};
var EnokiClient = class {
  constructor(config) {
    __privateAdd(this, _EnokiClient_instances);
    __privateAdd(this, _version);
    __privateAdd(this, _apiUrl);
    __privateAdd(this, _apiKey);
    __privateSet(this, _version, "v1");
    __privateSet(this, _apiUrl, config.apiUrl ?? DEFAULT_API_URL);
    __privateSet(this, _apiKey, config.apiKey);
  }
  getApp(_input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "app", {
      method: "GET"
    });
  }
  getZkLogin(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  getZkLoginAddresses(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/addresses", {
      method: "GET",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      }
    });
  }
  createZkLoginNonce(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/nonce", {
      method: "POST",
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        additionalEpochs: input.additionalEpochs
      })
    });
  }
  createZkLoginZkp(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "zklogin/zkp", {
      method: "POST",
      headers: {
        [ZKLOGIN_HEADER]: input.jwt
      },
      body: JSON.stringify({
        network: input.network,
        ephemeralPublicKey: input.ephemeralPublicKey.toSuiPublicKey(),
        maxEpoch: input.maxEpoch,
        randomness: input.randomness
      })
    });
  }
  createSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "transaction-blocks/sponsor", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        sender: input.sender,
        network: input.network,
        transactionBlockKindBytes: input.transactionKindBytes,
        allowedAddresses: input.allowedAddresses,
        allowedMoveCallTargets: input.allowedMoveCallTargets
      })
    });
  }
  executeSponsoredTransaction(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {
      method: "POST",
      body: JSON.stringify({
        signature: input.signature
      })
    });
  }
  getSubnames(input) {
    const query = new URLSearchParams();
    if (input.address) {
      query.set("address", input.address);
    }
    if (input.network) {
      query.set("network", input.network);
    }
    if (input.domain) {
      query.set("domain", input.domain);
    }
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames" + (query.size > 0 ? `?${query.toString()}` : ""), {
      method: "GET"
    });
  }
  createSubname(input) {
    return __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "POST",
      headers: input.jwt ? {
        [ZKLOGIN_HEADER]: input.jwt
      } : {},
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname,
        targetAddress: input.targetAddress
      })
    });
  }
  deleteSubname(input) {
    __privateMethod(this, _EnokiClient_instances, fetch_fn).call(this, "subnames", {
      method: "DELETE",
      body: JSON.stringify({
        network: input.network,
        domain: input.domain,
        subname: input.subname
      })
    });
  }
};
_version = /* @__PURE__ */ new WeakMap();
_apiUrl = /* @__PURE__ */ new WeakMap();
_apiKey = /* @__PURE__ */ new WeakMap();
_EnokiClient_instances = /* @__PURE__ */ new WeakSet();
fetch_fn = async function(path, init) {
  const res = await fetch(`${__privateGet(this, _apiUrl)}/${__privateGet(this, _version)}/${path}`, {
    ...init,
    headers: {
      ...init.headers,
      Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
      "Content-Type": "application/json",
      "Request-Id": crypto.randomUUID()
    }
  });
  if (!res.ok) {
    throw new EnokiClientError(res.status, await res.text());
  }
  const { data } = await res.json();
  return data;
};

// node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b58.js
var toBase58 = (buffer) => base58.encode(buffer);
var fromBase58 = (str) => base58.decode(str);

// node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/b64.js
function fromBase64(base64String2) {
  return Uint8Array.from(atob(base64String2), (char) => char.charCodeAt(0));
}
var CHUNK_SIZE = 8192;
function toBase64(bytes) {
  if (bytes.length < CHUNK_SIZE) {
    return btoa(String.fromCharCode(...bytes));
  }
  let output = "";
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    const chunk2 = bytes.slice(i, i + CHUNK_SIZE);
    output += String.fromCharCode(...chunk2);
  }
  return btoa(output);
}

// node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/hex.js
function fromHex(hexStr) {
  const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;
  const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
  if (intArr.length !== padded.length / 2) {
    throw new Error(`Invalid hex string ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/chunk.js
function chunk(array2, size) {
  return Array.from({ length: Math.ceil(array2.length / size) }, (_, i) => {
    return array2.slice(i * size, (i + 1) * size);
  });
}

// node_modules/.pnpm/@mysten+utils@0.2.0/node_modules/@mysten/utils/dist/esm/dataloader.js
var DataLoader = class {
  constructor(batchLoadFn, options) {
    if (typeof batchLoadFn !== "function") {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${batchLoadFn}.`
      );
    }
    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._cacheKeyFn = getValidCacheKeyFn(options);
    this._cacheMap = getValidCacheMap(options);
    this._batch = null;
    this.name = getValidName(options);
  }
  /**
   * Loads a key, returning a `Promise` for the value represented by that key.
   */
  load(key) {
    if (key === null || key === void 0) {
      throw new TypeError(
        `The loader.load() function must be called with a value, but got: ${String(key)}.`
      );
    }
    const batch = getCurrentBatch(this);
    const cacheMap2 = this._cacheMap;
    let cacheKey;
    if (cacheMap2) {
      cacheKey = this._cacheKeyFn(key);
      const cachedPromise = cacheMap2.get(cacheKey);
      if (cachedPromise) {
        const cacheHits = batch.cacheHits || (batch.cacheHits = []);
        return new Promise((resolve) => {
          cacheHits.push(() => {
            resolve(cachedPromise);
          });
        });
      }
    }
    batch.keys.push(key);
    const promise = new Promise((resolve, reject) => {
      batch.callbacks.push({ resolve, reject });
    });
    if (cacheMap2) {
      cacheMap2.set(cacheKey, promise);
    }
    return promise;
  }
  /**
   * Loads multiple keys, promising an array of values:
   *
   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);
   *
   * This is similar to the more verbose:
   *
   *     var [ a, b ] = await Promise.all([
   *       myLoader.load('a'),
   *       myLoader.load('b')
   *     ]);
   *
   * However it is different in the case where any load fails. Where
   * Promise.all() would reject, loadMany() always resolves, however each result
   * is either a value or an Error instance.
   *
   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);
   *     // c instanceof Error
   *
   */
  loadMany(keys) {
    if (!isArrayLike(keys)) {
      throw new TypeError(
        `The loader.loadMany() function must be called with Array<key>, but got: ${keys}.`
      );
    }
    const loadPromises = [];
    for (let i = 0; i < keys.length; i++) {
      loadPromises.push(this.load(keys[i]).catch((error) => error));
    }
    return Promise.all(loadPromises);
  }
  /**
   * Clears the value at `key` from the cache, if it exists. Returns itself for
   * method chaining.
   */
  clear(key) {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      const cacheKey = this._cacheKeyFn(key);
      cacheMap2.delete(cacheKey);
    }
    return this;
  }
  /**
   * Clears the entire cache. To be used when some event results in unknown
   * invalidations across this particular `DataLoader`. Returns itself for
   * method chaining.
   */
  clearAll() {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      cacheMap2.clear();
    }
    return this;
  }
  /**
   * Adds the provided key and value to the cache. If the key already
   * exists, no change is made. Returns itself for method chaining.
   *
   * To prime the cache with an error at a key, provide an Error instance.
   */
  prime(key, value) {
    const cacheMap2 = this._cacheMap;
    if (cacheMap2) {
      const cacheKey = this._cacheKeyFn(key);
      if (cacheMap2.get(cacheKey) === void 0) {
        let promise;
        if (value instanceof Error) {
          promise = Promise.reject(value);
          promise.catch(() => {
          });
        } else {
          promise = Promise.resolve(value);
        }
        cacheMap2.set(cacheKey, promise);
      }
    }
    return this;
  }
};
var enqueuePostPromiseJob = (
  /** @ts-ignore */
  typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(() => {
      process.nextTick(fn);
    });
  } : (
    // @ts-ignore
    typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    }
  )
);
var resolvedPromise;
function getCurrentBatch(loader) {
  const existingBatch = loader._batch;
  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
    return existingBatch;
  }
  const newBatch = { hasDispatched: false, keys: [], callbacks: [] };
  loader._batch = newBatch;
  loader._batchScheduleFn(() => {
    dispatchBatch(loader, newBatch);
  });
  return newBatch;
}
function dispatchBatch(loader, batch) {
  batch.hasDispatched = true;
  if (batch.keys.length === 0) {
    resolveCacheHits(batch);
    return;
  }
  let batchPromise;
  try {
    batchPromise = loader._batchLoadFn(batch.keys);
  } catch (e) {
    return failedDispatch(
      loader,
      batch,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(e)}.`
      )
    );
  }
  if (!batchPromise || typeof batchPromise.then !== "function") {
    return failedDispatch(
      loader,
      batch,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(batchPromise)}.`
      )
    );
  }
  Promise.resolve(batchPromise).then((values) => {
    if (!isArrayLike(values)) {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(values)}.`
      );
    }
    if (values.length !== batch.keys.length) {
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(batch.keys)}

Values:
${String(values)}`
      );
    }
    resolveCacheHits(batch);
    for (let i = 0; i < batch.callbacks.length; i++) {
      const value = values[i];
      if (value instanceof Error) {
        batch.callbacks[i].reject(value);
      } else {
        batch.callbacks[i].resolve(value);
      }
    }
  }).catch((error) => {
    failedDispatch(loader, batch, error);
  });
}
function failedDispatch(loader, batch, error) {
  resolveCacheHits(batch);
  for (let i = 0; i < batch.keys.length; i++) {
    loader.clear(batch.keys[i]);
    batch.callbacks[i].reject(error);
  }
}
function resolveCacheHits(batch) {
  if (batch.cacheHits) {
    for (let i = 0; i < batch.cacheHits.length; i++) {
      batch.cacheHits[i]();
    }
  }
}
function getValidMaxBatchSize(options) {
  const shouldBatch = !options || options.batch !== false;
  if (!shouldBatch) {
    return 1;
  }
  const maxBatchSize = options && options.maxBatchSize;
  if (maxBatchSize === void 0) {
    return Infinity;
  }
  if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
    throw new TypeError(`maxBatchSize must be a positive number: ${maxBatchSize}`);
  }
  return maxBatchSize;
}
function getValidBatchScheduleFn(options) {
  const batchScheduleFn = options && options.batchScheduleFn;
  if (batchScheduleFn === void 0) {
    return enqueuePostPromiseJob;
  }
  if (typeof batchScheduleFn !== "function") {
    throw new TypeError(`batchScheduleFn must be a function: ${batchScheduleFn}`);
  }
  return batchScheduleFn;
}
function getValidCacheKeyFn(options) {
  const cacheKeyFn = options && options.cacheKeyFn;
  if (cacheKeyFn === void 0) {
    return (key) => key;
  }
  if (typeof cacheKeyFn !== "function") {
    throw new TypeError(`cacheKeyFn must be a function: ${cacheKeyFn}`);
  }
  return cacheKeyFn;
}
function getValidCacheMap(options) {
  const shouldCache = !options || options.cache !== false;
  if (!shouldCache) {
    return null;
  }
  const cacheMap2 = options && options.cacheMap;
  if (cacheMap2 === void 0) {
    return /* @__PURE__ */ new Map();
  }
  if (cacheMap2 !== null) {
    const cacheFunctions = ["get", "set", "delete", "clear"];
    const missingFunctions = cacheFunctions.filter(
      (fnName) => cacheMap2 && typeof cacheMap2[fnName] !== "function"
    );
    if (missingFunctions.length !== 0) {
      throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
    }
  }
  return cacheMap2;
}
function getValidName(options) {
  if (options && options.name) {
    return options.name;
  }
  return null;
}
function isArrayLike(x) {
  return typeof x === "object" && x !== null && "length" in x && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
}

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/uleb.js
function ulebEncode(num2) {
  let bigNum = BigInt(num2);
  const arr = [];
  let len = 0;
  if (bigNum === 0n) {
    return [0];
  }
  while (bigNum > 0) {
    arr[len] = Number(bigNum & 0x7fn);
    if (bigNum >>= 7n) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0n;
  let shift = 0n;
  let len = 0;
  while (true) {
    if (len >= arr.length) {
      throw new Error("ULEB decode error: buffer overflow");
    }
    const byte = arr[len];
    len += 1;
    total += BigInt(byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7n;
  }
  if (total > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("ULEB decode error: value exceeds MAX_SAFE_INTEGER");
  }
  return {
    value: Number(total),
    length: len
  };
}

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/reader.js
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    const value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    const value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    const value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    const value1 = this.read32();
    const value2 = this.read32();
    const result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    const value1 = BigInt(this.read64());
    const value2 = BigInt(this.read64());
    const result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    const value1 = BigInt(this.read128());
    const value2 = BigInt(this.read128());
    const result = value2.toString(16) + value1.toString(16).padStart(32, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num2) {
    const start = this.bytePosition + this.dataView.byteOffset;
    const value = new Uint8Array(this.dataView.buffer, start, num2);
    this.shift(num2);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    const start = this.bytePosition + this.dataView.byteOffset;
    const buffer = new Uint8Array(this.dataView.buffer, start);
    const { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    const length = this.readULEB();
    const result = [];
    for (let i = 0; i < length; i++) {
      result.push(cb(this, i, length));
    }
    return result;
  }
};

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/utils.js
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toBase58(data);
    case "base64":
      return toBase64(data);
    case "hex":
      return toHex(data);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function splitGenericParameters(str, genericSeparators = ["<", ">"]) {
  const [left, right] = genericSeparators;
  const tok = [];
  let word = "";
  let nestedAngleBrackets = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (char === left) {
      nestedAngleBrackets++;
    }
    if (char === right) {
      nestedAngleBrackets--;
    }
    if (nestedAngleBrackets === 0 && char === ",") {
      tok.push(word.trim());
      word = "";
      continue;
    }
    word += char;
  }
  tok.push(word.trim());
  return tok;
}

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/writer.js
var BcsWriter = class {
  constructor({
    initialSize = 1024,
    maxSize = Infinity,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = initialSize;
    this.maxSize = maxSize;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(initialSize));
  }
  ensureSizeOrGrow(bytes) {
    const requiredSize = this.bytePosition + bytes;
    if (requiredSize > this.size) {
      const nextSize = Math.min(
        this.maxSize,
        Math.max(this.size + requiredSize, this.size + this.allocateSize)
      );
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeBytes(bytes) {
    this.ensureSizeOrGrow(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
      this.dataView.setUint8(this.bytePosition + i, bytes[i]);
    }
    return this.shift(bytes.length);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode(value).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector2, cb) {
    this.writeULEB(vector2.length);
    Array.from(vector2).forEach((el, i) => cb(this, el, i, vector2.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  // oxlint-disable-next-line require-yields
  *[Symbol.iterator]() {
    for (let i = 0; i < this.bytePosition; i++) {
      yield this.dataView.getUint8(i);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function toLittleEndian(bigint2, size) {
  const result = new Uint8Array(size);
  let i = 0;
  while (bigint2 > 0) {
    result[i] = Number(bigint2 % BigInt(256));
    bigint2 = bigint2 / BigInt(256);
    i += 1;
  }
  return result;
}

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write;
var _serialize;
var _schema;
var _bytes;
var _BcsType = class _BcsType2 {
  constructor(options) {
    __privateAdd2(this, _write);
    __privateAdd2(this, _serialize);
    this.name = options.name;
    this.read = options.read;
    this.serializedSize = options.serializedSize ?? (() => null);
    __privateSet2(this, _write, options.write);
    __privateSet2(this, _serialize, options.serialize ?? ((value, options2) => {
      const writer = new BcsWriter({
        initialSize: this.serializedSize(value) ?? void 0,
        ...options2
      });
      __privateGet2(this, _write).call(this, value, writer);
      return writer.toBytes();
    }));
    this.validate = options.validate ?? (() => {
    });
  }
  write(value, writer) {
    this.validate(value);
    __privateGet2(this, _write).call(this, value, writer);
  }
  serialize(value, options) {
    this.validate(value);
    return new SerializedBcs(this, __privateGet2(this, _serialize).call(this, value, options));
  }
  parse(bytes) {
    const reader = new BcsReader(bytes);
    return this.read(reader);
  }
  fromHex(hex) {
    return this.parse(fromHex(hex));
  }
  fromBase58(b64) {
    return this.parse(fromBase58(b64));
  }
  fromBase64(b64) {
    return this.parse(fromBase64(b64));
  }
  transform({
    name,
    input,
    output,
    validate: validate2
  }) {
    return new _BcsType2({
      name: name ?? this.name,
      read: (reader) => output ? output(this.read(reader)) : this.read(reader),
      write: (value, writer) => __privateGet2(this, _write).call(this, input ? input(value) : value, writer),
      serializedSize: (value) => this.serializedSize(input ? input(value) : value),
      serialize: (value, options) => __privateGet2(this, _serialize).call(this, input ? input(value) : value, options),
      validate: (value) => {
        validate2?.(value);
        this.validate(input ? input(value) : value);
      }
    });
  }
};
_write = /* @__PURE__ */ new WeakMap();
_serialize = /* @__PURE__ */ new WeakMap();
var BcsType = _BcsType;
var SERIALIZED_BCS_BRAND = Symbol.for("@mysten/serialized-bcs");
function isSerializedBcs(obj) {
  return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
var SerializedBcs = class {
  constructor(schema, bytes) {
    __privateAdd2(this, _schema);
    __privateAdd2(this, _bytes);
    __privateSet2(this, _schema, schema);
    __privateSet2(this, _bytes, bytes);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [SERIALIZED_BCS_BRAND]() {
    return true;
  }
  toBytes() {
    return __privateGet2(this, _bytes);
  }
  toHex() {
    return toHex(__privateGet2(this, _bytes));
  }
  toBase64() {
    return toBase64(__privateGet2(this, _bytes));
  }
  toBase58() {
    return toBase58(__privateGet2(this, _bytes));
  }
  parse() {
    return __privateGet2(this, _schema).parse(__privateGet2(this, _bytes));
  }
};
_schema = /* @__PURE__ */ new WeakMap();
_bytes = /* @__PURE__ */ new WeakMap();
function fixedSizeBcsType({
  size,
  ...options
}) {
  return new BcsType({
    ...options,
    serializedSize: () => size
  });
}
function uIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](value),
    validate: (value) => {
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value);
    }
  });
}
function bigUIntBcsType({
  readMethod,
  writeMethod,
  ...options
}) {
  return fixedSizeBcsType({
    ...options,
    read: (reader) => reader[readMethod](),
    write: (value, writer) => writer[writeMethod](BigInt(value)),
    validate: (val) => {
      const value = BigInt(val);
      if (value < 0 || value > options.maxValue) {
        throw new TypeError(
          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`
        );
      }
      options.validate?.(value);
    }
  });
}
function dynamicSizeBcsType({
  serialize,
  ...options
}) {
  const type = new BcsType({
    ...options,
    serialize,
    write: (value, writer) => {
      for (const byte of type.serialize(value).toBytes()) {
        writer.write8(byte);
      }
    }
  });
  return type;
}
function stringLikeBcsType({
  toBytes,
  fromBytes,
  ...options
}) {
  return new BcsType({
    ...options,
    read: (reader) => {
      const length = reader.readULEB();
      const bytes = reader.readBytes(length);
      return fromBytes(bytes);
    },
    write: (hex, writer) => {
      const bytes = toBytes(hex);
      writer.writeULEB(bytes.length);
      for (let i = 0; i < bytes.length; i++) {
        writer.write8(bytes[i]);
      }
    },
    serialize: (value) => {
      const bytes = toBytes(value);
      const size = ulebEncode(bytes.length);
      const result = new Uint8Array(size.length + bytes.length);
      result.set(size, 0);
      result.set(bytes, size.length);
      return result;
    },
    validate: (value) => {
      if (typeof value !== "string") {
        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
      }
      options.validate?.(value);
    }
  });
}
function lazyBcsType(cb) {
  let lazyType = null;
  function getType() {
    if (!lazyType) {
      lazyType = cb();
    }
    return lazyType;
  }
  return new BcsType({
    name: "lazy",
    read: (data) => getType().read(data),
    serializedSize: (value) => getType().serializedSize(value),
    write: (value, writer) => getType().write(value, writer),
    serialize: (value, options) => getType().serialize(value, options).toBytes()
  });
}
var BcsStruct = class extends BcsType {
  constructor({ name, fields, ...options }) {
    const canonicalOrder = Object.entries(fields);
    super({
      name,
      serializedSize: (values) => {
        let total = 0;
        for (const [field, type] of canonicalOrder) {
          const size = type.serializedSize(values[field]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = {};
        for (const [field, type] of canonicalOrder) {
          result[field] = type.read(reader);
        }
        return result;
      },
      write: (value, writer) => {
        for (const [field, type] of canonicalOrder) {
          type.write(value[field], writer);
        }
      },
      ...options,
      validate: (value) => {
        options?.validate?.(value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
      }
    });
  }
};
var BcsEnum = class extends BcsType {
  constructor({ fields, ...options }) {
    const canonicalOrder = Object.entries(fields);
    super({
      read: (reader) => {
        const index = reader.readULEB();
        const enumEntry = canonicalOrder[index];
        if (!enumEntry) {
          throw new TypeError(`Unknown value ${index} for enum ${options.name}`);
        }
        const [kind, type] = enumEntry;
        return {
          [kind]: type?.read(reader) ?? true,
          $kind: kind
        };
      },
      write: (value, writer) => {
        const [name, val] = Object.entries(value).filter(
          ([name2]) => Object.hasOwn(fields, name2)
        )[0];
        for (let i = 0; i < canonicalOrder.length; i++) {
          const [optionName, optionType] = canonicalOrder[i];
          if (optionName === name) {
            writer.writeULEB(i);
            optionType?.write(val, writer);
            return;
          }
        }
      },
      ...options,
      validate: (value) => {
        options?.validate?.(value);
        if (typeof value !== "object" || value == null) {
          throw new TypeError(`Expected object, found ${typeof value}`);
        }
        const keys = Object.keys(value).filter(
          (k) => value[k] !== void 0 && Object.hasOwn(fields, k)
        );
        if (keys.length !== 1) {
          throw new TypeError(
            `Expected object with one key, but found ${keys.length} for type ${options.name}}`
          );
        }
        const [variant] = keys;
        if (!Object.hasOwn(fields, variant)) {
          throw new TypeError(`Invalid enum variant ${variant}`);
        }
      }
    });
  }
};
var BcsTuple = class extends BcsType {
  constructor({ fields, name, ...options }) {
    super({
      name: name ?? `(${fields.map((t) => t.name).join(", ")})`,
      serializedSize: (values) => {
        let total = 0;
        for (let i = 0; i < fields.length; i++) {
          const size = fields[i].serializedSize(values[i]);
          if (size == null) {
            return null;
          }
          total += size;
        }
        return total;
      },
      read: (reader) => {
        const result = [];
        for (const field of fields) {
          result.push(field.read(reader));
        }
        return result;
      },
      write: (value, writer) => {
        for (let i = 0; i < fields.length; i++) {
          fields[i].write(value[i], writer);
        }
      },
      ...options,
      validate: (value) => {
        options?.validate?.(value);
        if (!Array.isArray(value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== fields.length) {
          throw new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);
        }
      }
    });
  }
};

// node_modules/.pnpm/@mysten+bcs@1.9.1/node_modules/@mysten/bcs/dist/esm/bcs.js
function fixedArray(size, type, options) {
  return new BcsType({
    read: (reader) => {
      const result = new Array(size);
      for (let i = 0; i < size; i++) {
        result[i] = type.read(reader);
      }
      return result;
    },
    write: (value, writer) => {
      for (const item of value) {
        type.write(item, writer);
      }
    },
    ...options,
    name: options?.name ?? `${type.name}[${size}]`,
    validate: (value) => {
      options?.validate?.(value);
      if (!value || typeof value !== "object" || !("length" in value)) {
        throw new TypeError(`Expected array, found ${typeof value}`);
      }
      if (value.length !== size) {
        throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
      }
    }
  });
}
function option(type) {
  return bcs.enum(`Option<${type.name}>`, {
    None: null,
    Some: type
  }).transform({
    input: (value) => {
      if (value == null) {
        return { None: true };
      }
      return { Some: value };
    },
    output: (value) => {
      if (value.$kind === "Some") {
        return value.Some;
      }
      return null;
    }
  });
}
function vector(type, options) {
  return new BcsType({
    read: (reader) => {
      const length = reader.readULEB();
      const result = new Array(length);
      for (let i = 0; i < length; i++) {
        result[i] = type.read(reader);
      }
      return result;
    },
    write: (value, writer) => {
      writer.writeULEB(value.length);
      for (const item of value) {
        type.write(item, writer);
      }
    },
    ...options,
    name: options?.name ?? `vector<${type.name}>`,
    validate: (value) => {
      options?.validate?.(value);
      if (!value || typeof value !== "object" || !("length" in value)) {
        throw new TypeError(`Expected array, found ${typeof value}`);
      }
    }
  });
}
function map(keyType, valueType) {
  return bcs.vector(bcs.tuple([keyType, valueType])).transform({
    name: `Map<${keyType.name}, ${valueType.name}>`,
    input: (value) => {
      return [...value.entries()];
    },
    output: (value) => {
      const result = /* @__PURE__ */ new Map();
      for (const [key, val] of value) {
        result.set(key, val);
      }
      return result;
    }
  });
}
var bcs = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(options) {
    return uIntBcsType({
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...options,
      name: options?.name ?? "u8"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(options) {
    return uIntBcsType({
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...options,
      name: options?.name ?? "u16"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(options) {
    return uIntBcsType({
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...options,
      name: options?.name ?? "u32"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(options) {
    return bigUIntBcsType({
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...options,
      name: options?.name ?? "u64"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(options) {
    return bigUIntBcsType({
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...options,
      name: options?.name ?? "u128"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(options) {
    return bigUIntBcsType({
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...options,
      name: options?.name ?? "u256"
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(options) {
    return fixedSizeBcsType({
      size: 1,
      read: (reader) => reader.read8() === 1,
      write: (value, writer) => writer.write8(value ? 1 : 0),
      ...options,
      name: options?.name ?? "bool",
      validate: (value) => {
        options?.validate?.(value);
        if (typeof value !== "boolean") {
          throw new TypeError(`Expected boolean, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(options) {
    return dynamicSizeBcsType({
      read: (reader) => reader.readULEB(),
      serialize: (value) => {
        return Uint8Array.from(ulebEncode(value));
      },
      ...options,
      name: options?.name ?? "uleb128"
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(size, options) {
    return fixedSizeBcsType({
      size,
      read: (reader) => reader.readBytes(size),
      write: (value, writer) => {
        writer.writeBytes(new Uint8Array(value));
      },
      ...options,
      name: options?.name ?? `bytes[${size}]`,
      validate: (value) => {
        options?.validate?.(value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
        if (value.length !== size) {
          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(options) {
    return new BcsType({
      read: (reader) => {
        const length = reader.readULEB();
        return reader.readBytes(length);
      },
      write: (value, writer) => {
        const array2 = new Uint8Array(value);
        writer.writeULEB(array2.length);
        writer.writeBytes(array2);
      },
      ...options,
      name: options?.name ?? "vector<u8>",
      serializedSize: (value) => {
        const length = "length" in value ? value.length : null;
        return length == null ? null : ulebEncode(length).length + length;
      },
      validate: (value) => {
        options?.validate?.(value);
        if (!value || typeof value !== "object" || !("length" in value)) {
          throw new TypeError(`Expected array, found ${typeof value}`);
        }
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(options) {
    return stringLikeBcsType({
      toBytes: (value) => new TextEncoder().encode(value),
      fromBytes: (bytes) => new TextDecoder().decode(bytes),
      ...options,
      name: options?.name ?? "string"
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray,
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option,
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector,
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(fields, options) {
    return new BcsTuple({
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(name, fields, options) {
    return new BcsStruct({
      name,
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(name, fields, options) {
    return new BcsEnum({
      name,
      fields,
      ...options
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map,
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(cb) {
    return lazyBcsType(cb);
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/utils/suins.js
var SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;
var SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i;
var MAX_SUI_NS_NAME_LENGTH = 235;
function isValidSuiNSName(name) {
  if (name.length > MAX_SUI_NS_NAME_LENGTH) {
    return false;
  }
  if (name.includes("@")) {
    return SUI_NS_NAME_REGEX.test(name);
  }
  return SUI_NS_DOMAIN_REGEX.test(name);
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/utils/move-registry.js
var NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;
var VERSION_REGEX = /^\d+$/;
var MAX_APP_SIZE = 64;
var NAME_SEPARATOR = "/";
var isValidNamedPackage = (name) => {
  const parts = name.split(NAME_SEPARATOR);
  if (parts.length < 2 || parts.length > 3) return false;
  const [org, app, version] = parts;
  if (version !== void 0 && !VERSION_REGEX.test(version)) return false;
  if (!isValidSuiNSName(org)) return false;
  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;
};
var isValidNamedType = (type) => {
  const splitType = type.split(/::|<|>|,/);
  for (const t of splitType) {
    if (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;
  }
  return true;
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/utils/sui-types.js
var SUI_ADDRESS_LENGTH = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function parseTypeTag(type) {
  if (!type.includes("::")) return type;
  return parseStructTag(type);
}
function parseStructTag(type) {
  const [address, module] = type.split("::");
  const isMvrPackage = isValidNamedPackage(address);
  const rest = type.slice(address.length + module.length + 4);
  const name = rest.includes("<") ? rest.slice(0, rest.indexOf("<")) : rest;
  const typeParams = rest.includes("<") ? splitGenericParameters(rest.slice(rest.indexOf("<") + 1, rest.lastIndexOf(">"))).map(
    (typeParam) => parseTypeTag(typeParam.trim())
  ) : [];
  return {
    address: isMvrPackage ? address : normalizeSuiAddress(address),
    module,
    name,
    typeParams
  };
}
function normalizeStructTag(type) {
  const { address, module, name, typeParams } = typeof type === "string" ? parseStructTag(type) : type;
  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(
    (typeParam) => typeof typeParam === "string" ? typeParam : normalizeStructTag(typeParam)
  ).join(",")}>` : "";
  return `${address}::${module}::${name}${formattedTypeParams}`;
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/bcs/bcs.js
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return bcs.enum("Option", {
    None: null,
    Some: type
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  validate: (val) => {
    const address = typeof val === "string" ? val : toHex(val);
    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
      throw new Error(`Invalid Sui address ${address}`);
    }
  },
  input: (val) => typeof val === "string" ? fromHex(normalizeSuiAddress(val)) : val,
  output: (val) => normalizeSuiAddress(toHex(val))
});
var ObjectDigest = bcs.byteVector().transform({
  name: "ObjectDigest",
  input: (value) => fromBase58(value),
  output: (value) => toBase58(new Uint8Array(value)),
  validate: (value) => {
    if (fromBase58(value).length !== 32) {
      throw new Error("ObjectDigest must be 32 bytes");
    }
  }
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwnedObject: SuiObjectRef,
  SharedObject: SharedObjectRef,
  Receiving: SuiObjectRef
});
var Owner = bcs.enum("Owner", {
  AddressOwner: Address,
  ObjectOwner: Address,
  Shared: bcs.struct("Shared", {
    initialSharedVersion: bcs.u64()
  }),
  Immutable: null,
  ConsensusAddressOwner: bcs.struct("ConsensusAddressOwner", {
    owner: Address,
    startVersion: bcs.u64()
  })
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.struct("Pure", {
    bytes: bcs.byteVector().transform({
      input: (val) => typeof val === "string" ? fromBase64(val) : val,
      output: (val) => toBase64(new Uint8Array(val))
    })
  }),
  Object: ObjectArg
});
var InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)
});
var Argument = bcs.enum("Argument", {
  GasCoin: null,
  Input: bcs.u16(),
  Result: bcs.u16(),
  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])
});
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  typeArguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
});
var Command = bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ProgrammableMoveCall,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: bcs.struct("TransferObjects", {
    objects: bcs.vector(Argument),
    address: Argument
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: bcs.struct("SplitCoins", {
    coin: Argument,
    amounts: bcs.vector(Argument)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: bcs.struct("MergeCoins", {
    destination: Argument,
    sources: bcs.vector(Argument)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: bcs.struct("Publish", {
    modules: bcs.vector(
      bcs.byteVector().transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: bcs.struct("MakeMoveVec", {
    type: optionEnum(TypeTag).transform({
      input: (val) => val === null ? {
        None: true
      } : {
        Some: val
      },
      output: (val) => val.Some ?? null
    }),
    elements: bcs.vector(Argument)
  }),
  Upgrade: bcs.struct("Upgrade", {
    modules: bcs.vector(
      bcs.byteVector().transform({
        input: (val) => typeof val === "string" ? fromBase64(val) : val,
        output: (val) => toBase64(new Uint8Array(val))
      })
    ),
    dependencies: bcs.vector(Address),
    package: Address,
    ticket: Argument
  })
});
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  commands: bcs.vector(Command)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var IntentScope = bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
});
var IntentVersion = bcs.enum("IntentVersion", {
  V0: null
});
var AppId = bcs.enum("AppId", {
  Sui: null
});
var Intent = bcs.struct("Intent", {
  scope: IntentScope,
  version: IntentVersion,
  appId: AppId
});
function IntentMessage(T) {
  return bcs.struct(`IntentMessage<${T.name}>`, {
    intent: Intent,
    value: T
  });
}
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.bytes(64),
  Secp256k1: bcs.bytes(64),
  Secp256r1: bcs.bytes(64),
  ZkLogin: bcs.byteVector(),
  Passkey: bcs.byteVector()
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.bytes(32),
  Secp256k1: bcs.bytes(33),
  Secp256r1: bcs.bytes(33),
  ZkLogin: bcs.byteVector(),
  Passkey: bcs.bytes(33)
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var base64String = bcs.byteVector().transform({
  input: (val) => typeof val === "string" ? fromBase64(val) : val,
  output: (val) => toBase64(new Uint8Array(val))
});
var SenderSignedTransaction = bcs.struct("SenderSignedTransaction", {
  intentMessage: IntentMessage(TransactionData),
  txSignatures: bcs.vector(base64String)
});
var SenderSignedData = bcs.vector(SenderSignedTransaction, {
  name: "SenderSignedData"
});
var PasskeyAuthenticator = bcs.struct("PasskeyAuthenticator", {
  authenticatorData: bcs.byteVector(),
  clientDataJson: bcs.string(),
  userSignature: bcs.byteVector()
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/bcs/effects.js
var PackageUpgradeError = bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: bcs.struct("UnableToFetchPackage", { packageId: Address }),
  NotAPackage: bcs.struct("NotAPackage", { objectId: Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: bcs.struct("DigestDoesNotMatch", { digest: bcs.byteVector() }),
  UnknownUpgradePolicy: bcs.struct("UnknownUpgradePolicy", { policy: bcs.u8() }),
  PackageIDDoesNotMatch: bcs.struct("PackageIDDoesNotMatch", {
    packageId: Address,
    ticketId: Address
  })
});
var ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
var MoveLocation = bcs.struct("MoveLocation", {
  module: ModuleId,
  function: bcs.u16(),
  instruction: bcs.u16(),
  functionName: bcs.option(bcs.string())
});
var CommandArgumentError = bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: bcs.struct("IndexOutOfBounds", { idx: bcs.u16() }),
  SecondaryIndexOutOfBounds: bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidResultArity: bcs.struct("InvalidResultArity", { resultIdx: bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
});
var TypeArgumentError = bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
});
var ExecutionFailureStatus = bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: bcs.struct("MoveObjectTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  MovePackageTooBig: bcs.struct("MovePackageTooBig", {
    objectSize: bcs.u64(),
    maxObjectSize: bcs.u64()
  }),
  CircularObjectOwnership: bcs.struct("CircularObjectOwnership", { object: Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: bcs.option(MoveLocation),
  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: bcs.struct("CommandArgumentError", {
    argIdx: bcs.u16(),
    kind: CommandArgumentError
  }),
  TypeArgumentError: bcs.struct("TypeArgumentError", {
    argumentIdx: bcs.u16(),
    kind: TypeArgumentError
  }),
  UnusedValueWithoutDrop: bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: bcs.u16(),
    secondaryIdx: bcs.u16()
  }),
  InvalidPublicFunctionReturnType: bcs.struct("InvalidPublicFunctionReturnType", {
    idx: bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: bcs.struct("EffectsTooLarge", { currentSize: bcs.u64(), maxSize: bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: bcs.struct("PackageUpgradeError", { upgradeError: PackageUpgradeError }),
  WrittenObjectsTooLarge: bcs.struct("WrittenObjectsTooLarge", {
    currentSize: bcs.u64(),
    maxSize: bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: bcs.vector(Address)
    }
  ),
  AddressDeniedForCoin: bcs.struct("AddressDeniedForCoin", {
    address: Address,
    coinType: bcs.string()
  }),
  CoinTypeGlobalPause: bcs.struct("CoinTypeGlobalPause", { coinType: bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
});
var ExecutionStatus = bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: bcs.struct("ExecutionFailed", {
    error: ExecutionFailureStatus,
    command: bcs.option(bcs.u64())
  })
});
var GasCostSummary = bcs.struct("GasCostSummary", {
  computationCost: bcs.u64(),
  storageCost: bcs.u64(),
  storageRebate: bcs.u64(),
  nonRefundableStorageFee: bcs.u64()
});
var TransactionEffectsV1 = bcs.struct("TransactionEffectsV1", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),
  sharedObjects: bcs.vector(SuiObjectRef),
  transactionDigest: ObjectDigest,
  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),
  deleted: bcs.vector(SuiObjectRef),
  unwrappedThenDeleted: bcs.vector(SuiObjectRef),
  wrapped: bcs.vector(SuiObjectRef),
  gasObject: bcs.tuple([SuiObjectRef, Owner]),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest)
});
var VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);
var ObjectIn = bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: bcs.tuple([VersionDigest, Owner])
});
var ObjectOut = bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),
  PackageWrite: VersionDigest
});
var IDOperation = bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
});
var EffectsObjectChange = bcs.struct("EffectsObjectChange", {
  inputState: ObjectIn,
  outputState: ObjectOut,
  idOperation: IDOperation
});
var UnchangedSharedKind = bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: VersionDigest,
  // TODO: these have been renamed to MutateConsensusStreamEnded and ReadConsensusStreamEnded
  MutateDeleted: bcs.u64(),
  ReadDeleted: bcs.u64(),
  Cancelled: bcs.u64(),
  PerEpochConfig: null
});
var TransactionEffectsV2 = bcs.struct("TransactionEffectsV2", {
  status: ExecutionStatus,
  executedEpoch: bcs.u64(),
  gasUsed: GasCostSummary,
  transactionDigest: ObjectDigest,
  gasObjectIndex: bcs.option(bcs.u32()),
  eventsDigest: bcs.option(ObjectDigest),
  dependencies: bcs.vector(ObjectDigest),
  lamportVersion: bcs.u64(),
  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),
  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),
  auxDataDigest: bcs.option(ObjectDigest)
});
var TransactionEffects = bcs.enum("TransactionEffects", {
  V1: TransactionEffectsV1,
  V2: TransactionEffectsV2
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/bcs/pure.js
function pureBcsSchemaFromTypeName(name) {
  switch (name) {
    case "u8":
      return bcs.u8();
    case "u16":
      return bcs.u16();
    case "u32":
      return bcs.u32();
    case "u64":
      return bcs.u64();
    case "u128":
      return bcs.u128();
    case "u256":
      return bcs.u256();
    case "bool":
      return bcs.bool();
    case "string":
      return bcs.string();
    case "id":
    case "address":
      return Address;
  }
  const generic = name.match(/^(vector|option)<(.+)>$/);
  if (generic) {
    const [kind, inner] = generic.slice(1);
    if (kind === "vector") {
      return bcs.vector(pureBcsSchemaFromTypeName(inner));
    } else {
      return bcs.option(pureBcsSchemaFromTypeName(inner));
    }
  }
  throw new Error(`Invalid Pure type name: ${name}`);
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/bcs/index.js
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  AppId,
  Argument,
  CallArg,
  Command,
  CompressedSignature,
  GasData,
  Intent,
  IntentMessage,
  IntentScope,
  IntentVersion,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  Owner,
  PasskeyAuthenticator,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SenderSignedTransaction,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  TransactionData,
  TransactionDataV1,
  TransactionEffects,
  TransactionExpiration,
  TransactionKind,
  TypeTag
};

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE2(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE2(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE2(n, len).reverse();
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange2(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange2(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n) => (_1n << BigInt(n)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object2, fields, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map3 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map3.get(arg);
    if (val !== void 0)
      return val;
    const computed2 = fn(arg, ...args);
    map3.set(arg, computed2);
    return computed2;
  };
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod2(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function assertIsSquare(Fp2, root, n) {
  if (!Fp2.eql(Fp2.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp2, n) {
  const p1div4 = (Fp2.ORDER + _1n2) / _4n;
  const root = Fp2.pow(n, p1div4);
  assertIsSquare(Fp2, root, n);
  return root;
}
function sqrt5mod8(Fp2, n) {
  const p5div8 = (Fp2.ORDER - _5n) / _8n;
  const n2 = Fp2.mul(n, _2n);
  const v = Fp2.pow(n2, p5div8);
  const nv = Fp2.mul(n, v);
  const i = Fp2.mul(Fp2.mul(nv, _2n), v);
  const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
  assertIsSquare(Fp2, root, n);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field2(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp2, n) => {
    let tv1 = Fp2.pow(n, c4);
    let tv2 = Fp2.mul(tv1, c1);
    const tv3 = Fp2.mul(tv1, c2);
    const tv4 = Fp2.mul(tv1, c3);
    const e1 = Fp2.eql(Fp2.sqr(tv2), n);
    const e2 = Fp2.eql(Fp2.sqr(tv3), n);
    tv1 = Fp2.cmov(tv1, tv2, e1);
    tv2 = Fp2.cmov(tv4, tv3, e2);
    const e3 = Fp2.eql(Fp2.sqr(tv2), n);
    const root = Fp2.cmov(tv1, tv2, e3);
    assertIsSquare(Fp2, root, n);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field2(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.is0(n))
      return n;
    if (FpLegendre(Fp2, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp2.mul(Fp2.ONE, cc);
    let t = Fp2.pow(n, Q);
    let R = Fp2.pow(n, Q1div2);
    while (!Fp2.eql(t, Fp2.ONE)) {
      if (Fp2.is0(t))
        return Fp2.ZERO;
      let i = 1;
      let t_tmp = Fp2.sqr(t);
      while (!Fp2.eql(t_tmp, Fp2.ONE)) {
        i++;
        t_tmp = Fp2.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp2.pow(c, exponent);
      M = i;
      c = Fp2.sqr(b);
      t = Fp2.mul(t, c);
      R = Fp2.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var isNegativeLE = (num2, modulo) => (mod2(num2, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map3, val) => {
    map3[val] = "function";
    return map3;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp2, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp2.ONE;
  if (power === _1n2)
    return num2;
  let p = Fp2.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp2.mul(p, d);
    d = Fp2.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp2, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp2.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp2.mul(acc, num2);
  }, Fp2.ONE);
  const invertedAcc = Fp2.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp2.is0(num2))
      return acc;
    inverted[i] = Fp2.mul(acc, inverted[i]);
    return Fp2.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp2, n) {
  const p1mod2 = (Fp2.ORDER - _1n2) / _2n;
  const powered = Fp2.pow(n, p1mod2);
  const yes = Fp2.eql(powered, Fp2.ONE);
  const zero = Fp2.eql(powered, Fp2.ZERO);
  const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modOnDecode = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE = _opts.isLE;
    if (typeof _opts.modOnDecode === "boolean")
      modOnDecode = _opts.modOnDecode;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num2) => mod2(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    // is valid and invertible
    isValidNot0: (num2) => !f.is0(num2) && f.isValid(num2),
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod2(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod2(num2 * num2, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f, num2, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num2) => isLE ? numberToBytesLE(num2, BYTES) : numberToBytesBE2(num2, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE2(bytes);
      if (modOnDecode)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp2, elm) {
  if (!Fp2.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp2.sqrt(elm);
  return Fp2.isOdd(root) ? Fp2.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE ? bytesToNumberLE(key) : bytesToNumberBE2(key);
  const reduced = mod2(num2, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE2;
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand, DST } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod2(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
var _DST_scalar = utf8ToBytes("HashToScalar-");
function createHasher3(Point2, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map3(num2) {
    return Point2.fromAffine(mapToCurve(num2));
  }
  function clear2(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point2.ZERO))
      return Point2.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map3(u[0]);
      const u1 = map3(u[1]);
      return clear2(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map3(u[0]);
      return clear2(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear2(map3(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N = Point2.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n, p = this.ZERO) {
    let d = elm;
    while (n > _0n3) {
      if (n & _1n3)
        p = p.add(d);
      d = d.double();
      n >>= _1n3;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i = 1; i < windowSize; i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n);
    return acc;
  }
  getPrecomputes(W, point, transform2) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform2 === "function")
          comp = transform2(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform2) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform2), scalar);
  }
  unsafe(point, scalar, transform2, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform2), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field2(order);
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp2 = createField(CURVE.p, curveOpts.Fp);
  const Fn2 = createField(CURVE.n, curveOpts.Fn);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp2.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp2, Fn: Fn2 };
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
function _splitEndoScalar(k, basis, n) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n4;
  const k2neg = k2 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k2 < _0n4 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes2("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function _legacyHelperEquat(Fp2, a, b) {
  function weierstrassEquation(x) {
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  return weierstrassEquation;
}
function _normFnElement2(Fn2, key) {
  const { BYTES: expected } = Fn2;
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else {
    let bytes = ensureBytes2("private key", key);
    try {
      num2 = Fn2.fromBytes(bytes);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn2.isValidNot0(num2))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num2;
}
function weierstrassN(CURVE, curveOpts = {}) {
  const { Fp: Fp2, Fn: Fn2 } = _createCurveFields("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp2.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp2.toBytes(x);
    abool("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp2.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp2.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes(bytes);
    const L = Fp2.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length === LC && (head === 2 || head === 3)) {
      const x = Fp2.fromBytes(tail);
      if (!Fp2.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp2.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp2.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp2.neg(y);
      return { x, y };
    } else if (length === LU && head === 4) {
      const x = Fp2.fromBytes(tail.subarray(L * 0, L * 1));
      const y = Fp2.fromBytes(tail.subarray(L * 1, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes = curveOpts.toBytes || pointToBytes2;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat(Fp2, CURVE.a, CURVE.b);
  function isValidXY(x, y) {
    const left = Fp2.sqr(y);
    const right = weierstrassEquation(x);
    return Fp2.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
  if (Fp2.is0(Fp2.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp2.isValid(n) || banZero && Fp2.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    if (Fp2.eql(Z, Fp2.ONE))
      return { x: X, y: Y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(Z);
    const x = Fp2.mul(X, iz);
    const y = Fp2.mul(Y, iz);
    const zz = Fp2.mul(Z, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp2.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp2.isValid(x) || !Fp2.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp2.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp2.is0(x) && Fp2.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, points);
    }
    static fromBytes(bytes) {
      abytes(bytes);
      return Point2.fromHex(bytes);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(_normFnElement2(Fn2, privateKey));
    }
    // TODO: remove
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp2.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp2.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.X, Fp2.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point2, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(Point2, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn2.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p.is0())
        return Point2.ZERO;
      if (sc === _1n4)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes(Point2, this, isCompressed);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  Point2.Fp = Fp2;
  Point2.Fn = Fn2;
  const bits = Fn2.BITS;
  const wnaf = new wNAF(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n2 === _0n4; o /= _2n2)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n2 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n2;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n2);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n2;
      tv52 = _2n2 << tv52 - _1n4;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU2(Fp2, opts) {
  validateField(Fp2);
  const { A, B, Z } = opts;
  if (!Fp2.isValid(A) || !Fp2.isValid(B) || !Fp2.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, Z);
  if (!Fp2.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, B);
    tv4 = Fp2.cmov(Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp2, [tv4], true)[0];
    x = Fp2.mul(x, tv4_inv);
    return { x, y };
  };
}
function ecdsa(Point2, hash, ecdsaOpts = {}) {
  ahash(hash);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
  const { Fp: Fp2, Fn: Fn2 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
  const seedLen = getMinHashLength(CURVE_ORDER);
  const lengths = {
    secret: Fn2.BYTES,
    public: 1 + Fp2.BYTES,
    publicUncompressed: 1 + 2 * Fp2.BYTES,
    signature: 2 * Fn2.BYTES,
    seed: seedLen
  };
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn2.neg(s) : s;
  }
  function aValidRS(title, num2) {
    if (!Fn2.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }
  class Signature {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes, format = "compact") {
      if (format === "compact") {
        const L = Fn2.BYTES;
        abytes(bytes, L * 2);
        const r = bytes.subarray(0, L);
        const s = bytes.subarray(L, L * 2);
        return new Signature(Fn2.fromBytes(r), Fn2.fromBytes(s));
      }
      if (format === "der") {
        abytes(bytes);
        const { r, s } = DER.toSig(bytes);
        return new Signature(r, s);
      }
      throw new Error("invalid format");
    }
    static fromHex(hex, format) {
      return this.fromBytes(hexToBytes(hex), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    // ProjPointType<bigint>
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp2.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp2.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp2.toBytes(radj);
      const R = Point2.fromHex(concatBytes(pprefix((rec & 1) === 0), x));
      const ir = Fn2.inv(radj);
      const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
      const u1 = Fn2.create(-h * ir);
      const u2 = Fn2.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn2.neg(this.s), this.recovery) : this;
    }
    toBytes(format = "compact") {
      if (format === "compact")
        return concatBytes(Fn2.toBytes(this.r), Fn2.toBytes(this.s));
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      throw new Error("invalid format");
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex) {
      return Signature.fromBytes(ensureBytes2("sig", hex), "compact");
    }
    static fromDER(hex) {
      return Signature.fromBytes(ensureBytes2("sig", hex), "der");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  function isValidSecretKey(privateKey) {
    try {
      return !!_normFnElement2(Fn2, privateKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== lengths.public)
        return false;
      if (isCompressed === false && l !== lengths.publicUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(seedLen)) {
    return mapHashToField2(seed, CURVE_ORDER);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement2(Fn2, key),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(_normFnElement2(Fn2, secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    if (Fn2.allowedLengths || lengths.secret === lengths.public)
      return void 0;
    const l = ensureBytes2("key", item).length;
    return l === lengths.public || l === lengths.publicUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = _normFnElement2(Fn2, secretKeyA);
    const b = Point2.fromHex(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE2(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes) {
    return Fn2.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
    return Fn2.toBytes(num2);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = _normFnElement2(Fn2, privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(lengths.secret) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn2.isValidNot0(k))
        return;
      const ik = Fn2.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn2.create(q.x);
      if (r === _0n4)
        return;
      const s = Fn2.create(ik * Fn2.create(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign(msgHash, secretKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn2.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point2.BASE.precompute(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    validateSigVerOpts(opts);
    const { lowS, prehash, format } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    let _sig = void 0;
    let P;
    if (format === void 0) {
      const isHex2 = typeof sg === "string" || isBytes(sg);
      const isObj = !isHex2 && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex2 && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      if (isObj) {
        _sig = new Signature(sg.r, sg.s);
      } else if (isHex2) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig) {
          try {
            _sig = Signature.fromCompact(sg);
          } catch (error) {
            return false;
          }
        }
      }
    } else {
      if (format === "compact" || format === "der") {
        if (typeof sg !== "string" && !isBytes(sg))
          throw new Error('"der" / "compact" format expects Uint8Array signature');
        _sig = Signature.fromBytes(ensureBytes2("sig", sg), format);
      } else if (format === "js") {
        if (!(sg instanceof Signature))
          throw new Error('"js" format expects Signature instance');
        _sig = sg;
      } else {
        throw new Error('format must be "compact", "der" or "js"');
      }
    }
    if (!_sig)
      return false;
    try {
      P = Point2.fromHex(publicKey);
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is2 = Fn2.inv(s);
      const u1 = Fn2.create(h * is2);
      const u2 = Fn2.create(r * is2);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn2.create(R.x);
      return v === r;
    } catch (e) {
      return false;
    }
  }
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    getSharedSecret,
    utils,
    Point: Point2,
    Signature,
    info: { type: "weierstrass", lengths, publicKeyHasPrefix: true }
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp2 = c.Fp;
  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
  const Fn2 = Field2(CURVE.n, {
    BITS: c.nBitLength,
    allowedLengths,
    modOnDecode: c.wrapPrivateKey
  });
  const curveOpts = {
    Fp: Fp2,
    Fn: Fn2,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, ecdsa2) {
  return Object.assign({}, ecdsa2, {
    ProjectivePoint: ecdsa2.Point,
    CURVE: c
  });
}
function weierstrass(c) {
  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point2 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point2, hash, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve2(curveDef, defHash) {
  const create = (hash) => weierstrass({ ...curveDef, hash });
  return { ...create(defHash), create };
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/nist.js
var p256_CURVE = {
  p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  h: BigInt(1),
  a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
  b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
};
var p384_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  h: BigInt(1),
  a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
  b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
};
var p521_CURVE = {
  p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  h: BigInt(1),
  a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
  b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};
var Fp256 = Field2(p256_CURVE.p);
var Fp384 = Field2(p384_CURVE.p);
var Fp521 = Field2(p521_CURVE.p);
function createSWU(Point2, opts) {
  const map3 = mapToCurveSimpleSWU2(Point2.Fp, opts);
  return (scalars) => map3(scalars[0]);
}
var p256 = createCurve2({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha256);
var p256_hasher = (() => {
  return createHasher3(p256.Point, createSWU(p256.Point, {
    A: p256_CURVE.a,
    B: p256_CURVE.b,
    Z: p256.Point.Fp.create(BigInt("-10"))
  }), {
    DST: "P256_XMD:SHA-256_SSWU_RO_",
    encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
    p: p256_CURVE.p,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256
  });
})();
var p384 = createCurve2({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);
var p384_hasher = (() => {
  return createHasher3(p384.Point, createSWU(p384.Point, {
    A: p384_CURVE.a,
    B: p384_CURVE.b,
    Z: p384.Point.Fp.create(BigInt("-12"))
  }), {
    DST: "P384_XMD:SHA-384_SSWU_RO_",
    encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
    p: p384_CURVE.p,
    m: 1,
    k: 192,
    expand: "xmd",
    hash: sha384
  });
})();
var p521 = createCurve2({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha512);
var p521_hasher = (() => {
  return createHasher3(p521.Point, createSWU(p521.Point, {
    A: p521_CURVE.a,
    B: p521_CURVE.b,
    Z: p521.Point.Fp.create(BigInt("-4"))
  }), {
    DST: "P521_XMD:SHA-512_SSWU_RO_",
    encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
    p: p521_CURVE.p,
    m: 1,
    k: 256,
    expand: "xmd",
    hash: sha512
  });
})();

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/p256.js
var secp256r1 = p256;
var hashToCurve = (() => p256_hasher.hashToCurve)();
var encodeToCurve = (() => p256_hasher.encodeToCurve)();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/intent.js
function messageWithIntent(scope, message) {
  return suiBcs.IntentMessage(suiBcs.bytes(message.length)).serialize({
    intent: {
      scope: { [scope]: true },
      version: { V0: true },
      appId: { Sui: true }
    },
    value: message
  }).toBytes();
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/signature-scheme.js
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  ZkLogin: 5,
  Passkey: 6
};
var SIGNATURE_SCHEME_TO_SIZE = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33,
  Passkey: 33
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "ZkLogin",
  6: "Passkey"
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/publickey.js
function bytesEqual(a, b) {
  if (a === b) return true;
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var PublicKey2 = class {
  /**
   * Checks if two public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());
  }
  /**
   * Return the base-64 representation of the public key
   */
  toBase64() {
    return toBase64(this.toRawBytes());
  }
  toString() {
    throw new Error(
      "`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead."
    );
  }
  /**
   * Return the Sui representation of the public key encoded in
   * base-64. A Sui public key is formed by the concatenation
   * of the scheme flag with the raw bytes of the public key
   */
  toSuiPublicKey() {
    const bytes = this.toSuiBytes();
    return toBase64(bytes);
  }
  verifyWithIntent(bytes, signature, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    return this.verify(digest, signature);
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    return this.verifyWithIntent(
      suiBcs.byteVector().serialize(message).toBytes(),
      signature,
      "PersonalMessage"
    );
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    return this.verifyWithIntent(transaction, signature, "TransactionData");
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return this.toSuiAddress() === address;
  }
  /**
   * Returns the bytes representation of the public key
   * prefixed with the signature scheme flag
   */
  toSuiBytes() {
    const rawBytes = this.toRawBytes();
    const suiBytes = new Uint8Array(rawBytes.length + 1);
    suiBytes.set([this.flag()]);
    suiBytes.set(rawBytes, 1);
    return suiBytes;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    return normalizeSuiAddress(
      bytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
    );
  }
};
function parseSerializedKeypairSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
      const signature = bytes.slice(1, bytes.length - size);
      const publicKey = bytes.slice(1 + signature.length);
      return {
        serializedSignature,
        signatureScheme,
        signature,
        publicKey,
        bytes
      };
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/keypairs/passkey/publickey.js
var PASSKEY_PUBLIC_KEY_SIZE = 33;
var PASSKEY_SIGNATURE_SIZE = 64;
var SECP256R1_SPKI_HEADER = new Uint8Array([
  48,
  89,
  // SEQUENCE, length 89
  48,
  19,
  // SEQUENCE, length 19
  6,
  7,
  // OID, length 7
  42,
  134,
  72,
  206,
  61,
  2,
  1,
  // OID: 1.2.840.10045.2.1 (ecPublicKey)
  6,
  8,
  // OID, length 8
  42,
  134,
  72,
  206,
  61,
  3,
  1,
  7,
  // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)
  3,
  66,
  // BIT STRING, length 66
  0
  // no unused bits
]);
var PasskeyPublicKey = class extends PublicKey2 {
  /**
   * Create a new PasskeyPublicKey object
   * @param value passkey public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two passkey public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Passkey"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    const parsed = parseSerializedPasskeySignature(signature);
    const clientDataJSON = JSON.parse(parsed.clientDataJson);
    if (clientDataJSON.type !== "webauthn.get") {
      return false;
    }
    const parsedChallenge = fromBase64(
      clientDataJSON.challenge.replace(/-/g, "+").replace(/_/g, "/")
    );
    if (!bytesEqual(message, parsedChallenge)) {
      return false;
    }
    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);
    if (!bytesEqual(this.toRawBytes(), pk)) {
      return false;
    }
    const payload = new Uint8Array([...parsed.authenticatorData, ...sha2562(parsed.clientDataJson)]);
    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);
    return secp256r1.verify(sig, sha2562(payload), pk);
  }
};
PasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;
function parseSerializedPasskeySignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {
    throw new Error("Invalid signature scheme");
  }
  const dec = PasskeyAuthenticator.parse(bytes.slice(1));
  return {
    signatureScheme: "Passkey",
    serializedSignature: toBase64(bytes),
    signature: bytes,
    authenticatorData: dec.authenticatorData,
    clientDataJson: dec.clientDataJson,
    userSignature: new Uint8Array(dec.userSignature),
    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))
  };
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/cache.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _prefix;
var _cache;
var _ClientCache = class _ClientCache2 {
  constructor({ prefix, cache } = {}) {
    __privateAdd3(this, _prefix);
    __privateAdd3(this, _cache);
    __privateSet3(this, _prefix, prefix ?? []);
    __privateSet3(this, _cache, cache ?? /* @__PURE__ */ new Map());
  }
  read(key, load) {
    const cacheKey = [__privateGet3(this, _prefix), ...key].join(":");
    if (__privateGet3(this, _cache).has(cacheKey)) {
      return __privateGet3(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet3(this, _cache).set(cacheKey, result);
    if (typeof result === "object" && result !== null && "then" in result) {
      return Promise.resolve(result).then((v) => {
        __privateGet3(this, _cache).set(cacheKey, v);
        return v;
      }).catch((err) => {
        __privateGet3(this, _cache).delete(cacheKey);
        throw err;
      });
    }
    return result;
  }
  readSync(key, load) {
    const cacheKey = [__privateGet3(this, _prefix), ...key].join(":");
    if (__privateGet3(this, _cache).has(cacheKey)) {
      return __privateGet3(this, _cache).get(cacheKey);
    }
    const result = load();
    __privateGet3(this, _cache).set(cacheKey, result);
    return result;
  }
  clear(prefix) {
    const prefixKey = [...__privateGet3(this, _prefix), ...prefix ?? []].join(":");
    if (!prefixKey) {
      __privateGet3(this, _cache).clear();
      return;
    }
    for (const key of __privateGet3(this, _cache).keys()) {
      if (key.startsWith(prefixKey)) {
        __privateGet3(this, _cache).delete(key);
      }
    }
  }
  scope(prefix) {
    return new _ClientCache2({
      prefix: [...__privateGet3(this, _prefix), ...Array.isArray(prefix) ? prefix : [prefix]],
      cache: __privateGet3(this, _cache)
    });
  }
};
_prefix = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
var ClientCache = _ClientCache;

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/client.js
var Experimental_BaseClient = class {
  constructor({
    network,
    base,
    cache = base?.cache ?? new ClientCache()
  }) {
    this.network = network;
    this.base = base ?? this;
    this.cache = cache;
  }
  $extend(...registrations) {
    return Object.create(
      this,
      Object.fromEntries(
        registrations.map((registration) => {
          return [registration.name, { value: registration.register(this) }];
        })
      )
    );
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/utils/dynamic-fields.js
function deriveDynamicFieldID(parentId, typeTag, key) {
  const address = suiBcs.Address.serialize(parentId).toBytes();
  const tag = suiBcs.TypeTag.serialize(typeTag).toBytes();
  const keyLength = suiBcs.u64().serialize(key.length).toBytes();
  const hash = blake2b.create({
    dkLen: 32
  });
  hash.update(new Uint8Array([240]));
  hash.update(address);
  hash.update(keyLength);
  hash.update(key);
  hash.update(tag);
  return `0x${toHex(hash.digest().slice(0, 32))}`;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/version.js
var PACKAGE_VERSION = "1.43.1";

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/mvr.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _cache2;
var _url;
var _pageSize;
var _overrides;
var _MvrClient_instances;
var mvrPackageDataLoader_get;
var mvrTypeDataLoader_get;
var resolvePackages_fn;
var resolveTypes_fn;
var fetch_fn2;
var NAME_SEPARATOR2 = "/";
var MVR_API_HEADER = {
  "Mvr-Source": `@mysten/sui@${PACKAGE_VERSION}`
};
var MvrClient = class {
  constructor({ cache, url, pageSize = 50, overrides }) {
    __privateAdd4(this, _MvrClient_instances);
    __privateAdd4(this, _cache2);
    __privateAdd4(this, _url);
    __privateAdd4(this, _pageSize);
    __privateAdd4(this, _overrides);
    __privateSet4(this, _cache2, cache);
    __privateSet4(this, _url, url);
    __privateSet4(this, _pageSize, pageSize);
    __privateSet4(this, _overrides, {
      packages: overrides?.packages,
      types: overrides?.types
    });
    validateOverrides(__privateGet4(this, _overrides));
  }
  async resolvePackage({
    package: name
  }) {
    if (!hasMvrName(name)) {
      return {
        package: name
      };
    }
    const resolved = await __privateGet4(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);
    return {
      package: resolved
    };
  }
  async resolveType({
    type
  }) {
    if (!hasMvrName(type)) {
      return {
        type
      };
    }
    const mvrTypes = [...extractMvrTypes(type)];
    const resolvedTypes = await __privateGet4(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);
    const typeMap = {};
    for (let i = 0; i < mvrTypes.length; i++) {
      const resolvedType = resolvedTypes[i];
      if (resolvedType instanceof Error) {
        throw resolvedType;
      }
      typeMap[mvrTypes[i]] = resolvedType;
    }
    return {
      type: replaceMvrNames(type, typeMap)
    };
  }
  async resolve({
    types = [],
    packages = []
  }) {
    const mvrTypes = /* @__PURE__ */ new Set();
    for (const type of types ?? []) {
      extractMvrTypes(type, mvrTypes);
    }
    const typesArray = [...mvrTypes];
    const [resolvedTypes, resolvedPackages] = await Promise.all([
      typesArray.length > 0 ? __privateGet4(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [],
      packages.length > 0 ? __privateGet4(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []
    ]);
    const typeMap = {
      ...__privateGet4(this, _overrides)?.types
    };
    for (const [i, type] of typesArray.entries()) {
      const resolvedType = resolvedTypes[i];
      if (resolvedType instanceof Error) {
        throw resolvedType;
      }
      typeMap[type] = resolvedType;
    }
    const replacedTypes = {};
    for (const type of types ?? []) {
      const resolvedType = replaceMvrNames(type, typeMap);
      replacedTypes[type] = {
        type: resolvedType
      };
    }
    const replacedPackages = {};
    for (const [i, pkg] of (packages ?? []).entries()) {
      const resolvedPkg = __privateGet4(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];
      if (resolvedPkg instanceof Error) {
        throw resolvedPkg;
      }
      replacedPackages[pkg] = {
        package: resolvedPkg
      };
    }
    return {
      types: replacedTypes,
      packages: replacedPackages
    };
  }
};
_cache2 = /* @__PURE__ */ new WeakMap();
_url = /* @__PURE__ */ new WeakMap();
_pageSize = /* @__PURE__ */ new WeakMap();
_overrides = /* @__PURE__ */ new WeakMap();
_MvrClient_instances = /* @__PURE__ */ new WeakSet();
mvrPackageDataLoader_get = function() {
  return __privateGet4(this, _cache2).readSync(["#mvrPackageDataLoader", __privateGet4(this, _url) ?? ""], () => {
    const loader = new DataLoader(async (packages) => {
      if (!__privateGet4(this, _url)) {
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${packages.join(", ")})`
        );
      }
      const resolved = await __privateMethod2(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);
      return packages.map(
        (pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`)
      );
    });
    const overrides = __privateGet4(this, _overrides)?.packages;
    if (overrides) {
      for (const [pkg, id] of Object.entries(overrides)) {
        loader.prime(pkg, id);
      }
    }
    return loader;
  });
};
mvrTypeDataLoader_get = function() {
  return __privateGet4(this, _cache2).readSync(["#mvrTypeDataLoader", __privateGet4(this, _url) ?? ""], () => {
    const loader = new DataLoader(async (types) => {
      if (!__privateGet4(this, _url)) {
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${types.join(", ")})`
        );
      }
      const resolved = await __privateMethod2(this, _MvrClient_instances, resolveTypes_fn).call(this, types);
      return types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));
    });
    const overrides = __privateGet4(this, _overrides)?.types;
    if (overrides) {
      for (const [type, id] of Object.entries(overrides)) {
        loader.prime(type, id);
      }
    }
    return loader;
  });
};
resolvePackages_fn = async function(packages) {
  if (packages.length === 0) return {};
  const batches = chunk(packages, __privateGet4(this, _pageSize));
  const results = {};
  await Promise.all(
    batches.map(async (batch) => {
      const data = await __privateMethod2(this, _MvrClient_instances, fetch_fn2).call(this, "/v1/resolution/bulk", {
        names: batch
      });
      if (!data?.resolution) return;
      for (const pkg of Object.keys(data?.resolution)) {
        const pkgData = data.resolution[pkg]?.package_id;
        if (!pkgData) continue;
        results[pkg] = pkgData;
      }
    })
  );
  return results;
};
resolveTypes_fn = async function(types) {
  if (types.length === 0) return {};
  const batches = chunk(types, __privateGet4(this, _pageSize));
  const results = {};
  await Promise.all(
    batches.map(async (batch) => {
      const data = await __privateMethod2(this, _MvrClient_instances, fetch_fn2).call(this, "/v1/struct-definition/bulk", {
        types: batch
      });
      if (!data?.resolution) return;
      for (const type of Object.keys(data?.resolution)) {
        const typeData = data.resolution[type]?.type_tag;
        if (!typeData) continue;
        results[type] = typeData;
      }
    })
  );
  return results;
};
fetch_fn2 = async function(url, body) {
  if (!__privateGet4(this, _url)) {
    throw new Error("MVR Api URL is not set for the current client");
  }
  const response = await fetch(`${__privateGet4(this, _url)}${url}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...MVR_API_HEADER
    },
    body: JSON.stringify(body)
  });
  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}));
    throw new Error(`Failed to resolve types: ${errorBody?.message}`);
  }
  return response.json();
};
function validateOverrides(overrides) {
  if (overrides?.packages) {
    for (const [pkg, id] of Object.entries(overrides.packages)) {
      if (!isValidNamedPackage(pkg)) {
        throw new Error(`Invalid package name: ${pkg}`);
      }
      if (!isValidSuiAddress(normalizeSuiAddress(id))) {
        throw new Error(`Invalid package ID: ${id}`);
      }
    }
  }
  if (overrides?.types) {
    for (const [type, val] of Object.entries(overrides.types)) {
      if (parseStructTag(type).typeParams.length > 0) {
        throw new Error(
          "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
        );
      }
      const parsedValue = parseStructTag(val);
      if (!isValidSuiAddress(parsedValue.address)) {
        throw new Error(`Invalid type: ${val}`);
      }
    }
  }
}
function extractMvrTypes(type, types = /* @__PURE__ */ new Set()) {
  if (typeof type === "string" && !hasMvrName(type)) return types;
  const tag = isStructTag(type) ? type : parseStructTag(type);
  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);
  for (const param of tag.typeParams) {
    extractMvrTypes(param, types);
  }
  return types;
}
function replaceMvrNames(tag, typeCache) {
  const type = isStructTag(tag) ? tag : parseStructTag(tag);
  const typeTag = `${type.address}::${type.module}::${type.name}`;
  const cacheHit = typeCache[typeTag];
  return normalizeStructTag({
    ...type,
    address: cacheHit ? cacheHit.split("::")[0] : type.address,
    typeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache))
  });
}
function hasMvrName(nameOrType) {
  return nameOrType.includes(NAME_SEPARATOR2) || nameOrType.includes("@") || nameOrType.includes(".sui");
}
function isStructTag(type) {
  return typeof type === "object" && "address" in type && "module" in type && "name" in type && "typeParams" in type;
}
function findNamesInTransaction(builder) {
  const packages = /* @__PURE__ */ new Set();
  const types = /* @__PURE__ */ new Set();
  for (const command of builder.commands) {
    switch (command.$kind) {
      case "MakeMoveVec":
        if (command.MakeMoveVec.type) {
          getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {
            types.add(type);
          });
        }
        break;
      case "MoveCall":
        const moveCall = command.MoveCall;
        const pkg = moveCall.package.split("::")[0];
        if (hasMvrName(pkg)) {
          if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);
          packages.add(pkg);
        }
        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {
          types.add(type);
        });
        break;
      default:
        break;
    }
  }
  return {
    packages: [...packages],
    types: [...types]
  };
}
function replaceNames(builder, resolved) {
  for (const command of builder.commands) {
    if (command.MakeMoveVec?.type) {
      if (!hasMvrName(command.MakeMoveVec.type)) continue;
      if (!resolved.types[command.MakeMoveVec.type])
        throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);
      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;
    }
    const tx = command.MoveCall;
    if (!tx) continue;
    const nameParts = tx.package.split("::");
    const name = nameParts[0];
    if (hasMvrName(name) && !resolved.packages[name])
      throw new Error(`No address found for package: ${name}`);
    if (hasMvrName(name)) {
      nameParts[0] = resolved.packages[name].package;
      tx.package = nameParts.join("::");
    }
    const types = tx.typeArguments;
    if (!types) continue;
    for (let i = 0; i < types.length; i++) {
      if (!hasMvrName(types[i])) continue;
      if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);
      types[i] = resolved.types[types[i]].type;
    }
    tx.typeArguments = types;
  }
}
function getNamesFromTypeList(types) {
  const names = /* @__PURE__ */ new Set();
  for (const type of types) {
    if (hasMvrName(type)) {
      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);
      names.add(type);
    }
  }
  return names;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/core.js
var DEFAULT_MVR_URLS = {
  mainnet: "https://mainnet.mvr.mystenlabs.com",
  testnet: "https://testnet.mvr.mystenlabs.com"
};
var Experimental_CoreClient = class extends Experimental_BaseClient {
  constructor(options) {
    super(options);
    this.core = this;
    this.mvr = new MvrClient({
      cache: this.cache.scope("core.mvr"),
      url: options.mvr?.url ?? DEFAULT_MVR_URLS[this.network],
      pageSize: options.mvr?.pageSize,
      overrides: options.mvr?.overrides
    });
  }
  async getObject(options) {
    const { objectId } = options;
    const {
      objects: [result]
    } = await this.getObjects({ objectIds: [objectId], signal: options.signal });
    if (result instanceof Error) {
      throw result;
    }
    return { object: result };
  }
  async getDynamicField(options) {
    const normalizedNameType = TypeTagSerializer.parseFromStr(
      (await this.core.mvr.resolveType({
        type: options.name.type
      })).type
    );
    const fieldId = deriveDynamicFieldID(options.parentId, normalizedNameType, options.name.bcs);
    const {
      objects: [fieldObject]
    } = await this.getObjects({
      objectIds: [fieldId],
      signal: options.signal
    });
    if (fieldObject instanceof Error) {
      throw fieldObject;
    }
    const fieldType = parseStructTag(fieldObject.type);
    const content = await fieldObject.content;
    return {
      dynamicField: {
        id: fieldObject.id,
        digest: fieldObject.digest,
        version: fieldObject.version,
        type: fieldObject.type,
        previousTransaction: fieldObject.previousTransaction,
        name: {
          type: typeof fieldType.typeParams[0] === "string" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),
          bcs: options.name.bcs
        },
        value: {
          type: typeof fieldType.typeParams[1] === "string" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),
          bcs: content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal,
    timeout = 60 * 1e3,
    ...input
  }) {
    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);
    const abortPromise = new Promise((_, reject) => {
      abortSignal.addEventListener("abort", () => reject(abortSignal.reason));
    });
    abortPromise.catch(() => {
    });
    while (true) {
      abortSignal.throwIfAborted();
      try {
        return await this.getTransaction({
          ...input,
          signal: abortSignal
        });
      } catch {
        await Promise.race([new Promise((resolve) => setTimeout(resolve, 2e3)), abortPromise]);
      }
    }
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/data/internal.js
function safeEnum(options) {
  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));
  return pipe(
    union(unionOptions),
    transform((value) => ({
      ...value,
      $kind: Object.keys(value)[0]
    }))
  );
}
var SuiAddress = pipe(
  string(),
  transform((value) => normalizeSuiAddress(value)),
  check(isValidSuiAddress)
);
var ObjectID = SuiAddress;
var BCSBytes = string();
var JsonU64 = pipe(
  union([string(), pipe(number(), integer())]),
  check((val) => {
    try {
      BigInt(val);
      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;
    } catch {
      return false;
    }
  }, "Invalid u64")
);
var ObjectRefSchema = object({
  objectId: SuiAddress,
  version: JsonU64,
  digest: string()
});
var ArgumentSchema = pipe(
  union([
    object({ GasCoin: literal(true) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("pure")) }),
    object({ Input: pipe(number(), integer()), type: optional(literal("object")) }),
    object({ Result: pipe(number(), integer()) }),
    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })
  ]),
  transform((value) => ({
    ...value,
    $kind: Object.keys(value)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
);
var GasDataSchema = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRefSchema))
});
var StructTagSchema = object({
  address: string(),
  module: string(),
  name: string(),
  // type_params in rust, should be updated to use camelCase
  typeParams: array(string())
});
var OpenMoveTypeSignatureBodySchema = union([
  literal("address"),
  literal("bool"),
  literal("u8"),
  literal("u16"),
  literal("u32"),
  literal("u64"),
  literal("u128"),
  literal("u256"),
  object({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),
  object({
    datatype: object({
      package: string(),
      module: string(),
      type: string(),
      typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))
    })
  }),
  object({ typeParameter: pipe(number(), integer()) })
]);
var OpenMoveTypeSignatureSchema = object({
  ref: nullable(union([literal("&"), literal("&mut")])),
  body: OpenMoveTypeSignatureBodySchema
});
var ProgrammableMoveCallSchema = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(ArgumentSchema),
  _argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))
});
var $Intent = object({
  name: string(),
  inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),
  data: record(string(), unknown())
});
var CommandSchema = safeEnum({
  MoveCall: ProgrammableMoveCallSchema,
  TransferObjects: object({
    objects: array(ArgumentSchema),
    address: ArgumentSchema
  }),
  SplitCoins: object({
    coin: ArgumentSchema,
    amounts: array(ArgumentSchema)
  }),
  MergeCoins: object({
    destination: ArgumentSchema,
    sources: array(ArgumentSchema)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(ArgumentSchema)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: ArgumentSchema
  }),
  $Intent
});
var ObjectArgSchema = safeEnum({
  ImmOrOwnedObject: ObjectRefSchema,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRefSchema
});
var CallArgSchema = safeEnum({
  Object: ObjectArgSchema,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64)),
    mutable: optional(nullable(boolean()))
  })
});
var NormalizedCallArg = safeEnum({
  Object: ObjectArgSchema,
  Pure: object({
    bytes: BCSBytes
  })
});
var TransactionExpiration2 = safeEnum({
  None: literal(true),
  Epoch: JsonU64
});
var TransactionDataSchema = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration2),
  gasData: GasDataSchema,
  inputs: array(CallArgSchema),
  commands: array(CommandSchema)
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/data/v1.js
var ObjectRef = object({
  digest: string(),
  objectId: string(),
  version: union([pipe(number(), integer()), string(), bigint()])
});
var ObjectArg2 = safeEnum({
  ImmOrOwned: ObjectRef,
  Shared: object({
    objectId: ObjectID,
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRef
});
var NormalizedCallArg2 = safeEnum({
  Object: ObjectArg2,
  Pure: array(pipe(number(), integer()))
});
var TransactionInput = union([
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: optional(literal("object"))
  }),
  object({
    kind: literal("Input"),
    index: pipe(number(), integer()),
    value: unknown(),
    type: literal("pure")
  })
]);
var TransactionExpiration3 = union([
  object({ Epoch: pipe(number(), integer()) }),
  object({ None: nullable(literal(true)) })
]);
var StringEncodedBigint = pipe(
  union([number(), string(), bigint()]),
  check((val) => {
    if (!["string", "number", "bigint"].includes(typeof val)) return false;
    try {
      BigInt(val);
      return true;
    } catch {
      return false;
    }
  })
);
var TypeTag2 = union([
  object({ bool: nullable(literal(true)) }),
  object({ u8: nullable(literal(true)) }),
  object({ u64: nullable(literal(true)) }),
  object({ u128: nullable(literal(true)) }),
  object({ address: nullable(literal(true)) }),
  object({ signer: nullable(literal(true)) }),
  object({ vector: lazy(() => TypeTag2) }),
  object({ struct: lazy(() => StructTag2) }),
  object({ u16: nullable(literal(true)) }),
  object({ u32: nullable(literal(true)) }),
  object({ u256: nullable(literal(true)) })
]);
var StructTag2 = object({
  address: string(),
  module: string(),
  name: string(),
  typeParams: array(TypeTag2)
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(ObjectRef)),
  owner: optional(string())
});
var TransactionArgumentTypes = [
  TransactionInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: pipe(number(), integer()) }),
  object({
    kind: literal("NestedResult"),
    index: pipe(number(), integer()),
    resultIndex: pipe(number(), integer())
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: pipe(
    string(),
    check((target) => target.split("::").length === 3)
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(TransactionArgument),
  address: TransactionArgument
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: TransactionArgument,
  amounts: array(TransactionArgument)
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: TransactionArgument,
  sources: array(TransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: union([object({ Some: TypeTag2 }), object({ None: nullable(literal(true)) })]),
  objects: array(TransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string())
});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(pipe(number(), integer()))),
  dependencies: array(string()),
  packageId: string(),
  ticket: TransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
var SerializedTransactionDataV1 = object({
  version: literal(1),
  sender: optional(string()),
  expiration: nullish(TransactionExpiration3),
  gasConfig: GasConfig,
  inputs: array(TransactionInput),
  transactions: array(TransactionType)
});
function serializeV1TransactionData(transactionData) {
  const inputs = transactionData.inputs.map(
    (input, index) => {
      if (input.Object) {
        return {
          kind: "Input",
          index,
          value: {
            Object: input.Object.ImmOrOwnedObject ? {
              ImmOrOwned: input.Object.ImmOrOwnedObject
            } : input.Object.Receiving ? {
              Receiving: {
                digest: input.Object.Receiving.digest,
                version: input.Object.Receiving.version,
                objectId: input.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: input.Object.SharedObject.mutable,
                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,
                objectId: input.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      }
      if (input.Pure) {
        return {
          kind: "Input",
          index,
          value: {
            Pure: Array.from(fromBase64(input.Pure.bytes))
          },
          type: "pure"
        };
      }
      if (input.UnresolvedPure) {
        return {
          kind: "Input",
          type: "pure",
          index,
          value: input.UnresolvedPure.value
        };
      }
      if (input.UnresolvedObject) {
        return {
          kind: "Input",
          type: "object",
          index,
          value: input.UnresolvedObject.objectId
        };
      }
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: transactionData.sender ?? void 0,
    expiration: transactionData.expiration?.$kind === "Epoch" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,
    gasConfig: {
      owner: transactionData.gasData.owner ?? void 0,
      budget: transactionData.gasData.budget ?? void 0,
      price: transactionData.gasData.price ?? void 0,
      payment: transactionData.gasData.payment ?? void 0
    },
    inputs,
    transactions: transactionData.commands.map((command) => {
      if (command.MakeMoveVec) {
        return {
          kind: "MakeMoveVec",
          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },
          objects: command.MakeMoveVec.elements.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.MergeCoins) {
        return {
          kind: "MergeCoins",
          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),
          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.MoveCall) {
        return {
          kind: "MoveCall",
          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,
          typeArguments: command.MoveCall.typeArguments,
          arguments: command.MoveCall.arguments.map(
            (arg) => convertTransactionArgument(arg, inputs)
          )
        };
      }
      if (command.Publish) {
        return {
          kind: "Publish",
          modules: command.Publish.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Publish.dependencies
        };
      }
      if (command.SplitCoins) {
        return {
          kind: "SplitCoins",
          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),
          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))
        };
      }
      if (command.TransferObjects) {
        return {
          kind: "TransferObjects",
          objects: command.TransferObjects.objects.map(
            (arg) => convertTransactionArgument(arg, inputs)
          ),
          address: convertTransactionArgument(command.TransferObjects.address, inputs)
        };
      }
      if (command.Upgrade) {
        return {
          kind: "Upgrade",
          modules: command.Upgrade.modules.map((mod3) => Array.from(fromBase64(mod3))),
          dependencies: command.Upgrade.dependencies,
          packageId: command.Upgrade.package,
          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)
        };
      }
      throw new Error(`Unknown transaction ${Object.keys(command)}`);
    })
  };
}
function convertTransactionArgument(arg, inputs) {
  if (arg.$kind === "GasCoin") {
    return { kind: "GasCoin" };
  }
  if (arg.$kind === "Result") {
    return { kind: "Result", index: arg.Result };
  }
  if (arg.$kind === "NestedResult") {
    return { kind: "NestedResult", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };
  }
  if (arg.$kind === "Input") {
    return inputs[arg.Input];
  }
  throw new Error(`Invalid argument ${Object.keys(arg)}`);
}
function transactionDataFromV1(data) {
  return parse(TransactionDataSchema, {
    version: 2,
    sender: data.sender ?? null,
    expiration: data.expiration ? "Epoch" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,
    gasData: {
      owner: data.gasConfig.owner ?? null,
      budget: data.gasConfig.budget?.toString() ?? null,
      price: data.gasConfig.price?.toString() ?? null,
      payment: data.gasConfig.payment?.map((ref) => ({
        digest: ref.digest,
        objectId: ref.objectId,
        version: ref.version.toString()
      })) ?? null
    },
    inputs: data.inputs.map((input) => {
      if (input.kind === "Input") {
        if (is(NormalizedCallArg2, input.value)) {
          const value = parse(NormalizedCallArg2, input.value);
          if (value.Object) {
            if (value.Object.ImmOrOwned) {
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: value.Object.ImmOrOwned.objectId,
                    version: String(value.Object.ImmOrOwned.version),
                    digest: value.Object.ImmOrOwned.digest
                  }
                }
              };
            }
            if (value.Object.Shared) {
              return {
                Object: {
                  SharedObject: {
                    mutable: value.Object.Shared.mutable ?? null,
                    initialSharedVersion: value.Object.Shared.initialSharedVersion,
                    objectId: value.Object.Shared.objectId
                  }
                }
              };
            }
            if (value.Object.Receiving) {
              return {
                Object: {
                  Receiving: {
                    digest: value.Object.Receiving.digest,
                    version: String(value.Object.Receiving.version),
                    objectId: value.Object.Receiving.objectId
                  }
                }
              };
            }
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: toBase64(new Uint8Array(value.Pure))
            }
          };
        }
        if (input.type === "object") {
          return {
            UnresolvedObject: {
              objectId: input.value
            }
          };
        }
        return {
          UnresolvedPure: {
            value: input.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: data.transactions.map((transaction) => {
      switch (transaction.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,
              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        case "MergeCoins": {
          return {
            MergeCoins: {
              destination: parseV1TransactionArgument(transaction.destination),
              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "MoveCall": {
          const [pkg, mod3, fn] = transaction.target.split("::");
          return {
            MoveCall: {
              package: pkg,
              module: mod3,
              function: fn,
              typeArguments: transaction.typeArguments,
              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "Publish": {
          return {
            Publish: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies
            }
          };
        }
        case "SplitCoins": {
          return {
            SplitCoins: {
              coin: parseV1TransactionArgument(transaction.coin),
              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))
            }
          };
        }
        case "TransferObjects": {
          return {
            TransferObjects: {
              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),
              address: parseV1TransactionArgument(transaction.address)
            }
          };
        }
        case "Upgrade": {
          return {
            Upgrade: {
              modules: transaction.modules.map((mod3) => toBase64(Uint8Array.from(mod3))),
              dependencies: transaction.dependencies,
              package: transaction.packageId,
              ticket: parseV1TransactionArgument(transaction.ticket)
            }
          };
        }
      }
      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);
    })
  });
}
function parseV1TransactionArgument(arg) {
  switch (arg.kind) {
    case "GasCoin": {
      return { GasCoin: true };
    }
    case "Result":
      return { Result: arg.index };
    case "NestedResult": {
      return { NestedResult: [arg.index, arg.resultIndex] };
    }
    case "Input": {
      return { Input: arg.index };
    }
  }
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/hash.js
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TransactionDataBuilder = class _TransactionDataBuilder {
  constructor(clone) {
    this.version = 2;
    this.sender = clone?.sender ?? null;
    this.expiration = clone?.expiration ?? null;
    this.inputs = clone?.inputs ?? [];
    this.commands = clone?.commands ?? [];
    this.gasData = clone?.gasData ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(bytes) {
    const kind = suiBcs.TransactionKind.parse(bytes);
    const programmableTx = kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static fromBytes(bytes) {
    const rawData = suiBcs.TransactionData.parse(bytes);
    const data = rawData?.V1;
    const programmableTx = data.kind.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    return _TransactionDataBuilder.restore({
      version: 2,
      sender: data.sender,
      expiration: data.expiration,
      gasData: data.gasData,
      inputs: programmableTx.inputs,
      commands: programmableTx.commands
    });
  }
  static restore(data) {
    if (data.version === 2) {
      return new _TransactionDataBuilder(parse(TransactionDataSchema, data));
    } else {
      return new _TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));
    }
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes) {
    const hash = hashTypedData("TransactionData", bytes);
    return toBase58(hash);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(value) {
    this.gasData = value;
  }
  build({
    maxSizeBytes = Infinity,
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs;
    const commands = this.commands;
    const kind = {
      ProgrammableTransaction: {
        inputs,
        commands
      }
    };
    if (onlyTransactionKind) {
      return suiBcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();
    }
    const expiration = overrides?.expiration ?? this.expiration;
    const sender = overrides?.sender ?? this.sender;
    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasData.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasData.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasData.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasData.payment,
        owner: prepareSuiAddress(this.gasData.owner ?? sender),
        price: BigInt(gasData.price),
        budget: BigInt(gasData.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          commands
        }
      }
    };
    return suiBcs.TransactionData.serialize(
      { V1: transactionData },
      { maxSize: maxSizeBytes }
    ).toBytes();
  }
  addInput(type, arg) {
    const index = this.inputs.length;
    this.inputs.push(arg);
    return { Input: index, type, $kind: "Input" };
  }
  getInputUses(index, fn) {
    this.mapArguments((arg, command) => {
      if (arg.$kind === "Input" && arg.Input === index) {
        fn(arg, command);
      }
      return arg;
    });
  }
  mapCommandArguments(index, fn) {
    const command = this.commands[index];
    switch (command.$kind) {
      case "MoveCall":
        command.MoveCall.arguments = command.MoveCall.arguments.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "TransferObjects":
        command.TransferObjects.objects = command.TransferObjects.objects.map(
          (arg) => fn(arg, command, index)
        );
        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);
        break;
      case "SplitCoins":
        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);
        command.SplitCoins.amounts = command.SplitCoins.amounts.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MergeCoins":
        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);
        command.MergeCoins.sources = command.MergeCoins.sources.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "MakeMoveVec":
        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(
          (arg) => fn(arg, command, index)
        );
        break;
      case "Upgrade":
        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);
        break;
      case "$Intent":
        const inputs = command.$Intent.inputs;
        command.$Intent.inputs = {};
        for (const [key, value] of Object.entries(inputs)) {
          command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn(arg, command, index)) : fn(value, command, index);
        }
        break;
      case "Publish":
        break;
      default:
        throw new Error(`Unexpected transaction kind: ${command.$kind}`);
    }
  }
  mapArguments(fn) {
    for (const commandIndex of this.commands.keys()) {
      this.mapCommandArguments(commandIndex, fn);
    }
  }
  replaceCommand(index, replacement, resultIndex = index) {
    if (!Array.isArray(replacement)) {
      this.commands[index] = replacement;
      return;
    }
    const sizeDiff = replacement.length - 1;
    this.commands.splice(index, 1, ...replacement);
    if (sizeDiff !== 0) {
      this.mapArguments((arg, _command, commandIndex) => {
        if (commandIndex < index + replacement.length) {
          return arg;
        }
        switch (arg.$kind) {
          case "Result":
            if (arg.Result === index) {
              arg.Result = resultIndex;
            }
            if (arg.Result > index) {
              arg.Result += sizeDiff;
            }
            break;
          case "NestedResult":
            if (arg.NestedResult[0] === index) {
              arg.NestedResult[0] = resultIndex;
            }
            if (arg.NestedResult[0] > index) {
              arg.NestedResult[0] += sizeDiff;
            }
            break;
        }
        return arg;
      });
    }
  }
  getDigest() {
    const bytes = this.build({ onlyTransactionKind: false });
    return _TransactionDataBuilder.getDigestFromBytes(bytes);
  }
  snapshot() {
    return parse(TransactionDataSchema, this);
  }
  shallowClone() {
    return new _TransactionDataBuilder({
      version: this.version,
      sender: this.sender,
      expiration: this.expiration,
      gasData: {
        ...this.gasData
      },
      inputs: [...this.inputs],
      commands: [...this.commands]
    });
  }
  applyResolvedData(resolved) {
    if (!this.sender) {
      this.sender = resolved.sender ?? null;
    }
    if (!this.expiration) {
      this.expiration = resolved.expiration ?? null;
    }
    if (!this.gasData.budget) {
      this.gasData.budget = resolved.gasData.budget;
    }
    if (!this.gasData.owner) {
      this.gasData.owner = resolved.gasData.owner ?? null;
    }
    if (!this.gasData.payment) {
      this.gasData.payment = resolved.gasData.payment;
    }
    if (!this.gasData.price) {
      this.gasData.price = resolved.gasData.price;
    }
    for (let i = 0; i < this.inputs.length; i++) {
      const input = this.inputs[i];
      const resolvedInput = resolved.inputs[i];
      switch (input.$kind) {
        case "UnresolvedPure":
          if (resolvedInput.$kind !== "Pure") {
            throw new Error(
              `Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(
                resolvedInput
              )}`
            );
          }
          this.inputs[i] = resolvedInput;
          break;
        case "UnresolvedObject":
          if (resolvedInput.$kind !== "Object") {
            throw new Error(
              `Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(
                resolvedInput
              )}`
            );
          }
          if (resolvedInput.Object.$kind === "ImmOrOwnedObject" || resolvedInput.Object.$kind === "Receiving") {
            const original = input.UnresolvedObject;
            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;
            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest || // Objects with shared object properties should not resolve to owned objects
            original.mutable != null || original.initialSharedVersion != null) {
              throw new Error(
                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`
              );
            }
          } else if (resolvedInput.Object.$kind === "SharedObject") {
            const original = input.UnresolvedObject;
            const resolved2 = resolvedInput.Object.SharedObject;
            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable || // Objects with owned object properties should not resolve to shared objects
            original.version != null || original.digest != null) {
              throw new Error(
                `Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`
              );
            }
          } else {
            throw new Error(
              `Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(
                resolvedInput.Object
              )}`
            );
          }
          this.inputs[i] = resolvedInput;
          break;
      }
    }
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/transports/utils.js
function parseTransactionBcs(bytes) {
  return {
    ...TransactionDataBuilder.fromBytes(bytes).snapshot(),
    bcs: bytes
  };
}
function parseTransactionEffectsBcs(effects) {
  const parsed = suiBcs.TransactionEffects.parse(effects);
  switch (parsed.$kind) {
    case "V1":
      return parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1 });
    case "V2":
      return parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2 });
    default:
      throw new Error(
        `Unknown transaction effects version: ${parsed.$kind}`
      );
  }
}
function parseTransactionEffectsV1(_) {
  throw new Error("V1 effects are not supported yet");
}
function parseTransactionEffectsV2({
  bytes,
  effects
}) {
  const changedObjects = effects.changedObjects.map(
    ([id, change]) => {
      return {
        id,
        inputState: change.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: change.inputState.Exist?.[0][0] ?? null,
        inputDigest: change.inputState.Exist?.[0][1] ?? null,
        inputOwner: change.inputState.Exist?.[1] ?? null,
        outputState: change.outputState.$kind === "NotExist" ? "DoesNotExist" : change.outputState.$kind,
        outputVersion: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[0] : change.outputState.ObjectWrite ? effects.lamportVersion : null,
        outputDigest: change.outputState.$kind === "PackageWrite" ? change.outputState.PackageWrite?.[1] : change.outputState.ObjectWrite?.[0] ?? null,
        outputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,
        idOperation: change.idOperation.$kind
      };
    }
  );
  return {
    bcs: bytes,
    digest: effects.transactionDigest,
    version: 2,
    status: effects.status.$kind === "Success" ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: add command
      error: effects.status.Failed.error.$kind
    },
    gasUsed: effects.gasUsed,
    transactionDigest: effects.transactionDigest,
    gasObject: effects.gasObjectIndex === null ? null : changedObjects[effects.gasObjectIndex] ?? null,
    eventsDigest: effects.eventsDigest,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion,
    changedObjects,
    unchangedConsensusObjects: effects.unchangedSharedObjects.map(
      ([objectId, object2]) => {
        return {
          kind: object2.$kind === "MutateDeleted" ? "MutateConsensusStreamEnded" : object2.$kind === "ReadDeleted" ? "ReadConsensusStreamEnded" : object2.$kind,
          objectId,
          version: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[0] : object2[object2.$kind],
          digest: object2.$kind === "ReadOnlyRoot" ? object2.ReadOnlyRoot[1] : null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxDataDigest
  };
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/graphql/generated/queries.js
var AddressTransactionBlockRelationship = ((AddressTransactionBlockRelationship2) => {
  AddressTransactionBlockRelationship2["Affected"] = "AFFECTED";
  AddressTransactionBlockRelationship2["Sent"] = "SENT";
  return AddressTransactionBlockRelationship2;
})(AddressTransactionBlockRelationship || {});
var DomainFormat = ((DomainFormat2) => {
  DomainFormat2["At"] = "AT";
  DomainFormat2["Dot"] = "DOT";
  return DomainFormat2;
})(DomainFormat || {});
var ExecutionStatus2 = ((ExecutionStatus22) => {
  ExecutionStatus22["Failure"] = "FAILURE";
  ExecutionStatus22["Success"] = "SUCCESS";
  return ExecutionStatus22;
})(ExecutionStatus2 || {});
var Feature = ((Feature2) => {
  Feature2["Analytics"] = "ANALYTICS";
  Feature2["Coins"] = "COINS";
  Feature2["DynamicFields"] = "DYNAMIC_FIELDS";
  Feature2["MoveRegistry"] = "MOVE_REGISTRY";
  Feature2["NameService"] = "NAME_SERVICE";
  Feature2["Subscriptions"] = "SUBSCRIPTIONS";
  Feature2["SystemState"] = "SYSTEM_STATE";
  return Feature2;
})(Feature || {});
var MoveAbility = ((MoveAbility2) => {
  MoveAbility2["Copy"] = "COPY";
  MoveAbility2["Drop"] = "DROP";
  MoveAbility2["Key"] = "KEY";
  MoveAbility2["Store"] = "STORE";
  return MoveAbility2;
})(MoveAbility || {});
var MoveVisibility = ((MoveVisibility2) => {
  MoveVisibility2["Friend"] = "FRIEND";
  MoveVisibility2["Private"] = "PRIVATE";
  MoveVisibility2["Public"] = "PUBLIC";
  return MoveVisibility2;
})(MoveVisibility || {});
var ObjectKind = ((ObjectKind2) => {
  ObjectKind2["Indexed"] = "INDEXED";
  ObjectKind2["NotIndexed"] = "NOT_INDEXED";
  return ObjectKind2;
})(ObjectKind || {});
var StakeStatus = ((StakeStatus2) => {
  StakeStatus2["Active"] = "ACTIVE";
  StakeStatus2["Pending"] = "PENDING";
  StakeStatus2["Unstaked"] = "UNSTAKED";
  return StakeStatus2;
})(StakeStatus || {});
var TransactionBlockKindInput = ((TransactionBlockKindInput2) => {
  TransactionBlockKindInput2["ProgrammableTx"] = "PROGRAMMABLE_TX";
  TransactionBlockKindInput2["SystemTx"] = "SYSTEM_TX";
  return TransactionBlockKindInput2;
})(TransactionBlockKindInput || {});
var ZkLoginIntentScope = ((ZkLoginIntentScope2) => {
  ZkLoginIntentScope2["PersonalMessage"] = "PERSONAL_MESSAGE";
  ZkLoginIntentScope2["TransactionData"] = "TRANSACTION_DATA";
  return ZkLoginIntentScope2;
})(ZkLoginIntentScope || {});
var TypedDocumentString = class extends String {
  constructor(value, __meta__) {
    super(value);
    this.value = value;
    this.__meta__ = __meta__;
  }
  toString() {
    return this.value;
  }
};
var Object_Owner_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}
    `, { "fragmentName": "OBJECT_OWNER_FIELDS" });
var Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`, { "fragmentName": "OBJECT_FIELDS" });
var Move_Object_FieldsFragmentDoc = new TypedDocumentString(`
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`, { "fragmentName": "MOVE_OBJECT_FIELDS" });
var Transaction_FieldsFragmentDoc = new TypedDocumentString(`
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}
    `, { "fragmentName": "TRANSACTION_FIELDS" });
var GetAllBalancesDocument = new TypedDocumentString(`
    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $owner) {
    balances(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinType {
          repr
        }
        coinObjectCount
        totalBalance
      }
    }
  }
}
    `);
var GetBalanceDocument = new TypedDocumentString(`
    query getBalance($owner: SuiAddress!, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    balance(type: $type) {
      coinType {
        repr
      }
      coinObjectCount
      totalBalance
    }
  }
}
    `);
var GetCoinsDocument = new TypedDocumentString(`
    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    address
    coins(first: $first, after: $cursor, type: $type) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinBalance
        owner {
          ...OBJECT_OWNER_FIELDS
        }
        contents {
          bcs
          type {
            repr
          }
        }
        address
        version
        digest
        previousTransactionBlock {
          digest
        }
      }
    }
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var GetDynamicFieldsDocument = new TypedDocumentString(`
    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {
  owner(address: $parentId) {
    dynamicFields(first: $first, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name {
          bcs
          type {
            repr
          }
        }
        value {
          __typename
          ... on MoveValue {
            type {
              repr
            }
          }
          ... on MoveObject {
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `);
var GetMoveFunctionDocument = new TypedDocumentString(`
    query getMoveFunction($package: SuiAddress!, $module: String!, $function: String!) {
  package(address: $package) {
    module(name: $module) {
      function(name: $function) {
        name
        visibility
        isEntry
        typeParameters {
          constraints
        }
        parameters {
          signature
        }
        return {
          signature
        }
      }
    }
  }
}
    `);
var GetReferenceGasPriceDocument = new TypedDocumentString(`
    query getReferenceGasPrice {
  epoch {
    referenceGasPrice
  }
}
    `);
var ResolveNameServiceNamesDocument = new TypedDocumentString(`
    query resolveNameServiceNames($address: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $address) {
    suinsRegistrations(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        domain
      }
    }
  }
}
    `);
var GetOwnedObjectsDocument = new TypedDocumentString(`
    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {
  address(address: $owner) {
    objects(first: $limit, after: $cursor, filter: $filter) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        ...MOVE_OBJECT_FIELDS
      }
    }
  }
}
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var MultiGetObjectsDocument = new TypedDocumentString(`
    query multiGetObjects($objectIds: [SuiAddress!]!, $limit: Int, $cursor: String) {
  objects(first: $limit, after: $cursor, filter: {objectIds: $objectIds}) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ...OBJECT_FIELDS
    }
  }
}
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`);
var DryRunTransactionBlockDocument = new TypedDocumentString(`
    query dryRunTransactionBlock($txBytes: String!) {
  dryRunTransactionBlock(txBytes: $txBytes) {
    error
    transaction {
      ...TRANSACTION_FIELDS
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var ExecuteTransactionBlockDocument = new TypedDocumentString(`
    mutation executeTransactionBlock($txBytes: String!, $signatures: [String!]!) {
  executeTransactionBlock(txBytes: $txBytes, signatures: $signatures) {
    errors
    effects {
      transactionBlock {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var GetTransactionBlockDocument = new TypedDocumentString(`
    query getTransactionBlock($digest: String!) {
  transactionBlock(digest: $digest) {
    ...TRANSACTION_FIELDS
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`);
var VerifyZkLoginSignatureDocument = new TypedDocumentString(`
    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {
  verifyZkloginSignature(
    bytes: $bytes
    signature: $signature
    intentScope: $intentScope
    author: $author
  ) {
    success
    errors
  }
}
    `);

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/experimental/errors.js
var SuiClientError = class extends Error {
};
var ObjectError = class _ObjectError extends SuiClientError {
  constructor(code, message) {
    super(message);
    this.code = code;
  }
  static fromResponse(response, objectId) {
    switch (response.code) {
      case "notExists":
        return new _ObjectError(response.code, `Object ${response.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _ObjectError(
          response.code,
          `Dynamic field not found for object ${response.parent_object_id}`
        );
      case "deleted":
        return new _ObjectError(response.code, `Object ${response.object_id} has been deleted`);
      case "displayError":
        return new _ObjectError(response.code, `Display error: ${response.error}`);
      case "unknown":
      default:
        return new _ObjectError(
          response.code,
          `Unknown error while loading object${objectId ? ` ${objectId}` : ""}`
        );
    }
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/graphql/core.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _graphqlClient;
var _GraphQLCoreClient_instances;
var graphqlQuery_fn;
var GraphQLCoreClient = class extends Experimental_CoreClient {
  constructor({
    graphqlClient,
    mvr
  }) {
    super({ network: graphqlClient.network, base: graphqlClient, mvr });
    __privateAdd5(this, _GraphQLCoreClient_instances);
    __privateAdd5(this, _graphqlClient);
    __privateSet5(this, _graphqlClient, graphqlClient);
  }
  async getObjects(options) {
    const objects = [];
    let hasNextPage = true;
    let cursor = null;
    while (hasNextPage) {
      const objectsPage = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
        query: MultiGetObjectsDocument,
        variables: {
          objectIds: options.objectIds,
          cursor
        }
      }, (result) => result.objects);
      objects.push(...objectsPage.nodes);
      hasNextPage = objectsPage.pageInfo.hasNextPage;
      cursor = objectsPage.pageInfo.endCursor ?? null;
    }
    return {
      objects: options.objectIds.map((id) => normalizeSuiAddress(id)).map(
        (id) => objects.find((obj) => obj.address === id) ?? new ObjectError("notFound", `Object ${id} not found`)
      ).map((obj) => {
        if (obj instanceof ObjectError) {
          return obj;
        }
        return {
          id: obj.address,
          version: obj.version.toString(),
          digest: obj.digest,
          owner: mapOwner(obj.owner),
          type: obj.asMoveObject?.contents?.type?.repr,
          content: Promise.resolve(
            obj.asMoveObject?.contents?.bcs ? fromBase64(obj.asMoveObject.contents.bcs) : new Uint8Array()
          ),
          previousTransaction: obj.previousTransactionBlock?.digest ?? null
        };
      })
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetOwnedObjectsDocument,
      variables: {
        owner: options.address,
        limit: options.limit,
        cursor: options.cursor,
        filter: options.type ? { type: (await this.mvr.resolveType({ type: options.type })).type } : void 0
      }
    }, (result) => result.address?.objects);
    return {
      objects: objects.nodes.map((obj) => ({
        id: obj.address,
        version: obj.version.toString(),
        digest: obj.digest,
        owner: mapOwner(obj.owner),
        type: obj.contents?.type?.repr,
        content: Promise.resolve(
          obj.contents?.bcs ? fromBase64(obj.contents.bcs) : new Uint8Array()
        ),
        previousTransaction: obj.previousTransactionBlock?.digest ?? null
      })),
      hasNextPage: objects.pageInfo.hasNextPage,
      cursor: objects.pageInfo.endCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetCoinsDocument,
      variables: {
        owner: options.address,
        cursor: options.cursor,
        first: options.limit,
        type: (await this.mvr.resolveType({ type: options.coinType })).type
      }
    }, (result) => result.address?.coins);
    return {
      cursor: coins.pageInfo.endCursor ?? null,
      hasNextPage: coins.pageInfo.hasNextPage,
      objects: coins.nodes.map((coin) => ({
        id: coin.address,
        version: coin.version.toString(),
        digest: coin.digest,
        owner: mapOwner(coin.owner),
        type: coin.contents?.type?.repr,
        balance: coin.coinBalance,
        content: Promise.resolve(
          coin.contents?.bcs ? fromBase64(coin.contents.bcs) : new Uint8Array()
        ),
        previousTransaction: coin.previousTransactionBlock?.digest ?? null
      }))
    };
  }
  async getBalance(options) {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetBalanceDocument,
      variables: {
        owner: options.address,
        type: (await this.mvr.resolveType({ type: options.coinType })).type
      }
    }, (result2) => result2.address?.balance);
    return {
      balance: {
        coinType: result.coinType.repr,
        balance: result.totalBalance
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetAllBalancesDocument,
      variables: { owner: options.address }
    }, (result) => result.address?.balances);
    return {
      cursor: balances.pageInfo.endCursor ?? null,
      hasNextPage: balances.pageInfo.hasNextPage,
      balances: balances.nodes.map((balance) => ({
        coinType: balance.coinType.repr,
        balance: balance.totalBalance
      }))
    };
  }
  async getTransaction(options) {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetTransactionBlockDocument,
      variables: { digest: options.digest }
    }, (result2) => result2.transactionBlock);
    return {
      transaction: parseTransaction(result)
    };
  }
  async executeTransaction(options) {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: ExecuteTransactionBlockDocument,
      variables: { txBytes: toBase64(options.transaction), signatures: options.signatures }
    }, (result2) => result2.executeTransactionBlock);
    if (result.errors) {
      if (result.errors.length === 1) {
        throw new Error(result.errors[0]);
      }
      throw new AggregateError(result.errors.map((error) => new Error(error)));
    }
    return {
      transaction: parseTransaction(result.effects.transactionBlock)
    };
  }
  async dryRunTransaction(options) {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: DryRunTransactionBlockDocument,
      variables: { txBytes: toBase64(options.transaction) }
    }, (result2) => result2.dryRunTransactionBlock);
    if (result.error) {
      throw new Error(result.error);
    }
    return {
      transaction: parseTransaction(result.transaction)
    };
  }
  async getReferenceGasPrice() {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetReferenceGasPriceDocument
    }, (result2) => result2.epoch?.referenceGasPrice);
    return {
      referenceGasPrice: result
    };
  }
  async getDynamicFields(options) {
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetDynamicFieldsDocument,
      variables: { parentId: options.parentId }
    }, (result2) => result2.owner?.dynamicFields);
    return {
      dynamicFields: result.nodes.map((dynamicField) => {
        const valueType = dynamicField.value?.__typename === "MoveObject" ? dynamicField.value.contents?.type?.repr : dynamicField.value?.type.repr;
        return {
          id: deriveDynamicFieldID(
            options.parentId,
            dynamicField.name?.type.repr,
            fromBase64(dynamicField.name?.bcs)
          ),
          type: normalizeStructTag(
            dynamicField.value?.__typename === "MoveObject" ? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${dynamicField.name?.type.repr}>,0x2::object::ID>` : `0x2::dynamic_field::Field<${dynamicField.name?.type.repr},${valueType}>`
          ),
          name: {
            type: dynamicField.name?.type.repr,
            bcs: fromBase64(dynamicField.name?.bcs)
          },
          valueType
        };
      }),
      cursor: result.pageInfo.endCursor ?? null,
      hasNextPage: result.pageInfo.hasNextPage
    };
  }
  async verifyZkLoginSignature(options) {
    const intentScope = options.intentScope === "TransactionData" ? ZkLoginIntentScope.TransactionData : ZkLoginIntentScope.PersonalMessage;
    const result = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: VerifyZkLoginSignatureDocument,
      variables: {
        bytes: options.bytes,
        signature: options.signature,
        intentScope,
        author: options.author
      }
    }, (result2) => result2.verifyZkloginSignature);
    return {
      success: result.success,
      errors: result.errors
    };
  }
  async resolveNameServiceNames(options) {
    const suinsRegistrations = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: ResolveNameServiceNamesDocument,
      signal: options.signal,
      variables: {
        address: options.address,
        cursor: options.cursor,
        limit: options.limit
      }
    }, (result) => result.address?.suinsRegistrations);
    return {
      hasNextPage: suinsRegistrations.pageInfo.hasNextPage,
      nextCursor: suinsRegistrations.pageInfo.endCursor ?? null,
      data: suinsRegistrations.nodes.map((node) => node.domain) ?? []
    };
  }
  async getMoveFunction(options) {
    const moveFunction = await __privateMethod3(this, _GraphQLCoreClient_instances, graphqlQuery_fn).call(this, {
      query: GetMoveFunctionDocument,
      variables: {
        package: (await this.mvr.resolvePackage({ package: options.packageId })).package,
        module: options.moduleName,
        function: options.name
      }
    }, (result) => result.package?.module?.function);
    let visibility = "unknown";
    switch (moveFunction.visibility) {
      case "PUBLIC":
        visibility = "public";
        break;
      case "PRIVATE":
        visibility = "private";
        break;
      case "FRIEND":
        visibility = "friend";
        break;
    }
    return {
      function: {
        packageId: normalizeSuiAddress(options.packageId),
        moduleName: options.moduleName,
        name: moveFunction.name,
        visibility,
        isEntry: moveFunction.isEntry ?? false,
        typeParameters: moveFunction.typeParameters?.map(({ constraints }) => ({
          isPhantom: false,
          constraints: constraints.map((constraint) => {
            switch (constraint) {
              case "COPY":
                return "copy";
              case "DROP":
                return "drop";
              case "STORE":
                return "store";
              case "KEY":
                return "key";
              default:
                return "unknown";
            }
          }) ?? []
        })) ?? [],
        parameters: moveFunction.parameters?.map((param) => parseNormalizedSuiMoveType(param.signature)) ?? [],
        returns: moveFunction.return?.map(({ signature }) => parseNormalizedSuiMoveType(signature)) ?? []
      }
    };
  }
  resolveTransactionPlugin() {
    throw new Error("GraphQL client does not support transaction resolution yet");
  }
};
_graphqlClient = /* @__PURE__ */ new WeakMap();
_GraphQLCoreClient_instances = /* @__PURE__ */ new WeakSet();
graphqlQuery_fn = async function(options, getData) {
  const { data, errors } = await __privateGet5(this, _graphqlClient).query(options);
  handleGraphQLErrors(errors);
  const extractedData = data && (getData ? getData(data) : data);
  if (extractedData == null) {
    throw new Error("Missing response data");
  }
  return extractedData;
};
function handleGraphQLErrors(errors) {
  if (!errors || errors.length === 0) return;
  const errorInstances = errors.map((error) => new GraphQLResponseError(error));
  if (errorInstances.length === 1) {
    throw errorInstances[0];
  }
  throw new AggregateError(errorInstances);
}
var GraphQLResponseError = class extends Error {
  constructor(error) {
    super(error.message);
    this.locations = error.locations;
  }
};
function mapOwner(owner) {
  switch (owner.__typename) {
    case "AddressOwner":
      return { $kind: "AddressOwner", AddressOwner: owner.owner?.asAddress?.address };
    case "ConsensusAddressOwner":
      return {
        $kind: "ConsensusAddressOwner",
        ConsensusAddressOwner: {
          owner: owner.owner?.address,
          startVersion: String(owner.startVersion)
        }
      };
    case "Immutable":
      return { $kind: "Immutable", Immutable: true };
    case "Parent":
      return { $kind: "ObjectOwner", ObjectOwner: owner.parent?.address };
    case "Shared":
      return {
        $kind: "Shared",
        Shared: { initialSharedVersion: String(owner.initialSharedVersion) }
      };
  }
}
function parseTransaction(transaction) {
  const objectTypes = {};
  transaction.effects?.unchangedConsensusObjects.nodes.forEach((node) => {
    if (node.__typename === "ConsensusObjectRead") {
      const type = node.object?.asMoveObject?.contents?.type.repr;
      const address = node.object?.asMoveObject?.address;
      if (type && address) {
        objectTypes[address] = type;
      }
    }
  });
  transaction.effects?.objectChanges.nodes.forEach((node) => {
    const address = node.address;
    const type = node.inputState?.asMoveObject?.contents?.type.repr ?? node.outputState?.asMoveObject?.contents?.type.repr;
    if (address && type) {
      objectTypes[address] = type;
    }
  });
  if (transaction.effects?.balanceChanges.pageInfo.hasNextPage) {
    throw new Error("Pagination for balance changes is not supported");
  }
  return {
    digest: transaction.digest,
    effects: parseTransactionEffectsBcs(fromBase64(transaction.effects?.bcs)),
    epoch: transaction.effects?.epoch?.epochId?.toString() ?? null,
    objectTypes: Promise.resolve(objectTypes),
    transaction: parseTransactionBcs(fromBase64(transaction.bcs)),
    signatures: transaction.signatures,
    balanceChanges: transaction.effects?.balanceChanges.nodes.map((change) => ({
      coinType: change?.coinType?.repr,
      address: change.owner?.address,
      amount: change.amount
    })) ?? []
    // events: transaction.events?.pageInfo.hasNextPage
  };
}
function parseNormalizedSuiMoveType(type) {
  let reference = null;
  if (type.ref === "&") {
    reference = "immutable";
  } else if (type.ref === "&mut") {
    reference = "mutable";
  }
  return {
    reference,
    body: parseNormalizedSuiMoveTypeBody(type.body)
  };
}
function parseNormalizedSuiMoveTypeBody(type) {
  switch (type) {
    case "address":
      return { $kind: "address" };
    case "bool":
      return { $kind: "bool" };
    case "u8":
      return { $kind: "u8" };
    case "u16":
      return { $kind: "u16" };
    case "u32":
      return { $kind: "u32" };
    case "u64":
      return { $kind: "u64" };
    case "u128":
      return { $kind: "u128" };
    case "u256":
      return { $kind: "u256" };
  }
  if (typeof type === "string") {
    throw new Error(`Unknown type: ${type}`);
  }
  if ("vector" in type) {
    return {
      $kind: "vector",
      vector: parseNormalizedSuiMoveTypeBody(type.vector)
    };
  }
  if ("datatype" in type) {
    return {
      $kind: "datatype",
      datatype: {
        typeName: `${normalizeSuiAddress(type.datatype.package)}::${type.datatype.module}::${type.datatype.type}`,
        typeParameters: type.datatype.typeParameters.map((t) => parseNormalizedSuiMoveTypeBody(t))
      }
    };
  }
  if ("typeParameter" in type) {
    return {
      $kind: "typeParameter",
      index: type.typeParameter
    };
  }
  throw new Error(`Unknown type: ${JSON.stringify(type)}`);
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/graphql/client.js
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _url2;
var _queries;
var _headers;
var _fetch;
var SuiGraphQLRequestError = class extends Error {
};
var SuiGraphQLClient = class extends Experimental_BaseClient {
  constructor({
    url,
    fetch: fetchFn = fetch,
    headers = {},
    queries = {},
    network = "unknown",
    mvr
  }) {
    super({
      network
    });
    __privateAdd6(this, _url2);
    __privateAdd6(this, _queries);
    __privateAdd6(this, _headers);
    __privateAdd6(this, _fetch);
    __privateSet6(this, _url2, url);
    __privateSet6(this, _queries, queries);
    __privateSet6(this, _headers, headers);
    __privateSet6(this, _fetch, (...args) => fetchFn(...args));
    this.core = new GraphQLCoreClient({
      graphqlClient: this,
      mvr
    });
  }
  async query(options) {
    const res = await __privateGet6(this, _fetch).call(this, __privateGet6(this, _url2), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...__privateGet6(this, _headers)
      },
      body: JSON.stringify({
        query: typeof options.query === "string" || options.query instanceof String ? String(options.query) : print(options.query),
        variables: options.variables,
        extensions: options.extensions,
        operationName: options.operationName
      }),
      signal: options.signal
    });
    if (!res.ok) {
      throw new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);
    }
    return await res.json();
  }
  async execute(query, options) {
    return this.query({
      ...options,
      query: __privateGet6(this, _queries)[query]
    });
  }
};
_url2 = /* @__PURE__ */ new WeakMap();
_queries = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_fetch = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/jwt-decode.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(
    atob(str).replace(/(.)/g, (_m, p) => {
      let code = p.charCodeAt(0).toString(16).toUpperCase();
      if (code.length < 2) {
        code = "0" + code;
      }
      return "%" + code;
    })
  );
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e) {
    throw new InvalidTokenError(
      `Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`
    );
  }
  try {
    return JSON.parse(decoded);
  } catch (e) {
    throw new InvalidTokenError(
      `Invalid token specified: invalid json for part #${pos + 1} (${e.message})`
    );
  }
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/poseidon.js
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/utils.js
function findFirstNonZeroIndex(bytes) {
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i] !== 0) {
      return i;
    }
  }
  return -1;
}
function toPaddedBigEndianBytes(num2, width) {
  const hex = num2.toString(16);
  return hexToBytes(hex.padStart(width * 2, "0").slice(-width * 2));
}
function toBigEndianBytes(num2, width) {
  const bytes = toPaddedBigEndianBytes(num2, width);
  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);
  if (firstNonZeroIndex === -1) {
    return new Uint8Array([0]);
  }
  return bytes.slice(firstNonZeroIndex);
}
function normalizeZkLoginIssuer(iss) {
  if (iss === "accounts.google.com") {
    return "https://accounts.google.com";
  }
  return iss;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/jwt-utils.js
function base64UrlCharTo6Bits(base64UrlChar) {
  if (base64UrlChar.length !== 1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const base64UrlCharacterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const index = base64UrlCharacterSet.indexOf(base64UrlChar);
  if (index === -1) {
    throw new Error("Invalid base64Url character: " + base64UrlChar);
  }
  const binaryString = index.toString(2).padStart(6, "0");
  const bits = Array.from(binaryString).map(Number);
  return bits;
}
function base64UrlStringToBitVector(base64UrlString) {
  let bitVector = [];
  for (let i = 0; i < base64UrlString.length; i++) {
    const base64UrlChar = base64UrlString.charAt(i);
    const bits = base64UrlCharTo6Bits(base64UrlChar);
    bitVector = bitVector.concat(bits);
  }
  return bitVector;
}
function decodeBase64URL(s, i) {
  if (s.length < 2) {
    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);
  }
  let bits = base64UrlStringToBitVector(s);
  const firstCharOffset = i % 4;
  if (firstCharOffset === 0) {
  } else if (firstCharOffset === 1) {
    bits = bits.slice(2);
  } else if (firstCharOffset === 2) {
    bits = bits.slice(4);
  } else {
    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i}))`);
  }
  const lastCharOffset = (i + s.length - 1) % 4;
  if (lastCharOffset === 3) {
  } else if (lastCharOffset === 2) {
    bits = bits.slice(0, bits.length - 2);
  } else if (lastCharOffset === 1) {
    bits = bits.slice(0, bits.length - 4);
  } else {
    throw new Error(
      `Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i}))`
    );
  }
  if (bits.length % 8 !== 0) {
    throw new Error(`We should never reach here...`);
  }
  const bytes = new Uint8Array(Math.floor(bits.length / 8));
  let currentByteIndex = 0;
  for (let i2 = 0; i2 < bits.length; i2 += 8) {
    const bitChunk = bits.slice(i2, i2 + 8);
    const byte = parseInt(bitChunk.join(""), 2);
    bytes[currentByteIndex++] = byte;
  }
  return new TextDecoder().decode(bytes);
}
function verifyExtendedClaim(claim) {
  if (!(claim.slice(-1) === "}" || claim.slice(-1) === ",")) {
    throw new Error("Invalid claim");
  }
  const json = JSON.parse("{" + claim.slice(0, -1) + "}");
  if (Object.keys(json).length !== 1) {
    throw new Error("Invalid claim");
  }
  const key = Object.keys(json)[0];
  return [key, json[key]];
}
function extractClaimValue(claim, claimName) {
  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);
  const [name, value] = verifyExtendedClaim(extendedClaim);
  if (name !== claimName) {
    throw new Error(`Invalid field name: found ${name} expected ${claimName}`);
  }
  return value;
}
function decodeJwt(jwt) {
  const { iss, aud, sub, ...decodedJWT } = jwtDecode(jwt);
  if (!sub || !iss || !aud) {
    throw new Error("Missing jwt data");
  }
  if (Array.isArray(aud)) {
    throw new Error("Not supported aud. Aud is an array, string was expected.");
  }
  return {
    ...decodedJWT,
    iss: normalizeZkLoginIssuer(iss),
    rawIss: iss,
    aud,
    sub
  };
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/bcs.js
var zkLoginSignature = bcs.struct("ZkLoginSignature", {
  inputs: bcs.struct("ZkLoginSignatureInputs", {
    proofPoints: bcs.struct("ZkLoginSignatureInputsProofPoints", {
      a: bcs.vector(bcs.string()),
      b: bcs.vector(bcs.vector(bcs.string())),
      c: bcs.vector(bcs.string())
    }),
    issBase64Details: bcs.struct("ZkLoginSignatureInputsClaim", {
      value: bcs.string(),
      indexMod4: bcs.u8()
    }),
    headerBase64: bcs.string(),
    addressSeed: bcs.string()
  }),
  maxEpoch: bcs.u64(),
  userSignature: bcs.byteVector()
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/signature.js
function getZkLoginSignatureBytes({ inputs, maxEpoch, userSignature }) {
  return zkLoginSignature.serialize(
    {
      inputs,
      maxEpoch,
      userSignature: typeof userSignature === "string" ? fromBase64(userSignature) : userSignature
    },
    { maxSize: 2048 }
  ).toBytes();
}
function getZkLoginSignature({ inputs, maxEpoch, userSignature }) {
  const bytes = getZkLoginSignatureBytes({ inputs, maxEpoch, userSignature });
  const signatureBytes = new Uint8Array(bytes.length + 1);
  signatureBytes.set([SIGNATURE_SCHEME_TO_FLAG.ZkLogin]);
  signatureBytes.set(bytes, 1);
  return toBase64(signatureBytes);
}
function parseZkLoginSignature(signature) {
  return zkLoginSignature.parse(typeof signature === "string" ? fromBase64(signature) : signature);
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/publickey.js
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var _data;
var _client;
var _legacyAddress;
var _ZkLoginPublicIdentifier_instances;
var toLegacyAddress_fn;
var _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier2 extends PublicKey2 {
  /**
   * Create a new ZkLoginPublicIdentifier object
   * @param value zkLogin public identifier as buffer or base-64 encoded string
   */
  constructor(value, { client } = {}) {
    super();
    __privateAdd7(this, _ZkLoginPublicIdentifier_instances);
    __privateAdd7(this, _data);
    __privateAdd7(this, _client);
    __privateAdd7(this, _legacyAddress);
    __privateSet7(this, _client, client);
    if (typeof value === "string") {
      __privateSet7(this, _data, fromBase64(value));
    } else if (value instanceof Uint8Array) {
      __privateSet7(this, _data, value);
    } else {
      __privateSet7(this, _data, Uint8Array.from(value));
    }
    __privateSet7(this, _legacyAddress, __privateGet7(this, _data).length !== __privateGet7(this, _data)[0] + 1 + 32);
    if (__privateGet7(this, _legacyAddress)) {
      __privateSet7(this, _data, normalizeZkLoginPublicKeyBytes(__privateGet7(this, _data)));
    }
  }
  static fromBytes(bytes, {
    client,
    address,
    legacyAddress
  } = {}) {
    let publicKey;
    if (legacyAddress === true) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
        client
      });
    } else if (legacyAddress === false) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
    } else if (address) {
      publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, false), {
        client
      });
      if (publicKey.toSuiAddress() !== address) {
        publicKey = new _ZkLoginPublicIdentifier2(normalizeZkLoginPublicKeyBytes(bytes, true), {
          client
        });
      }
    } else {
      publicKey = new _ZkLoginPublicIdentifier2(bytes, {
        client
      });
    }
    if (address && publicKey.toSuiAddress() !== address) {
      throw new Error("Public key bytes do not match the provided address");
    }
    return publicKey;
  }
  static fromProof(address, proof) {
    const { issBase64Details, addressSeed } = proof;
    const iss = extractClaimValue(issBase64Details, "iss");
    const legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: true
    });
    if (legacyPublicKey.toSuiAddress() === address) {
      return legacyPublicKey;
    }
    const publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {
      legacyAddress: false
    });
    if (publicKey.toSuiAddress() !== address) {
      throw new Error("Proof does not match address");
    }
    return publicKey;
  }
  /**
   * Checks if two zkLogin public identifiers are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  toSuiAddress() {
    if (__privateGet7(this, _legacyAddress)) {
      return __privateMethod4(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
    }
    return super.toSuiAddress();
  }
  /**
   * Return the byte array representation of the zkLogin public identifier
   */
  toRawBytes() {
    return __privateGet7(this, _data);
  }
  /**
   * Return the Sui address associated with this ZkLogin public identifier
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ZkLogin"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(_message, _signature) {
    throw Error("does not support");
  }
  /**
   * Verifies that the signature is valid for for the provided PersonalMessage
   */
  verifyPersonalMessage(message, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(message),
      signature: parsedSignature.serializedSignature,
      intentScope: "PersonalMessage",
      client: __privateGet7(this, _client)
    });
  }
  /**
   * Verifies that the signature is valid for for the provided Transaction
   */
  verifyTransaction(transaction, signature) {
    const parsedSignature = parseSerializedZkLoginSignature(signature);
    const address = new _ZkLoginPublicIdentifier2(parsedSignature.publicKey).toSuiAddress();
    return graphqlVerifyZkLoginSignature({
      address,
      bytes: toBase64(transaction),
      signature: parsedSignature.serializedSignature,
      intentScope: "TransactionData",
      client: __privateGet7(this, _client)
    });
  }
  /**
   * Verifies that the public key is associated with the provided address
   */
  verifyAddress(address) {
    return address === super.toSuiAddress() || address === __privateMethod4(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);
  }
};
_data = /* @__PURE__ */ new WeakMap();
_client = /* @__PURE__ */ new WeakMap();
_legacyAddress = /* @__PURE__ */ new WeakMap();
_ZkLoginPublicIdentifier_instances = /* @__PURE__ */ new WeakSet();
toLegacyAddress_fn = function() {
  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet7(this, _data), true);
  const addressBytes = new Uint8Array(legacyBytes.length + 1);
  addressBytes[0] = this.flag();
  addressBytes.set(legacyBytes, 1);
  return normalizeSuiAddress(
    bytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2)
  );
};
var ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;
function toZkLoginPublicIdentifier(addressSeed, iss, options) {
  const addressSeedBytesBigEndian = options?.legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));
  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);
  tmp.set([issBytes.length], 0);
  tmp.set(issBytes, 1);
  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);
  return new ZkLoginPublicIdentifier(tmp, options);
}
function normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {
  const issByteLength = bytes[0] + 1;
  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);
  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);
  const data = new Uint8Array(issByteLength + seedBytes.length);
  data.set(bytes.slice(0, issByteLength), 0);
  data.set(seedBytes, issByteLength);
  return data;
}
async function graphqlVerifyZkLoginSignature({
  address,
  bytes,
  signature,
  intentScope,
  client = new SuiGraphQLClient({
    url: "https://sui-mainnet.mystenlabs.com/graphql"
  })
}) {
  const resp = await client.core.verifyZkLoginSignature({
    bytes,
    signature,
    intentScope,
    author: address
  });
  return resp.success === true && resp.errors.length === 0;
}
function parseSerializedZkLoginSignature(signature) {
  const bytes = typeof signature === "string" ? fromBase64(signature) : signature;
  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {
    throw new Error("Invalid signature scheme");
  }
  const signatureBytes = bytes.slice(1);
  const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
  const { issBase64Details, addressSeed } = inputs;
  const iss = extractClaimValue(issBase64Details, "iss");
  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);
  return {
    serializedSignature: toBase64(bytes),
    signatureScheme: "ZkLogin",
    zkLogin: {
      inputs,
      maxEpoch,
      userSignature,
      iss,
      addressSeed: BigInt(addressSeed)
    },
    signature: bytes,
    publicKey: publicIdentifer.toRawBytes()
  };
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/signature.js
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toBase64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromBase64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  switch (signatureScheme) {
    case "Passkey":
      return parseSerializedPasskeySignature(serializedSignature);
    case "MultiSig":
      const multisig = suiBcs.MultiSig.parse(bytes.slice(1));
      return {
        serializedSignature,
        signatureScheme,
        multisig,
        bytes,
        signature: void 0
      };
    case "ZkLogin":
      return parseSerializedZkLoginSignature(serializedSignature);
    case "ED25519":
    case "Secp256k1":
    case "Secp256r1":
      return parseSerializedKeypairSignature(serializedSignature);
    default:
      throw new Error("Unsupported signature scheme");
  }
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/mnemonics.js
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return mnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHex(mnemonicToSeed(mnemonics));
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/cryptography/keypair.js
var PRIVATE_KEY_SIZE = 32;
var SUI_PRIVATE_KEY_PREFIX = "suiprivkey";
var Signer = class {
  /**
   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,
   * it ensures that a signed message is tied to a specific purpose and domain separator is provided
   */
  async signWithIntent(bytes, intent) {
    const intentMessage = messageWithIntent(intent, bytes);
    const digest = blake2b(intentMessage, { dkLen: 32 });
    const signature = toSerializedSignature({
      signature: await this.sign(digest),
      signatureScheme: this.getKeyScheme(),
      publicKey: this.getPublicKey()
    });
    return {
      signature,
      bytes: toBase64(bytes)
    };
  }
  /**
   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope
   */
  async signTransaction(bytes) {
    return this.signWithIntent(bytes, "TransactionData");
  }
  /**
   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope
   */
  async signPersonalMessage(bytes) {
    const { signature } = await this.signWithIntent(
      bcs.byteVector().serialize(bytes).toBytes(),
      "PersonalMessage"
    );
    return {
      bytes: toBase64(bytes),
      signature
    };
  }
  async signAndExecuteTransaction({
    transaction,
    client
  }) {
    const bytes = await transaction.build({ client });
    const { signature } = await this.signTransaction(bytes);
    const response = await client.core.executeTransaction({
      transaction: bytes,
      signatures: [signature]
    });
    return response.transaction;
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
};
var Keypair = class extends Signer {
};
function decodeSuiPrivateKey(value) {
  const { prefix, words } = bech32.decode(value);
  if (prefix !== SUI_PRIVATE_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    scheme: signatureScheme,
    schema: signatureScheme,
    secretKey
  };
}
function encodeSuiPrivateKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));
}

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n4, P) * b3 % P;
  const b9 = pow2(b6, _3n4, P) * b3 % P;
  const b11 = pow2(b9, _2n3, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n4, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n3, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n3 === _0n5;
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn2, BASE } = Pointk1;
  const d_ = _normFnElement(Fn2, priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn2.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp2 = Fpk1;
  if (!Fp2.isValidNot0(x))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp2.create(x * x);
  const c = Fp2.create(xx * x + BigInt(7));
  let y = Fp2.sqrt(c);
  if (!hasEven(y))
    y = Fp2.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn2 } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn2.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn2.toBytes(Fn2.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn: Fn2, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n5, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n5, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn2.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn2.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve2 = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve2 = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey2 {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/.pnpm/@mysten+signers@0.5.7_typescript@5.9.2/node_modules/@mysten/signers/dist/esm/webcrypto/index.js
var __typeError8 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck8 = (obj, member, msg) => member.has(obj) || __typeError8("Cannot " + msg);
var __privateGet8 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd8 = (obj, member, value) => member.has(obj) ? __typeError8("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet8 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _publicKey;
function getCompressedPublicKey(publicKey) {
  const rawBytes = new Uint8Array(publicKey);
  const x = rawBytes.slice(1, 33);
  const y = rawBytes.slice(33, 65);
  const prefix = (y[31] & 1) === 0 ? 2 : 3;
  const compressed = new Uint8Array(Secp256r1PublicKey.SIZE);
  compressed[0] = prefix;
  compressed.set(x, 1);
  return compressed;
}
var _WebCryptoSigner = class _WebCryptoSigner2 extends Signer {
  constructor(privateKey, publicKey) {
    super();
    __privateAdd8(this, _publicKey);
    this.privateKey = privateKey;
    __privateSet8(this, _publicKey, new Secp256r1PublicKey(publicKey));
  }
  static async generate({ extractable = false } = {}) {
    const keypair = await globalThis.crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-256"
      },
      extractable,
      ["sign", "verify"]
    );
    const publicKey = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
    return new _WebCryptoSigner2(
      keypair.privateKey,
      getCompressedPublicKey(new Uint8Array(publicKey))
    );
  }
  /**
   * Imports a keypair using the value returned by `export()`.
   */
  static import(data) {
    return new _WebCryptoSigner2(data.privateKey, data.publicKey);
  }
  getKeyScheme() {
    return "Secp256r1";
  }
  /**
   * Exports the keypair so that it can be stored in IndexedDB.
   */
  export() {
    const exportedKeypair = {
      privateKey: this.privateKey,
      publicKey: __privateGet8(this, _publicKey).toRawBytes()
    };
    Object.defineProperty(exportedKeypair, "toJSON", {
      enumerable: false,
      value: () => {
        throw new Error(
          "The exported keypair must not be serialized. It must be stored in IndexedDB directly."
        );
      }
    });
    return exportedKeypair;
  }
  getPublicKey() {
    return __privateGet8(this, _publicKey);
  }
  async sign(bytes) {
    const rawSignature = await globalThis.crypto.subtle.sign(
      {
        name: "ECDSA",
        hash: "SHA-256"
      },
      this.privateKey,
      bytes
    );
    const signature = secp256r1.Signature.fromCompact(new Uint8Array(rawSignature));
    return signature.normalizeS().toCompactRawBytes();
  }
};
_publicKey = /* @__PURE__ */ new WeakMap();
var WebCryptoSigner = _WebCryptoSigner;

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n4 = BigInt(2);
var _8n2 = BigInt(8);
function isEdValidXY(Fp2, CURVE, x, y) {
  const x2 = Fp2.sqr(x);
  const y2 = Fp2.sqr(y);
  const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
  const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
  return Fp2.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp2, Fn: Fn2 } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n4 << BigInt(Fn2.BYTES * 8) - _1n6;
  const modP = (n) => Fp2.create(n);
  const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n6 };
    }
  });
  if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n6 : _0n6;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp2.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp2.mul(Z, iz);
    if (is0)
      return { x: _0n6, y: _1n6 };
    if (zz !== _1n6)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // TODO: remove
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, points);
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn2, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n6, modP(x * y));
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n4);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n4 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n6, CURVE_ORDER);
      const { p, f } = wnaf.cached(this, n, (p2) => normalizeZ(Point2, p2));
      return normalizeZ(Point2, [p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n6, CURVE_ORDER);
      if (n === _0n6)
        return Point2.ZERO;
      if (this.is0() || n === _1n6)
        return this;
      return wnaf.unsafe(this, n, (p) => normalizeZ(Point2, p), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n6)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes, zip215 = false) {
      abytes(bytes);
      return Point2.fromHex(bytes, zip215);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes2("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n6, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n6);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n6) === _1n6;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n6 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp2.BYTES);
      bytes[bytes.length - 1] |= x & _1n6 ? 128 : 0;
      return bytes;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n6, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n6, _1n6, _1n6, _0n6);
  Point2.Fp = Fp2;
  Point2.Fn = Fn2;
  const wnaf = new wNAF(Point2, Fn2.BYTES * 8);
  return Point2;
}
var PrimeEdwardsPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes2) {
    throw new Error("fromBytes must be implemented by subclass");
  }
  static fromHex(_hex) {
    throw new Error("fromHex must be implemented by subclass");
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
};
function eddsa(Point2, cHash, eddsaOpts) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE: G, Fp: Fp2, Fn: Fn2 } = Point2;
  const CURVE_ORDER = Fn2.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a) {
    return Fn2.create(a);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = Fp2.BYTES;
    key = ensureBytes2("private key", key, len);
    const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
  }
  function sign(msg, secretKey, options = {}) {
    msg = ensureBytes2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange("signature.s", s, _0n6, CURVE_ORDER);
    const L = Fp2.BYTES;
    const res = concatBytes(R, numberToBytesLE(s, L));
    return ensureBytes2("result", res, L * 2);
  }
  const verifyOpts = { zip215: true };
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes2("signature", sig, 2 * len);
    msg = ensureBytes2("message", msg);
    publicKey = ensureBytes2("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const size = Fp2.BYTES;
  const lengths = {
    secret: size,
    public: size,
    signature: 2 * size,
    seed: size
  };
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return seed;
  }
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    randomPrivateKey: randomSecretKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     *
     * There is NO `fromMontgomery`:
     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate
     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*
     *   accepts inputs on the quadratic twist, which can't be moved to ed25519
     */
    toMontgomery(publicKey) {
      const { y } = Point2.fromBytes(publicKey);
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp2.div(_1n6 + y, _1n6 - y) : Fp2.div(y - _1n6, y + _1n6);
      return Fp2.toBytes(u);
    },
    toMontgomeryPriv(privateKey) {
      abytes(privateKey, size);
      const hashed = cHash(privateKey.subarray(0, size));
      return adjustScalarBytes2(hashed).subarray(0, size);
    },
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key) {
    try {
      return !!Fn2.fromBytes(key, false);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point2.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    utils,
    Point: Point2,
    info: { type: "edwards", lengths }
  });
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp2 = c.Fp;
  const Fn2 = Field2(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp2, Fn: Fn2, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point2 = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point2, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n5 ** BigInt(254) : _2n5 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n5 ** BigInt(251) - _1n7 : BigInt(4) * _2n5 ** BigInt(445) - _1n7;
  const maxScalar = minScalar + maxAdded + _1n7;
  const modP = (n) => mod2(n, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes2("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(ensureBytes2("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n7)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n7, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n7;
    let z_2 = _0n7;
    let x_3 = u;
    let z_3 = _1n7;
    let swap = _0n7;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n7; t--) {
      const k_t = k >> t & _1n7;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const randomSecretKey = (seed = randomBytes_(fieldLen)) => seed;
  const utils = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey
  };
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: scalarMultBase(secretKey) };
  }
  const lengths = {
    secret: fieldLen,
    public: fieldLen,
    seed: fieldLen
  };
  return {
    keygen,
    getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
    getPublicKey: (secretKey) => scalarMultBase(secretKey),
    scalarMult,
    scalarMultBase,
    utils,
    GuBytes: GuBytes.slice(),
    info: { type: "montgomery", lengths }
  };
}

// node_modules/.pnpm/@noble+curves@1.9.4/node_modules/@noble/curves/esm/ed25519.js
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n6 = BigInt(2);
var _3n3 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE.p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow22(b2, _2n6, P) * b2 % P;
  const b5 = pow22(b4, _1n8, P) * x % P;
  const b10 = pow22(b5, _5n2, P) * b5 % P;
  const b20 = pow22(b10, _10n, P) * b10 % P;
  const b40 = pow22(b20, _20n, P) * b20 % P;
  const b80 = pow22(b40, _40n, P) * b40 % P;
  const b160 = pow22(b80, _80n, P) * b80 % P;
  const b240 = pow22(b160, _80n, P) * b80 % P;
  const b250 = pow22(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow22(b250, _2n6, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P = ed25519_CURVE.p;
  const v3 = mod2(v * v * v, P);
  const v7 = mod2(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow, P);
  const vx2 = mod2(v * x * x, P);
  const root1 = x;
  const root2 = mod2(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u, P);
  const noRoot = vx2 === mod2(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod2(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = (() => Field2(ed25519_CURVE.p, { isLE: true }))();
var Fn = (() => Field2(ed25519_CURVE.n, { isLE: true }))();
var ed25519Defaults = (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha512,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => {
  const P = ed25519_CURVE.p;
  return montgomery({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod2(pow22(pow_p_5_8, _3n3, P) * b2, P);
    },
    adjustScalarBytes
  });
})();
var ELL2_C1 = (() => (Fp.ORDER + _3n3) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n6, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (Fp.ORDER - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n6);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n8 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e);
  xd = Fp.cmov(xd, Fp.ONE, e);
  yn = Fp.cmov(yn, Fp.ONE, e);
  yd = Fp.cmov(yd, Fp.ONE, e);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
var ed25519_hasher = (() => createHasher3(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n8, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod3 = ed25519.CURVE.Fp.create;
  const r = mod3(SQRT_M1 * r0 * r0);
  const Ns = mod3((r + _1n8) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod3((c - d * r) * mod3(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod3(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod3(c * (r - _1n8) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod3((s + s) * D);
  const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod3(_1n8 - s2);
  const W3 = mod3(_1n8 + s2);
  return new ed25519.Point(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
}
function ristretto255_map(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap(r1);
  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap(r2);
  return new _RistrettoPoint(R1.add(R2));
}
var _RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new __RistrettoPoint(ed25519.Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof __RistrettoPoint))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new __RistrettoPoint(ep);
  }
  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
  static hashToCurve(hex) {
    return ristretto255_map(ensureBytes2("ristrettoHash", hex, 64));
  }
  static fromBytes(bytes) {
    abytes(bytes, 32);
    const { a, d } = ed25519.CURVE;
    const P = Fp.ORDER;
    const mod3 = Fp.create;
    const s = bytes255ToNumberLE(bytes);
    if (!equalBytes(numberToBytesLE(s, 32), bytes) || isNegativeLE(s, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s2 = mod3(s * s);
    const u1 = mod3(_1n8 + a * s2);
    const u2 = mod3(_1n8 - a * s2);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u2 * u2);
    const v = mod3(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
    const Dx = mod3(I * u2);
    const Dy = mod3(I * Dx * v);
    let x = mod3((s + s) * Dx);
    if (isNegativeLE(x, P))
      x = mod3(-x);
    const y = mod3(u1 * Dy);
    const t = mod3(x * y);
    if (!isValid || isNegativeLE(t, P) || y === _0n8)
      throw new Error("invalid ristretto255 encoding 2");
    return new __RistrettoPoint(new ed25519.Point(x, y, _1n8, t));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    return __RistrettoPoint.fromBytes(ensureBytes2("ristrettoHex", hex, 32));
  }
  static msm(points, scalars) {
    return pippenger(__RistrettoPoint, ed25519.Point.Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = Fp.ORDER;
    const mod3 = Fp.create;
    const u1 = mod3(mod3(Z + Y) * mod3(Z - Y));
    const u2 = mod3(X * Y);
    const u2sq = mod3(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D2 = mod3(invsqrt * u2);
    const zInv = mod3(D1 * D2 * T);
    let D;
    if (isNegativeLE(T * zInv, P)) {
      let _x = mod3(Y * SQRT_M1);
      let _y = mod3(X * SQRT_M1);
      X = _x;
      Y = _y;
      D = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(X * zInv, P))
      Y = mod3(-Y);
    let s = mod3((Z - Y) * D);
    if (isNegativeLE(s, P))
      s = mod3(-s);
    return numberToBytesLE(s, 32);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod3 = Fp.create;
    const one = mod3(X1 * Y2) === mod3(Y1 * X2);
    const two = mod3(Y1 * Y2) === mod3(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(__RistrettoPoint.ZERO);
  }
};
_RistrettoPoint.BASE = (() => new _RistrettoPoint(ed25519.Point.BASE))();
_RistrettoPoint.ZERO = (() => new _RistrettoPoint(ed25519.Point.ZERO))();
_RistrettoPoint.Fp = Fp;
_RistrettoPoint.Fn = Fn;
var ristretto255_hasher = {
  hashToCurve(msg, options) {
    const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
    return ristretto255_map(expand_message_xmd(msg, DST, 64, sha512));
  },
  hashToScalar(msg, options = { DST: _DST_scalar }) {
    return Fn.create(bytesToNumberLE(expand_message_xmd(msg, options.DST, 64, sha512)));
  }
};
var hashToCurve3 = (() => ed25519_hasher.hashToCurve)();
var encodeToCurve3 = (() => ed25519_hasher.encodeToCurve)();
var hashToRistretto255 = (() => ristretto255_hasher.hashToCurve)();
var hash_to_ristretto255 = (() => ristretto255_hasher.hashToCurve)();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/ed25519-hd-key.js
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = hmac.create(sha5122, ED25519_CURVE);
  const I = h.update(fromHex(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);
  const I = hmac.create(sha5122, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {
    key,
    chainCode
  });
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/publickey.js
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class extends PublicKey2 {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["ED25519"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "ED25519") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return ed25519.verify(bytes, message, this.toRawBytes());
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/keypairs/ed25519/keypair.js
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class _Ed25519Keypair extends Keypair {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = {
        publicKey: keypair.publicKey,
        secretKey: keypair.secretKey.slice(0, 32)
      };
    } else {
      const privateKey = ed25519.utils.randomPrivateKey();
      this.keypair = {
        publicKey: ed25519.getPublicKey(privateKey),
        secretKey: privateKey
      };
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    const secretKey = ed25519.utils.randomPrivateKey();
    return new _Ed25519Keypair({
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    });
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key as a byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "ED25519") {
        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = {
      publicKey: ed25519.getPublicKey(secretKey),
      secretKey
    };
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = ed25519.sign(signData, secretKey);
      if (!ed25519.verify(signature, signData, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new _Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Ed25519 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(
      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),
      this.getKeyScheme()
    );
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  async sign(data) {
    return ed25519.sign(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return _Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * Derive Ed25519 keypair from mnemonicSeed and path.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypairFromSeed(seedHex, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, seedHex);
    return _Ed25519Keypair.fromSecretKey(key);
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/utils/constants.js
var MIST_PER_SUI = BigInt(1e9);
var MOVE_STDLIB_ADDRESS = "0x1";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");
var SUI_RANDOM_OBJECT_ID = normalizeSuiObjectId("0x8");

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/zklogin/address.js
var MAX_PADDED_UNSIGNED_JWT_LEN = 64 * 25;

// node_modules/.pnpm/idb-keyval@6.2.2/node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves) i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  let promise = cb().finally(endTask);
  promise.t = true;
  return promise;
}
function allTasks() {
  if (tasks === 0) {
    return Promise.resolve();
  } else {
    return new Promise((resolve) => {
      resolves.push(resolve);
    });
  }
}

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/clean-stores/index.js
var clean2 = Symbol("clean");

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean2] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/lifecycle/index.js
var SET = 2;
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object2, listener, eventKey, mutateStore) => {
  object2.events = object2.events || {};
  if (!object2.events[eventKey + REVERT_MUTATION]) {
    object2.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object2.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object2.events[eventKey] = object2.events[eventKey] || [];
  object2.events[eventKey].push(listener);
  return () => {
    let currentListeners = object2.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object2.events[eventKey];
      object2.events[eventKey + REVERT_MUTATION]();
      delete object2.events[eventKey + REVERT_MUTATION];
    }
  };
};
var onSet = ($store, listener) => on($store, listener, SET, (runListeners) => {
  let originSet = $store.set;
  let originSetKey = $store.setKey;
  if ($store.setKey) {
    $store.setKey = (changed, changedValue) => {
      let isAborted;
      let abort = () => {
        isAborted = true;
      };
      runListeners({
        abort,
        changed,
        newValue: { ...$store.value, [changed]: changedValue }
      });
      if (!isAborted) return originSetKey(changed, changedValue);
    };
  }
  $store.set = (newValue) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, newValue });
    if (!isAborted) return originSet(newValue);
  };
  return () => {
    $store.set = originSet;
    $store.setKey = originSetKey;
  };
});
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean2];
      $store[clean2] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/encryption.js
function createDefaultEncryption() {
  async function keyFromPassword(password, salt) {
    const key = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(password),
      { name: "PBKDF2" },
      false,
      ["deriveBits", "deriveKey"]
    );
    const derivedKey = await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 9e5,
        hash: "SHA-256"
      },
      key,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    return { key, derivedKey };
  }
  return {
    async encrypt(password, data) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const { derivedKey } = await keyFromPassword(password, salt);
      const payload = await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv
        },
        derivedKey,
        new TextEncoder().encode(data)
      );
      return JSON.stringify({
        payload: toBase64(new Uint8Array(payload)),
        iv: toBase64(iv),
        salt: toBase64(salt)
      });
    },
    async decrypt(password, data) {
      const parsed = JSON.parse(data);
      if (!parsed.payload || !parsed.iv || !parsed.salt) {
        throw new Error("Invalid encrypted data");
      }
      const { derivedKey } = await keyFromPassword(password, fromBase64(parsed.salt));
      const decryptedContent = await crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: fromBase64(parsed.iv)
        },
        derivedKey,
        fromBase64(parsed.payload)
      );
      return new TextDecoder().decode(decryptedContent);
    }
  };
}

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/EnokiKeypair.js
var __typeError9 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck9 = (obj, member, msg) => member.has(obj) || __typeError9("Cannot " + msg);
var __privateGet9 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd9 = (obj, member, value) => member.has(obj) ? __typeError9("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet9 = (obj, member, value, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _proof;
var _maxEpoch;
var _ephemeralKeypair;
var _publicKey2;
var EnokiPublicKey = class extends ZkLoginPublicIdentifier {
};
var EnokiKeypair = class extends Signer {
  constructor(input) {
    super();
    __privateAdd9(this, _proof);
    __privateAdd9(this, _maxEpoch);
    __privateAdd9(this, _ephemeralKeypair);
    __privateAdd9(this, _publicKey2);
    __privateSet9(this, _proof, input.proof);
    __privateSet9(this, _maxEpoch, input.maxEpoch);
    __privateSet9(this, _ephemeralKeypair, input.ephemeralKeypair);
    __privateSet9(this, _publicKey2, EnokiPublicKey.fromProof(input.address, input.proof));
  }
  async sign(data) {
    return __privateGet9(this, _ephemeralKeypair).sign(data);
  }
  async signPersonalMessage(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet9(this, _ephemeralKeypair).signPersonalMessage(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet9(this, _proof),
      maxEpoch: __privateGet9(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  async signTransaction(bytes) {
    const { bytes: signedBytes, signature: userSignature } = await __privateGet9(this, _ephemeralKeypair).signTransaction(bytes);
    const zkSignature = getZkLoginSignature({
      inputs: __privateGet9(this, _proof),
      maxEpoch: __privateGet9(this, _maxEpoch),
      userSignature
    });
    return {
      bytes: signedBytes,
      signature: zkSignature
    };
  }
  getKeyScheme() {
    return __privateGet9(this, _ephemeralKeypair).getKeyScheme();
  }
  getPublicKey() {
    return __privateGet9(this, _publicKey2);
  }
};
_proof = /* @__PURE__ */ new WeakMap();
_maxEpoch = /* @__PURE__ */ new WeakMap();
_ephemeralKeypair = /* @__PURE__ */ new WeakMap();
_publicKey2 = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/stores.js
function createWebStorage(storage) {
  return {
    get(key) {
      return storage.getItem(key);
    },
    set(key, value) {
      storage.setItem(key, value);
    },
    delete(key) {
      storage.removeItem(key);
    }
  };
}
function createInMemoryStorage() {
  const store = /* @__PURE__ */ new Map();
  return {
    get(key) {
      return store.get(key) ?? null;
    },
    set(key, value) {
      store.set(key, value);
    },
    delete(key) {
      store.delete(key);
    }
  };
}
function createLocalStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.localStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.localStorage);
}
function createSessionStorage() {
  if (typeof window === "undefined") {
    console.warn("`window.sessionStorage` is not available, falling back to in-memory storage");
    return createInMemoryStorage();
  }
  return createWebStorage(window.sessionStorage);
}

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/EnokiFlow.js
var __typeError10 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck10 = (obj, member, msg) => member.has(obj) || __typeError10("Cannot " + msg);
var __privateGet10 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd10 = (obj, member, value) => member.has(obj) ? __typeError10("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet10 = (obj, member, value, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck10(obj, member, "access private method"), method);
var _storageKeys;
var _enokiClient;
var _encryption;
var _encryptionKey;
var _store;
var _useNativeCryptoSigner;
var _idbStore;
var _EnokiFlow_instances;
var setSession_fn;
var createStorageKeys = (apiKey) => ({
  STATE: `@enoki/flow/state/${apiKey}`,
  SESSION: `@enoki/flow/session/${apiKey}`
});
var EnokiFlow = class {
  constructor(config) {
    __privateAdd10(this, _EnokiFlow_instances);
    __privateAdd10(this, _storageKeys);
    __privateAdd10(this, _enokiClient);
    __privateAdd10(this, _encryption);
    __privateAdd10(this, _encryptionKey);
    __privateAdd10(this, _store);
    __privateAdd10(this, _useNativeCryptoSigner);
    __privateAdd10(this, _idbStore);
    __privateSet10(this, _enokiClient, new EnokiClient({
      apiKey: config.apiKey,
      apiUrl: config.apiUrl
    }));
    __privateSet10(this, _encryptionKey, config.apiKey);
    if (config.experimental_nativeCryptoSigner) {
      __privateSet10(this, _useNativeCryptoSigner, true);
      __privateSet10(this, _idbStore, createStore(config.apiKey, "enoki"));
    } else {
      __privateSet10(this, _useNativeCryptoSigner, false);
    }
    __privateSet10(this, _encryption, config.encryption ?? createDefaultEncryption());
    __privateSet10(this, _store, config.store ?? createSessionStorage());
    __privateSet10(this, _storageKeys, createStorageKeys(config.apiKey));
    let storedState = null;
    try {
      const rawStoredValue = __privateGet10(this, _store).get(__privateGet10(this, _storageKeys).STATE);
      if (rawStoredValue) {
        storedState = JSON.parse(rawStoredValue);
      }
    } catch {
    }
    this.$zkLoginState = atom(storedState || {});
    this.$zkLoginSession = atom({ initialized: false, value: null });
    onMount(this.$zkLoginSession, () => {
      this.getSession();
    });
    onSet(this.$zkLoginState, ({ newValue }) => {
      __privateGet10(this, _store).set(__privateGet10(this, _storageKeys).STATE, JSON.stringify(newValue));
    });
  }
  get enokiClient() {
    return __privateGet10(this, _enokiClient);
  }
  async createAuthorizationURL(input) {
    const ephemeralKeyPair = __privateGet10(this, _useNativeCryptoSigner) ? await WebCryptoSigner.generate() : new Ed25519Keypair();
    const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet10(this, _enokiClient).createZkLoginNonce({
      network: input.network,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    const params = new URLSearchParams({
      ...input.extraParams,
      nonce,
      client_id: input.clientId,
      redirect_uri: input.redirectUrl,
      response_type: "id_token",
      // TODO: Eventually fetch the scopes for this client ID from the Enoki service:
      scope: [
        "openid",
        // Merge the requested scopes in with the required openid scopes:
        ...input.extraParams && "scope" in input.extraParams ? input.extraParams.scope : []
      ].filter(Boolean).join(" ")
    });
    let oauthUrl;
    switch (input.provider) {
      case "google": {
        oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
        break;
      }
      case "facebook": {
        oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
        break;
      }
      case "twitch": {
        params.set("force_verify", "true");
        oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
        break;
      }
      default:
        throw new Error(`Invalid provider: ${input.provider}`);
    }
    this.$zkLoginState.set({ provider: input.provider });
    if (__privateGet10(this, _useNativeCryptoSigner)) {
      await set("ephemeralKeyPair", ephemeralKeyPair.export(), __privateGet10(this, _idbStore));
    }
    await __privateMethod5(this, _EnokiFlow_instances, setSession_fn).call(this, {
      expiresAt: estimatedExpiration,
      maxEpoch,
      randomness,
      ephemeralKeyPair: __privateGet10(this, _useNativeCryptoSigner) ? "@@native" : toBase64(
        decodeSuiPrivateKey(ephemeralKeyPair.getSecretKey()).secretKey
      )
    });
    return oauthUrl;
  }
  // TODO: Should our SDK manage this automatically in addition to exposing a method?
  async handleAuthCallback(hash = window.location.hash) {
    const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
    const zkp = await this.getSession();
    if (!zkp || !zkp.ephemeralKeyPair || !zkp.maxEpoch || !zkp.randomness) {
      throw new Error(
        "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
      );
    }
    const jwt = params.get("id_token");
    if (!jwt) {
      throw new Error("Missing ID Token");
    }
    decodeJwt(jwt);
    const { address, salt, publicKey } = await __privateGet10(this, _enokiClient).getZkLogin({ jwt });
    this.$zkLoginState.set({
      ...this.$zkLoginState.get(),
      salt,
      address,
      publicKey
    });
    await __privateMethod5(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      jwt
    });
    return params.get("state");
  }
  async getSession() {
    if (this.$zkLoginSession.get().initialized) {
      return this.$zkLoginSession.get().value;
    }
    try {
      const storedValue = __privateGet10(this, _store).get(__privateGet10(this, _storageKeys).SESSION);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet10(this, _encryption).decrypt(__privateGet10(this, _encryptionKey), storedValue)
      );
      if (state?.expiresAt && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        this.$zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      this.$zkLoginSession.set({ initialized: true, value: null });
    }
    return this.$zkLoginSession.get().value;
  }
  async logout() {
    this.$zkLoginState.set({});
    __privateGet10(this, _store).delete(__privateGet10(this, _storageKeys).STATE);
    if (__privateGet10(this, _useNativeCryptoSigner)) {
      await clear(__privateGet10(this, _idbStore));
    }
    await __privateMethod5(this, _EnokiFlow_instances, setSession_fn).call(this, null);
  }
  // TODO: Should this return the proof if it already exists?
  async getProof({ network } = {}) {
    const zkp = await this.getSession();
    const { salt } = this.$zkLoginState.get();
    if (zkp?.proof) {
      if (zkp.expiresAt && Date.now() > zkp.expiresAt) {
        throw new Error("Stored proof is expired.");
      }
      return zkp.proof;
    }
    if (!salt || !zkp || !zkp.jwt) {
      throw new Error("Missing required parameters for proof generation");
    }
    let storedNativeSigner = void 0;
    if (__privateGet10(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet10(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeyPair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    const proof = await __privateGet10(this, _enokiClient).createZkLoginZkp({
      network,
      jwt: zkp.jwt,
      maxEpoch: zkp.maxEpoch,
      randomness: zkp.randomness,
      ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
    });
    await __privateMethod5(this, _EnokiFlow_instances, setSession_fn).call(this, {
      ...zkp,
      proof
    });
    return proof;
  }
  async getKeypair({ network } = {}) {
    await this.getProof({ network });
    const zkp = await this.getSession();
    const { address } = this.$zkLoginState.get();
    if (!address || !zkp || !zkp.proof) {
      throw new Error("Missing required data for keypair generation.");
    }
    if (Date.now() > zkp.expiresAt) {
      throw new Error("Stored proof is expired.");
    }
    let storedNativeSigner = void 0;
    if (__privateGet10(this, _useNativeCryptoSigner) && zkp.ephemeralKeyPair === "@@native") {
      storedNativeSigner = await get("ephemeralKeyPair", __privateGet10(this, _idbStore));
      if (!storedNativeSigner) {
        throw new Error("Native signer not found in store.");
      }
    }
    const ephemeralKeypair = zkp.ephemeralKeyPair === "@@native" ? WebCryptoSigner.import(storedNativeSigner) : Ed25519Keypair.fromSecretKey(fromBase64(zkp.ephemeralKeyPair));
    return new EnokiKeypair({
      address,
      ephemeralKeypair,
      maxEpoch: zkp.maxEpoch,
      proof: zkp.proof
    });
  }
};
_storageKeys = /* @__PURE__ */ new WeakMap();
_enokiClient = /* @__PURE__ */ new WeakMap();
_encryption = /* @__PURE__ */ new WeakMap();
_encryptionKey = /* @__PURE__ */ new WeakMap();
_store = /* @__PURE__ */ new WeakMap();
_useNativeCryptoSigner = /* @__PURE__ */ new WeakMap();
_idbStore = /* @__PURE__ */ new WeakMap();
_EnokiFlow_instances = /* @__PURE__ */ new WeakSet();
setSession_fn = async function(newValue) {
  if (newValue) {
    const storedValue = await __privateGet10(this, _encryption).encrypt(
      __privateGet10(this, _encryptionKey),
      JSON.stringify(newValue)
    );
    __privateGet10(this, _store).set(__privateGet10(this, _storageKeys).SESSION, storedValue);
  } else {
    __privateGet10(this, _store).delete(__privateGet10(this, _storageKeys).SESSION);
  }
  this.$zkLoginSession.set({ initialized: true, value: newValue });
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/serializer.js
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
function isTxContext(param) {
  const struct = typeof param.body === "object" && "datatype" in param.body ? param.body.datatype : null;
  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress("0x2") && struct.module === "tx_context" && struct.type === "TxContext";
}
function getPureBcsSchema(typeSignature) {
  if (typeof typeSignature === "string") {
    switch (typeSignature) {
      case "address":
        return suiBcs.Address;
      case "bool":
        return suiBcs.Bool;
      case "u8":
        return suiBcs.U8;
      case "u16":
        return suiBcs.U16;
      case "u32":
        return suiBcs.U32;
      case "u64":
        return suiBcs.U64;
      case "u128":
        return suiBcs.U128;
      case "u256":
        return suiBcs.U256;
      default:
        throw new Error(`Unknown type signature ${typeSignature}`);
    }
  }
  if ("vector" in typeSignature) {
    if (typeSignature.vector === "u8") {
      return suiBcs.byteVector().transform({
        input: (val) => typeof val === "string" ? new TextEncoder().encode(val) : val,
        output: (val) => val
      });
    }
    const type = getPureBcsSchema(typeSignature.vector);
    return type ? suiBcs.vector(type) : null;
  }
  if ("datatype" in typeSignature) {
    const pkg = normalizeSuiAddress(typeSignature.datatype.package);
    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {
      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {
        return suiBcs.String;
      }
      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {
        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);
        return type ? suiBcs.vector(type) : null;
      }
    }
    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizedTypeToMoveTypeSignature(type) {
  if (typeof type === "object" && "Reference" in type) {
    return {
      ref: "&",
      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)
    };
  }
  if (typeof type === "object" && "MutableReference" in type) {
    return {
      ref: "&mut",
      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)
    };
  }
  return {
    ref: null,
    body: normalizedTypeToMoveTypeSignatureBody(type)
  };
}
function normalizedTypeToMoveTypeSignatureBody(type) {
  if (typeof type === "string") {
    switch (type) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${type}`);
    }
  }
  if ("Vector" in type) {
    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };
  }
  if ("Struct" in type) {
    return {
      datatype: {
        package: type.Struct.address,
        module: type.Struct.module,
        type: type.Struct.name,
        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)
      }
    };
  }
  if ("TypeParameter" in type) {
    return { typeParameter: type.TypeParameter };
  }
  throw new Error(`Unexpected type ${JSON.stringify(type)}`);
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/Inputs.js
function Pure(data) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()
    }
  };
}
var Inputs = {
  Pure,
  ObjectRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  ReceivingRef({ objectId, digest, version }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest,
          version,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/Commands.js
var UpgradePolicy = ((UpgradePolicy2) => {
  UpgradePolicy2[UpgradePolicy2["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy2[UpgradePolicy2["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy2[UpgradePolicy2["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy2;
})(UpgradePolicy || {});
var Commands = {
  MoveCall(input) {
    const [pkg, mod3 = "", fn = ""] = "target" in input ? input.target.split("::") : [input.package, input.module, input.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: pkg,
        module: mod3,
        function: fn,
        typeArguments: input.typeArguments ?? [],
        arguments: input.arguments ?? []
      }
    };
  },
  TransferObjects(objects, address) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: objects.map((o) => parse(ArgumentSchema, o)),
        address: parse(ArgumentSchema, address)
      }
    };
  },
  SplitCoins(coin, amounts) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: parse(ArgumentSchema, coin),
        amounts: amounts.map((o) => parse(ArgumentSchema, o))
      }
    };
  },
  MergeCoins(destination, sources) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: parse(ArgumentSchema, destination),
        sources: sources.map((o) => parse(ArgumentSchema, o))
      }
    };
  },
  Publish({
    modules,
    dependencies
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      }
    };
  },
  Upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: modules.map(
          (module) => typeof module === "string" ? module : toBase64(new Uint8Array(module))
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        package: packageId,
        ticket: parse(ArgumentSchema, ticket)
      }
    };
  },
  MakeMoveVec({
    type,
    elements
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: type ?? null,
        elements: elements.map((o) => parse(ArgumentSchema, o))
      }
    };
  },
  Intent({
    name,
    inputs = {},
    data = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name,
        inputs: Object.fromEntries(
          Object.entries(inputs).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.map((o) => parse(ArgumentSchema, o)) : parse(ArgumentSchema, value)
          ])
        ),
        data
      }
    };
  }
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/data/v2.js
function enumUnion(options) {
  return union(
    Object.entries(options).map(([key, value]) => object({ [key]: value }))
  );
}
var Argument2 = enumUnion({
  GasCoin: literal(true),
  Input: pipe(number(), integer()),
  Result: pipe(number(), integer()),
  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])
});
var GasData2 = object({
  budget: nullable(JsonU64),
  price: nullable(JsonU64),
  owner: nullable(SuiAddress),
  payment: nullable(array(ObjectRefSchema))
});
var ProgrammableMoveCall2 = object({
  package: ObjectID,
  module: string(),
  function: string(),
  // snake case in rust
  typeArguments: array(string()),
  arguments: array(Argument2)
});
var $Intent2 = object({
  name: string(),
  inputs: record(string(), union([Argument2, array(Argument2)])),
  data: record(string(), unknown())
});
var Command2 = enumUnion({
  MoveCall: ProgrammableMoveCall2,
  TransferObjects: object({
    objects: array(Argument2),
    address: Argument2
  }),
  SplitCoins: object({
    coin: Argument2,
    amounts: array(Argument2)
  }),
  MergeCoins: object({
    destination: Argument2,
    sources: array(Argument2)
  }),
  Publish: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID)
  }),
  MakeMoveVec: object({
    type: nullable(string()),
    elements: array(Argument2)
  }),
  Upgrade: object({
    modules: array(BCSBytes),
    dependencies: array(ObjectID),
    package: ObjectID,
    ticket: Argument2
  }),
  $Intent: $Intent2
});
var ObjectArg3 = enumUnion({
  ImmOrOwnedObject: ObjectRefSchema,
  SharedObject: object({
    objectId: ObjectID,
    // snake case in rust
    initialSharedVersion: JsonU64,
    mutable: boolean()
  }),
  Receiving: ObjectRefSchema
});
var CallArg2 = enumUnion({
  Object: ObjectArg3,
  Pure: object({
    bytes: BCSBytes
  }),
  UnresolvedPure: object({
    value: unknown()
  }),
  UnresolvedObject: object({
    objectId: ObjectID,
    version: optional(nullable(JsonU64)),
    digest: optional(nullable(string())),
    initialSharedVersion: optional(nullable(JsonU64)),
    mutable: optional(nullable(boolean()))
  })
});
var TransactionExpiration4 = enumUnion({
  None: literal(true),
  Epoch: JsonU64
});
var SerializedTransactionDataV2Schema = object({
  version: literal(2),
  sender: nullish(SuiAddress),
  expiration: nullish(TransactionExpiration4),
  gasData: GasData2,
  inputs: array(CallArg2),
  commands: array(Command2),
  digest: optional(nullable(string()))
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/jsonRpc/json-rpc-resolver.js
var MAX_OBJECTS_PER_FETCH = 50;
var GAS_SAFE_OVERHEAD = 1000n;
var MAX_GAS = 5e10;
function jsonRpcClientResolveTransactionPlugin(client) {
  return async function resolveTransactionData(transactionData, options, next) {
    await normalizeInputs(transactionData, client);
    await resolveObjectReferences(transactionData, client);
    if (!options.onlyTransactionKind) {
      await setGasPrice(transactionData, client);
      await setGasBudget(transactionData, client);
      await setGasPayment(transactionData, client);
    }
    return await next();
  };
}
async function setGasPrice(transactionData, client) {
  if (!transactionData.gasConfig.price) {
    transactionData.gasConfig.price = String(await client.getReferenceGasPrice());
  }
}
async function setGasBudget(transactionData, client) {
  if (transactionData.gasConfig.budget) {
    return;
  }
  const dryRunResult = await client.dryRunTransactionBlock({
    transactionBlock: transactionData.build({
      overrides: {
        gasData: {
          budget: String(MAX_GAS),
          payment: []
        }
      }
    })
  });
  if (dryRunResult.effects.status.status !== "success") {
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
      { cause: dryRunResult }
    );
  }
  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);
  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;
  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);
  transactionData.gasConfig.budget = String(
    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead
  );
}
async function setGasPayment(transactionData, client) {
  if (!transactionData.gasConfig.payment) {
    const coins = await client.getCoins({
      owner: transactionData.gasConfig.owner || transactionData.sender,
      coinType: SUI_TYPE_ARG
    });
    const paymentCoins = coins.data.filter((coin) => {
      const matchingInput = transactionData.inputs.find((input) => {
        if (input.Object?.ImmOrOwnedObject) {
          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;
        }
        return false;
      });
      return !matchingInput;
    }).map((coin) => ({
      objectId: coin.coinObjectId,
      digest: coin.digest,
      version: coin.version
    }));
    if (!paymentCoins.length) {
      throw new Error("No valid gas coins found for the transaction.");
    }
    transactionData.gasConfig.payment = paymentCoins.map(
      (payment) => parse(ObjectRefSchema, payment)
    );
  }
}
async function resolveObjectReferences(transactionData, client) {
  const objectsToResolve = transactionData.inputs.filter((input) => {
    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);
  });
  const dedupedIds = [
    ...new Set(
      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))
    )
  ];
  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];
  const resolved = (await Promise.all(
    objectChunks.map(
      (chunk2) => client.multiGetObjects({
        ids: chunk2,
        options: { showOwner: true }
      })
    )
  )).flat();
  const responsesById = new Map(
    dedupedIds.map((id, index) => {
      return [id, resolved[index]];
    })
  );
  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));
  if (invalidObjects.length) {
    throw new Error(`The following input objects are invalid: ${invalidObjects.join(", ")}`);
  }
  const objects = resolved.map((object2) => {
    if (object2.error || !object2.data) {
      throw new Error(`Failed to fetch object: ${object2.error}`);
    }
    const owner = object2.data.owner;
    const initialSharedVersion = owner && typeof owner === "object" ? "Shared" in owner ? owner.Shared.initial_shared_version : "ConsensusAddressOwner" in owner ? owner.ConsensusAddressOwner.start_version : null : null;
    return {
      objectId: object2.data.objectId,
      digest: object2.data.digest,
      version: object2.data.version,
      initialSharedVersion
    };
  });
  const objectsById = new Map(
    dedupedIds.map((id, index) => {
      return [id, objects[index]];
    })
  );
  for (const [index, input] of transactionData.inputs.entries()) {
    if (!input.UnresolvedObject) {
      continue;
    }
    let updated;
    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);
    const object2 = objectsById.get(id);
    if (input.UnresolvedObject.initialSharedVersion ?? object2?.initialSharedVersion) {
      updated = Inputs.SharedObjectRef({
        objectId: id,
        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object2?.initialSharedVersion,
        mutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index)
      });
    } else if (isUsedAsReceiving(transactionData, index)) {
      updated = Inputs.ReceivingRef(
        {
          objectId: id,
          digest: input.UnresolvedObject.digest ?? object2?.digest,
          version: input.UnresolvedObject.version ?? object2?.version
        }
      );
    }
    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({
      objectId: id,
      digest: input.UnresolvedObject.digest ?? object2?.digest,
      version: input.UnresolvedObject.version ?? object2?.version
    });
  }
}
async function normalizeInputs(transactionData, client) {
  const { inputs, commands } = transactionData;
  const moveCallsToResolve = [];
  const moveFunctionsToResolve = /* @__PURE__ */ new Set();
  commands.forEach((command) => {
    if (command.MoveCall) {
      if (command.MoveCall._argumentTypes) {
        return;
      }
      const inputs2 = command.MoveCall.arguments.map((arg) => {
        if (arg.$kind === "Input") {
          return transactionData.inputs[arg.Input];
        }
        return null;
      });
      const needsResolution = inputs2.some(
        (input) => input?.UnresolvedPure || input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== "boolean"
      );
      if (needsResolution) {
        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;
        moveFunctionsToResolve.add(functionName);
        moveCallsToResolve.push(command.MoveCall);
      }
    }
  });
  const moveFunctionParameters = /* @__PURE__ */ new Map();
  if (moveFunctionsToResolve.size > 0) {
    await Promise.all(
      [...moveFunctionsToResolve].map(async (functionName) => {
        const [packageId, moduleId, functionId] = functionName.split("::");
        const def = await client.getNormalizedMoveFunction({
          package: packageId,
          module: moduleId,
          function: functionId
        });
        moveFunctionParameters.set(
          functionName,
          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))
        );
      })
    );
  }
  if (moveCallsToResolve.length) {
    await Promise.all(
      moveCallsToResolve.map(async (moveCall) => {
        const parameters = moveFunctionParameters.get(
          `${moveCall.package}::${moveCall.module}::${moveCall.function}`
        );
        if (!parameters) {
          return;
        }
        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));
        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;
        moveCall._argumentTypes = params;
      })
    );
  }
  commands.forEach((command) => {
    if (!command.MoveCall) {
      return;
    }
    const moveCall = command.MoveCall;
    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;
    const params = moveCall._argumentTypes;
    if (!params) {
      return;
    }
    if (params.length !== command.MoveCall.arguments.length) {
      throw new Error(`Incorrect number of arguments for ${fnName}`);
    }
    params.forEach((param, i) => {
      const arg = moveCall.arguments[i];
      if (arg.$kind !== "Input") return;
      const input = inputs[arg.Input];
      if (!input.UnresolvedPure && !input.UnresolvedObject) {
        return;
      }
      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;
      const schema = getPureBcsSchema(param.body);
      if (schema) {
        arg.type = "pure";
        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));
        return;
      }
      if (typeof inputValue !== "string") {
        throw new Error(
          `Expect the argument to be an object id string, got ${JSON.stringify(
            inputValue,
            null,
            2
          )}`
        );
      }
      arg.type = "object";
      const unresolvedObject = input.UnresolvedPure ? {
        $kind: "UnresolvedObject",
        UnresolvedObject: {
          objectId: inputValue
        }
      } : input;
      inputs[arg.Input] = unresolvedObject;
    });
  });
}
function isUsedAsMutable(transactionData, index) {
  let usedAsMutable = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== "&" || usedAsMutable;
    }
    if (tx.$kind === "MakeMoveVec" || tx.$kind === "MergeCoins" || tx.$kind === "SplitCoins" || tx.$kind === "TransferObjects") {
      usedAsMutable = true;
    }
  });
  return usedAsMutable;
}
function isUsedAsReceiving(transactionData, index) {
  let usedAsReceiving = false;
  transactionData.getInputUses(index, (arg, tx) => {
    if (tx.MoveCall && tx.MoveCall._argumentTypes) {
      const argIndex = tx.MoveCall.arguments.indexOf(arg);
      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;
    }
  });
  return usedAsReceiving;
}
function isReceivingType(type) {
  if (typeof type.body !== "object" || !("datatype" in type.body)) {
    return false;
  }
  return type.body.datatype.package === "0x2" && type.body.datatype.module === "transfer" && type.body.datatype.type === "Receiving";
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/resolve.js
function needsTransactionResolution(data, options) {
  if (data.inputs.some((input) => {
    return input.UnresolvedObject || input.UnresolvedPure;
  })) {
    return true;
  }
  if (!options.onlyTransactionKind) {
    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {
      return true;
    }
  }
  return false;
}
async function resolveTransactionPlugin(transactionData, options, next) {
  normalizeRawArguments(transactionData);
  if (!needsTransactionResolution(transactionData, options)) {
    await validate(transactionData);
    return next();
  }
  const client = getClient(options);
  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);
  return plugin(transactionData, options, async () => {
    await validate(transactionData);
    await next();
  });
}
function validate(transactionData) {
  transactionData.inputs.forEach((input, index) => {
    if (input.$kind !== "Object" && input.$kind !== "Pure") {
      throw new Error(
        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          input
        )}`
      );
    }
  });
}
function getClient(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}
function normalizeRawArguments(transactionData) {
  for (const command of transactionData.commands) {
    switch (command.$kind) {
      case "SplitCoins":
        command.SplitCoins.amounts.forEach((amount) => {
          normalizeRawArgument(amount, suiBcs.U64, transactionData);
        });
        break;
      case "TransferObjects":
        normalizeRawArgument(command.TransferObjects.address, suiBcs.Address, transactionData);
        break;
    }
  }
}
function normalizeRawArgument(arg, schema, transactionData) {
  if (arg.$kind !== "Input") {
    return;
  }
  const input = transactionData.inputs[arg.Input];
  if (input.$kind !== "UnresolvedPure") {
    return;
  }
  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/object.js
function createObjectMethods(makeObject) {
  function object2(value) {
    return makeObject(value);
  }
  object2.system = (options) => {
    const mutable = options?.mutable;
    if (mutable !== void 0) {
      return object2(
        Inputs.SharedObjectRef({
          objectId: "0x5",
          initialSharedVersion: 1,
          mutable
        })
      );
    }
    return object2({
      $kind: "UnresolvedObject",
      UnresolvedObject: {
        objectId: "0x5",
        initialSharedVersion: 1
      }
    });
  };
  object2.clock = () => object2(
    Inputs.SharedObjectRef({
      objectId: "0x6",
      initialSharedVersion: 1,
      mutable: false
    })
  );
  object2.random = () => object2({
    $kind: "UnresolvedObject",
    UnresolvedObject: {
      objectId: "0x8",
      mutable: false
    }
  });
  object2.denyList = (options) => {
    return object2({
      $kind: "UnresolvedObject",
      UnresolvedObject: {
        objectId: "0x403",
        mutable: options?.mutable
      }
    });
  };
  object2.option = ({ type, value }) => (tx) => tx.moveCall({
    typeArguments: [type],
    target: `0x1::option::${value === null ? "none" : "some"}`,
    arguments: value === null ? [] : [tx.object(value)]
  });
  return object2;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/pure.js
function createPure(makePure) {
  function pure(typeOrSerializedValue, value) {
    if (typeof typeOrSerializedValue === "string") {
      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));
    }
    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {
      return makePure(typeOrSerializedValue);
    }
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  pure.u8 = (value) => makePure(suiBcs.U8.serialize(value));
  pure.u16 = (value) => makePure(suiBcs.U16.serialize(value));
  pure.u32 = (value) => makePure(suiBcs.U32.serialize(value));
  pure.u64 = (value) => makePure(suiBcs.U64.serialize(value));
  pure.u128 = (value) => makePure(suiBcs.U128.serialize(value));
  pure.u256 = (value) => makePure(suiBcs.U256.serialize(value));
  pure.bool = (value) => makePure(suiBcs.Bool.serialize(value));
  pure.string = (value) => makePure(suiBcs.String.serialize(value));
  pure.address = (value) => makePure(suiBcs.Address.serialize(value));
  pure.id = pure.address;
  pure.vector = (type, value) => {
    return makePure(
      suiBcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value)
    );
  };
  pure.option = (type, value) => {
    return makePure(suiBcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));
  };
  return pure;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/utils.js
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if (arg.Object) {
    if (arg.Object.ImmOrOwnedObject) {
      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);
    }
    if (arg.Object.Receiving) {
      return normalizeSuiAddress(arg.Object.Receiving.objectId);
    }
    return normalizeSuiAddress(arg.Object.SharedObject.objectId);
  }
  if (arg.UnresolvedObject) {
    return normalizeSuiAddress(arg.UnresolvedObject.objectId);
  }
  return void 0;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/plugins/NamedPackagesPlugin.js
var cacheMap = /* @__PURE__ */ new WeakMap();
var namedPackagesPlugin = (options) => {
  let mvrClient;
  if (options) {
    const overrides = options.overrides ?? {
      packages: {},
      types: {}
    };
    if (!cacheMap.has(overrides)) {
      cacheMap.set(overrides, new ClientCache());
    }
    mvrClient = new MvrClient({
      cache: cacheMap.get(overrides),
      url: options.url,
      pageSize: options.pageSize,
      overrides
    });
  }
  return async (transactionData, buildOptions, next) => {
    const names = findNamesInTransaction(transactionData);
    if (names.types.length === 0 && names.packages.length === 0) {
      return next();
    }
    const resolved = await (mvrClient || getClient2(buildOptions).core.mvr).resolve({
      types: names.types,
      packages: names.packages
    });
    replaceNames(transactionData, resolved);
    await next();
  };
};
function getClient2(options) {
  if (!options.client) {
    throw new Error(
      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return options.client;
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/Transaction.js
var __typeError11 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck11 = (obj, member, msg) => member.has(obj) || __typeError11("Cannot " + msg);
var __privateGet11 = (obj, member, getter) => (__accessCheck11(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd11 = (obj, member, value) => member.has(obj) ? __typeError11("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet11 = (obj, member, value, setter) => (__accessCheck11(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod6 = (obj, member, method) => (__accessCheck11(obj, member, "access private method"), method);
var _serializationPlugins;
var _buildPlugins;
var _intentResolvers;
var _inputSection;
var _commandSection;
var _availableResults;
var _pendingPromises;
var _added;
var _data2;
var _Transaction_instances;
var fork_fn;
var addCommand_fn;
var addInput_fn;
var normalizeTransactionArgument_fn;
var resolveArgument_fn;
var prepareBuild_fn;
var runPlugins_fn;
var waitForPendingTasks_fn;
var sortCommandsAndInputs_fn;
function createTransactionResult(index, length = Infinity) {
  const baseResult = {
    $kind: "Result",
    get Result() {
      return typeof index === "function" ? index() : index;
    }
  };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    $kind: "NestedResult",
    get NestedResult() {
      return [typeof index === "function" ? index() : index, resultIndex];
    }
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i = 0;
          while (i < length) {
            yield nestedResultFor(i);
            i++;
          }
        };
      }
      if (typeof property === "symbol") return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0) return;
      return nestedResultFor(resultIndex);
    }
  });
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
function isTransaction(obj) {
  return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
}
var modulePluginRegistry = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
};
var TRANSACTION_REGISTRY_KEY = Symbol.for("@mysten/transaction/registry");
function getGlobalPluginRegistry() {
  try {
    const target = globalThis;
    if (!target[TRANSACTION_REGISTRY_KEY]) {
      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;
    }
    return target[TRANSACTION_REGISTRY_KEY];
  } catch {
    return modulePluginRegistry;
  }
}
var _Transaction = class _Transaction2 {
  constructor() {
    __privateAdd11(this, _Transaction_instances);
    __privateAdd11(this, _serializationPlugins);
    __privateAdd11(this, _buildPlugins);
    __privateAdd11(this, _intentResolvers, /* @__PURE__ */ new Map());
    __privateAdd11(this, _inputSection, []);
    __privateAdd11(this, _commandSection, []);
    __privateAdd11(this, _availableResults, /* @__PURE__ */ new Set());
    __privateAdd11(this, _pendingPromises, /* @__PURE__ */ new Set());
    __privateAdd11(this, _added, /* @__PURE__ */ new Map());
    __privateAdd11(this, _data2);
    this.object = createObjectMethods(
      (value) => {
        if (typeof value === "function") {
          return this.object(this.add(value));
        }
        if (typeof value === "object" && is(ArgumentSchema, value)) {
          return value;
        }
        const id = getIdFromCallArg(value);
        const inserted = __privateGet11(this, _data2).inputs.find((i) => id === getIdFromCallArg(i));
        if (inserted?.Object?.SharedObject && typeof value === "object" && value.Object?.SharedObject) {
          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;
        }
        return inserted ? { $kind: "Input", Input: __privateGet11(this, _data2).inputs.indexOf(inserted), type: "object" } : __privateMethod6(this, _Transaction_instances, addInput_fn).call(this, "object", typeof value === "string" ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: { objectId: normalizeSuiAddress(value) }
        } : value);
      }
    );
    const globalPlugins = getGlobalPluginRegistry();
    __privateSet11(this, _data2, new TransactionDataBuilder());
    __privateSet11(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);
    __privateSet11(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _Transaction2();
    __privateSet11(tx, _data2, TransactionDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromBase64(serialized) : serialized
    ));
    __privateSet11(tx, _inputSection, __privateGet11(tx, _data2).inputs.slice());
    __privateSet11(tx, _commandSection, __privateGet11(tx, _data2).commands.slice());
    __privateSet11(tx, _availableResults, new Set(__privateGet11(tx, _commandSection).map((_, i) => i)));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(transaction) {
    const newTransaction = new _Transaction2();
    if (isTransaction(transaction)) {
      __privateSet11(newTransaction, _data2, TransactionDataBuilder.restore(
        transaction.getData()
      ));
    } else if (typeof transaction !== "string" || !transaction.startsWith("{")) {
      __privateSet11(newTransaction, _data2, TransactionDataBuilder.fromBytes(
        typeof transaction === "string" ? fromBase64(transaction) : transaction
      ));
    } else {
      __privateSet11(newTransaction, _data2, TransactionDataBuilder.restore(JSON.parse(transaction)));
    }
    __privateSet11(newTransaction, _inputSection, __privateGet11(newTransaction, _data2).inputs.slice());
    __privateSet11(newTransaction, _commandSection, __privateGet11(newTransaction, _data2).commands.slice());
    __privateSet11(newTransaction, _availableResults, new Set(__privateGet11(newTransaction, _commandSection).map((_, i) => i)));
    return newTransaction;
  }
  static registerGlobalSerializationPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().serializationPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalSerializationPlugin(name) {
    getGlobalPluginRegistry().serializationPlugins.delete(name);
  }
  static registerGlobalBuildPlugin(stepOrStep, step) {
    getGlobalPluginRegistry().buildPlugins.set(
      stepOrStep,
      step ?? stepOrStep
    );
  }
  static unregisterGlobalBuildPlugin(name) {
    getGlobalPluginRegistry().buildPlugins.delete(name);
  }
  addSerializationPlugin(step) {
    __privateGet11(this, _serializationPlugins).push(step);
  }
  addBuildPlugin(step) {
    __privateGet11(this, _buildPlugins).push(step);
  }
  addIntentResolver(intent, resolver) {
    if (__privateGet11(this, _intentResolvers).has(intent) && __privateGet11(this, _intentResolvers).get(intent) !== resolver) {
      throw new Error(`Intent resolver for ${intent} already exists`);
    }
    __privateGet11(this, _intentResolvers).set(intent, resolver);
  }
  setSender(sender) {
    __privateGet11(this, _data2).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet11(this, _data2).sender) {
      __privateGet11(this, _data2).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet11(this, _data2).expiration = expiration ? parse(TransactionExpiration2, expiration) : null;
  }
  setGasPrice(price) {
    __privateGet11(this, _data2).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet11(this, _data2).gasConfig.budget = String(budget);
  }
  setGasBudgetIfNotSet(budget) {
    if (__privateGet11(this, _data2).gasData.budget == null) {
      __privateGet11(this, _data2).gasConfig.budget = String(budget);
    }
  }
  setGasOwner(owner) {
    __privateGet11(this, _data2).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    __privateGet11(this, _data2).gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return serializeV1TransactionData(__privateGet11(this, _data2).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return __privateGet11(this, _data2).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    Object.defineProperty(this, "pure", {
      enumerable: false,
      value: createPure((value) => {
        if (isSerializedBcs(value)) {
          return __privateMethod6(this, _Transaction_instances, addInput_fn).call(this, "pure", {
            $kind: "Pure",
            Pure: {
              bytes: value.toBase64()
            }
          });
        }
        return __privateMethod6(this, _Transaction_instances, addInput_fn).call(this, "pure", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: "UnresolvedPure", UnresolvedPure: { value } });
      })
    });
    return this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: true };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...args) {
    return this.object(Inputs.ReceivingRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  add(command) {
    if (typeof command === "function") {
      if (__privateGet11(this, _added).has(command)) {
        return __privateGet11(this, _added).get(command);
      }
      const fork = __privateMethod6(this, _Transaction_instances, fork_fn).call(this);
      const result = command(fork);
      if (!(result && typeof result === "object" && "then" in result)) {
        __privateSet11(this, _availableResults, __privateGet11(fork, _availableResults));
        __privateGet11(this, _added).set(command, result);
        return result;
      }
      const placeholder = __privateMethod6(this, _Transaction_instances, addCommand_fn).call(this, {
        $kind: "$Intent",
        $Intent: {
          name: "AsyncTransactionThunk",
          inputs: {},
          data: {
            resultIndex: __privateGet11(this, _data2).commands.length,
            result: null
          }
        }
      });
      __privateGet11(this, _pendingPromises).add(
        Promise.resolve(result).then((result2) => {
          placeholder.$Intent.data.result = result2;
        })
      );
      const txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);
      __privateGet11(this, _added).set(command, txResult);
      return txResult;
    } else {
      __privateMethod6(this, _Transaction_instances, addCommand_fn).call(this, command);
    }
    return createTransactionResult(__privateGet11(this, _data2).commands.length - 1);
  }
  // Method shorthands:
  splitCoins(coin, amounts) {
    const command = Commands.SplitCoins(
      typeof coin === "string" ? this.object(coin) : __privateMethod6(this, _Transaction_instances, resolveArgument_fn).call(this, coin),
      amounts.map(
        (amount) => typeof amount === "number" || typeof amount === "bigint" || typeof amount === "string" ? this.pure.u64(amount) : __privateMethod6(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)
      )
    );
    __privateMethod6(this, _Transaction_instances, addCommand_fn).call(this, command);
    return createTransactionResult(__privateGet11(this, _data2).commands.length - 1, amounts.length);
  }
  mergeCoins(destination, sources) {
    return this.add(
      Commands.MergeCoins(
        this.object(destination),
        sources.map((src) => this.object(src))
      )
    );
  }
  publish({ modules, dependencies }) {
    return this.add(
      Commands.Publish({
        modules,
        dependencies
      })
    );
  }
  upgrade({
    modules,
    dependencies,
    package: packageId,
    ticket
  }) {
    return this.add(
      Commands.Upgrade({
        modules,
        dependencies,
        package: packageId,
        ticket: this.object(ticket)
      })
    );
  }
  moveCall({
    arguments: args,
    ...input
  }) {
    return this.add(
      Commands.MoveCall({
        ...input,
        arguments: args?.map((arg) => __privateMethod6(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))
      })
    );
  }
  transferObjects(objects, address) {
    return this.add(
      Commands.TransferObjects(
        objects.map((obj) => this.object(obj)),
        typeof address === "string" ? this.pure.address(address) : __privateMethod6(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)
      )
    );
  }
  makeMoveVec({
    type,
    elements
  }) {
    return this.add(
      Commands.MakeMoveVec({
        type,
        elements: elements.map((obj) => this.object(obj))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(serializeV1TransactionData(__privateGet11(this, _data2).snapshot()));
  }
  async toJSON(options = {}) {
    await this.prepareForSerialization(options);
    const fullyResolved = this.isFullyResolved();
    return JSON.stringify(
      parse(
        SerializedTransactionDataV2Schema,
        fullyResolved ? {
          ...__privateGet11(this, _data2).snapshot(),
          digest: __privateGet11(this, _data2).getDigest()
        } : __privateGet11(this, _data2).snapshot()
      ),
      (_key, value) => typeof value === "bigint" ? value.toString() : value,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(options) {
    const { signer, ...buildOptions } = options;
    const bytes = await this.build(buildOptions);
    return signer.signTransaction(bytes);
  }
  /**
   *  Ensures that:
   *  - All objects have been fully resolved to a specific version
   *  - All pure inputs have been serialized to bytes
   *  - All async thunks have been fully resolved
   *  - All transaction intents have been resolved
   * 	- The gas payment, budget, and price have been set
   *  - The transaction sender has been set
   *
   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)
   */
  isFullyResolved() {
    if (!__privateGet11(this, _data2).sender) {
      return false;
    }
    if (__privateGet11(this, _pendingPromises).size > 0) {
      return false;
    }
    if (__privateGet11(this, _data2).commands.some((cmd) => cmd.$Intent)) {
      return false;
    }
    if (needsTransactionResolution(__privateGet11(this, _data2), {})) {
      return false;
    }
    return true;
  }
  /** Build the transaction to BCS bytes. */
  async build(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod6(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet11(this, _data2).build({
      onlyTransactionKind: options.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(options = {}) {
    await this.prepareForSerialization(options);
    await __privateMethod6(this, _Transaction_instances, prepareBuild_fn).call(this, options);
    return __privateGet11(this, _data2).getDigest();
  }
  async prepareForSerialization(options) {
    await __privateMethod6(this, _Transaction_instances, waitForPendingTasks_fn).call(this);
    __privateMethod6(this, _Transaction_instances, sortCommandsAndInputs_fn).call(this);
    const intents = /* @__PURE__ */ new Set();
    for (const command of __privateGet11(this, _data2).commands) {
      if (command.$Intent) {
        intents.add(command.$Intent.name);
      }
    }
    const steps = [...__privateGet11(this, _serializationPlugins)];
    for (const intent of intents) {
      if (options.supportedIntents?.includes(intent)) {
        continue;
      }
      if (!__privateGet11(this, _intentResolvers).has(intent)) {
        throw new Error(`Missing intent resolver for ${intent}`);
      }
      steps.push(__privateGet11(this, _intentResolvers).get(intent));
    }
    steps.push(namedPackagesPlugin());
    await __privateMethod6(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);
  }
};
_serializationPlugins = /* @__PURE__ */ new WeakMap();
_buildPlugins = /* @__PURE__ */ new WeakMap();
_intentResolvers = /* @__PURE__ */ new WeakMap();
_inputSection = /* @__PURE__ */ new WeakMap();
_commandSection = /* @__PURE__ */ new WeakMap();
_availableResults = /* @__PURE__ */ new WeakMap();
_pendingPromises = /* @__PURE__ */ new WeakMap();
_added = /* @__PURE__ */ new WeakMap();
_data2 = /* @__PURE__ */ new WeakMap();
_Transaction_instances = /* @__PURE__ */ new WeakSet();
fork_fn = function() {
  const fork = new _Transaction();
  __privateSet11(fork, _data2, __privateGet11(this, _data2));
  __privateSet11(fork, _serializationPlugins, __privateGet11(this, _serializationPlugins));
  __privateSet11(fork, _buildPlugins, __privateGet11(this, _buildPlugins));
  __privateSet11(fork, _intentResolvers, __privateGet11(this, _intentResolvers));
  __privateSet11(fork, _pendingPromises, __privateGet11(this, _pendingPromises));
  __privateSet11(fork, _availableResults, new Set(__privateGet11(this, _availableResults)));
  __privateSet11(fork, _added, __privateGet11(this, _added));
  __privateGet11(this, _inputSection).push(__privateGet11(fork, _inputSection));
  __privateGet11(this, _commandSection).push(__privateGet11(fork, _commandSection));
  return fork;
};
addCommand_fn = function(command) {
  const resultIndex = __privateGet11(this, _data2).commands.length;
  __privateGet11(this, _commandSection).push(command);
  __privateGet11(this, _availableResults).add(resultIndex);
  __privateGet11(this, _data2).commands.push(command);
  __privateGet11(this, _data2).mapCommandArguments(resultIndex, (arg) => {
    if (arg.$kind === "Result" && !__privateGet11(this, _availableResults).has(arg.Result)) {
      throw new Error(
        `Result { Result: ${arg.Result} } is not available to use the current transaction`
      );
    }
    if (arg.$kind === "NestedResult" && !__privateGet11(this, _availableResults).has(arg.NestedResult[0])) {
      throw new Error(
        `Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use the current transaction`
      );
    }
    if (arg.$kind === "Input" && arg.Input >= __privateGet11(this, _data2).inputs.length) {
      throw new Error(
        `Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`
      );
    }
    return arg;
  });
  return command;
};
addInput_fn = function(type, input) {
  __privateGet11(this, _inputSection).push(input);
  return __privateGet11(this, _data2).addInput(type, input);
};
normalizeTransactionArgument_fn = function(arg) {
  if (isSerializedBcs(arg)) {
    return this.pure(arg);
  }
  return __privateMethod6(this, _Transaction_instances, resolveArgument_fn).call(this, arg);
};
resolveArgument_fn = function(arg) {
  if (typeof arg === "function") {
    const resolved = this.add(arg);
    if (typeof resolved === "function") {
      return __privateMethod6(this, _Transaction_instances, resolveArgument_fn).call(this, resolved);
    }
    return parse(ArgumentSchema, resolved);
  }
  return parse(ArgumentSchema, arg);
};
prepareBuild_fn = async function(options) {
  if (!options.onlyTransactionKind && !__privateGet11(this, _data2).sender) {
    throw new Error("Missing transaction sender");
  }
  await __privateMethod6(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet11(this, _buildPlugins), resolveTransactionPlugin], options);
};
runPlugins_fn = async function(plugins, options) {
  try {
    const createNext = (i) => {
      if (i >= plugins.length) {
        return () => {
        };
      }
      const plugin = plugins[i];
      return async () => {
        const next = createNext(i + 1);
        let calledNext = false;
        let nextResolved = false;
        await plugin(__privateGet11(this, _data2), options, async () => {
          if (calledNext) {
            throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);
          }
          calledNext = true;
          await next();
          nextResolved = true;
        });
        if (!calledNext) {
          throw new Error(`next() was not called in TransactionPlugin ${i}`);
        }
        if (!nextResolved) {
          throw new Error(`next() was not awaited in TransactionPlugin ${i}`);
        }
      };
    };
    await createNext(0)();
  } finally {
    __privateSet11(this, _inputSection, __privateGet11(this, _data2).inputs.slice());
    __privateSet11(this, _commandSection, __privateGet11(this, _data2).commands.slice());
  }
};
waitForPendingTasks_fn = async function() {
  while (__privateGet11(this, _pendingPromises).size > 0) {
    const newPromise = Promise.all(__privateGet11(this, _pendingPromises));
    __privateGet11(this, _pendingPromises).clear();
    __privateGet11(this, _pendingPromises).add(newPromise);
    await newPromise;
    __privateGet11(this, _pendingPromises).delete(newPromise);
  }
};
sortCommandsAndInputs_fn = function() {
  const unorderedCommands = __privateGet11(this, _data2).commands;
  const unorderedInputs = __privateGet11(this, _data2).inputs;
  const orderedCommands = __privateGet11(this, _commandSection).flat(Infinity);
  const orderedInputs = __privateGet11(this, _inputSection).flat(Infinity);
  if (orderedCommands.length !== unorderedCommands.length) {
    throw new Error("Unexpected number of commands found in transaction data");
  }
  if (orderedInputs.length !== unorderedInputs.length) {
    throw new Error("Unexpected number of inputs found in transaction data");
  }
  const filteredCommands = orderedCommands.filter(
    (cmd) => cmd.$Intent?.name !== "AsyncTransactionThunk"
  );
  __privateGet11(this, _data2).commands = filteredCommands;
  __privateGet11(this, _data2).inputs = orderedInputs;
  __privateSet11(this, _commandSection, filteredCommands);
  __privateSet11(this, _inputSection, orderedInputs);
  __privateSet11(this, _availableResults, new Set(filteredCommands.map((_, i) => i)));
  function getOriginalIndex(index) {
    const command = unorderedCommands[index];
    if (command.$Intent?.name === "AsyncTransactionThunk") {
      const result = command.$Intent.data.result;
      if (result == null) {
        throw new Error("AsyncTransactionThunk has not been resolved");
      }
      return getOriginalIndex(result.Result);
    }
    const updated = filteredCommands.indexOf(command);
    if (updated === -1) {
      throw new Error("Unable to find original index for command");
    }
    return updated;
  }
  __privateGet11(this, _data2).mapArguments((arg) => {
    if (arg.$kind === "Input") {
      const updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);
      if (updated === -1) {
        throw new Error("Input has not been resolved");
      }
      return { ...arg, Input: updated };
    } else if (arg.$kind === "Result") {
      const updated = getOriginalIndex(arg.Result);
      return { ...arg, Result: updated };
    } else if (arg.$kind === "NestedResult") {
      const updated = getOriginalIndex(arg.NestedResult[0]);
      return { ...arg, NestedResult: [updated, arg.NestedResult[1]] };
    }
    return arg;
  });
  for (const [i, cmd] of unorderedCommands.entries()) {
    if (cmd.$Intent?.name === "AsyncTransactionThunk") {
      try {
        cmd.$Intent.data.resultIndex = getOriginalIndex(i);
      } catch {
      }
    }
  }
};
var Transaction = _Transaction;

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var _caches;
var _cache3;
var _onEffects;
_caches = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_onEffects = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var _client2;
var _lastDigest;
_client2 = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var _queue;
var _queue2;
_queue = /* @__PURE__ */ new WeakMap();
_queue2 = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var _queue3;
var _signer;
var _cache4;
var _defaultGasBudget;
var _cacheGasCoin;
var _buildTransaction;
_queue3 = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_cache4 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
  if (!effects.V2) {
    throw new Error("Unexpected effects version");
  }
  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
  if (!gasObjectChange) {
    throw new Error("Gas object not found in effects");
  }
  const [objectId, { outputState }] = gasObjectChange;
  if (!outputState.ObjectWrite) {
    throw new Error("Unexpected gas object state");
  }
  const [digest, owner] = outputState.ObjectWrite;
  return {
    ref: {
      objectId,
      digest,
      version: effects.V2.lamportVersion
    },
    owner: owner.AddressOwner || owner.ObjectOwner
  };
}

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError12 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck12 = (obj, member, msg) => member.has(obj) || __typeError12("Cannot " + msg);
var __privateGet12 = (obj, member, getter) => (__accessCheck12(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet12 = (obj, member, value, setter) => (__accessCheck12(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod7 = (obj, member, method) => (__accessCheck12(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet12(obj, member, value, setter);
  },
  get _() {
    return __privateGet12(obj, member, getter);
  }
});
var _signer2;
var _client3;
var _coinBatchSize;
var _initialCoinBalance;
var _minimumCoinBalance;
var _epochBoundaryWindow;
var _defaultGasBudget2;
var _maxPoolSize;
var _sourceCoins;
var _coinPool;
var _cache5;
var _objectIdQueues;
var _buildQueue;
var _executeQueue;
var _lastDigest2;
var _cacheLock;
var _pendingTransactions;
var _gasPrice;
var _ParallelTransactionExecutor_instances;
var getUsedObjects_fn;
var execute_fn;
var updateCache_fn;
var waitForLastDigest_fn;
var getGasCoin_fn;
var getGasPrice_fn;
var refillCoinPool_fn;
_signer2 = /* @__PURE__ */ new WeakMap();
_client3 = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget2 = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache5 = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest2 = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      if (input.Object?.ImmOrOwnedObject?.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if (input.Object?.Receiving?.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet12(this, _client3) });
  return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {
  let gasCoin;
  try {
    transaction.setSenderIfNotSet(__privateGet12(this, _signer2).toSuiAddress());
    await __privateGet12(this, _buildQueue).runTask(async () => {
      const data = transaction.getData();
      if (!data.gasData.price) {
        transaction.setGasPrice(await __privateMethod7(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
      }
      transaction.setGasBudgetIfNotSet(__privateGet12(this, _defaultGasBudget2));
      await __privateMethod7(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
      gasCoin = await __privateMethod7(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
      __privateWrapper(this, _pendingTransactions)._++;
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      await __privateGet12(this, _cache5).buildTransaction({ transaction, onlyTransactionKind: true });
    });
    const bytes = await transaction.build({ client: __privateGet12(this, _client3) });
    const { signature } = await __privateGet12(this, _signer2).signTransaction(bytes);
    const results = await __privateGet12(this, _cache5).executeTransaction({
      transaction: bytes,
      signature: [signature, ...additionalSignatures],
      options: {
        ...options,
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = suiBcs.TransactionEffects.parse(effectsBytes);
    const gasResult = getGasCoinFromEffects(effects);
    const gasUsed = effects.V2?.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet12(this, _signer2).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      const remainingBalance = gasCoin.balance - totalUsed;
      let usesGasCoin = false;
      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
        if (arg.$kind === "GasCoin") {
          usesGasCoin = true;
        }
        return arg;
      });
      if (!usesGasCoin && remainingBalance >= __privateGet12(this, _minimumCoinBalance)) {
        __privateGet12(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: remainingBalance
        });
      } else {
        if (!__privateGet12(this, _sourceCoins)) {
          __privateSet12(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet12(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    __privateSet12(this, _lastDigest2, results.digest);
    return {
      digest: results.digest,
      effects: toBase64(effectsBytes),
      data: results
    };
  } catch (error) {
    if (gasCoin) {
      if (!__privateGet12(this, _sourceCoins)) {
        __privateSet12(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet12(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateMethod7(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
      await Promise.all([
        __privateGet12(this, _cache5).cache.deleteObjects([...usedObjects]),
        __privateMethod7(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)
      ]);
    });
    throw error;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet12(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet12(this, _objectIdQueues).delete(objectId);
      }
    });
    __privateWrapper(this, _pendingTransactions)._--;
  }
};
updateCache_fn = async function(fn) {
  if (__privateGet12(this, _cacheLock)) {
    await __privateGet12(this, _cacheLock);
  }
  __privateSet12(this, _cacheLock, fn?.().then(
    () => {
      __privateSet12(this, _cacheLock, null);
    },
    () => {
    }
  ) ?? null);
};
waitForLastDigest_fn = async function() {
  const digest = __privateGet12(this, _lastDigest2);
  if (digest) {
    __privateSet12(this, _lastDigest2, null);
    await __privateGet12(this, _client3).waitForTransaction({ digest });
  }
};
getGasCoin_fn = async function() {
  if (__privateGet12(this, _coinPool).length === 0 && __privateGet12(this, _pendingTransactions) <= __privateGet12(this, _maxPoolSize)) {
    await __privateMethod7(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
  }
  if (__privateGet12(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet12(this, _coinPool).shift();
  return coin;
};
getGasPrice_fn = async function() {
  const remaining = __privateGet12(this, _gasPrice) ? __privateGet12(this, _gasPrice).expiration - __privateGet12(this, _epochBoundaryWindow) - Date.now() : 0;
  if (remaining > 0) {
    return __privateGet12(this, _gasPrice).price;
  }
  if (__privateGet12(this, _gasPrice)) {
    const timeToNextEpoch = Math.max(
      __privateGet12(this, _gasPrice).expiration + __privateGet12(this, _epochBoundaryWindow) - Date.now(),
      1e3
    );
    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
  }
  const state = await __privateGet12(this, _client3).getLatestSuiSystemState();
  __privateSet12(this, _gasPrice, {
    price: BigInt(state.referenceGasPrice),
    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
  });
  return __privateMethod7(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
  const batchSize = Math.min(
    __privateGet12(this, _coinBatchSize),
    __privateGet12(this, _maxPoolSize) - (__privateGet12(this, _coinPool).length + __privateGet12(this, _pendingTransactions)) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new Transaction();
  const address = __privateGet12(this, _signer2).toSuiAddress();
  txb.setSender(address);
  if (__privateGet12(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id, ref] of __privateGet12(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet12(this, _client3).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet12(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet12(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i = 0; i < amounts.length; i++) {
    coinResults.push(results[i]);
  }
  txb.transferObjects(coinResults, address);
  await this.waitForLastTransaction();
  const result = await __privateGet12(this, _client3).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet12(this, _signer2),
    options: {
      showRawEffects: true
    }
  });
  const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  effects.V2?.changedObjects.forEach(([id, { outputState }], i) => {
    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {
      return;
    }
    __privateGet12(this, _coinPool).push({
      id,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet12(this, _initialCoinBalance))
    });
  });
  if (!__privateGet12(this, _sourceCoins)) {
    __privateSet12(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = getGasCoinFromEffects(effects).ref;
  __privateGet12(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet12(this, _client3).waitForTransaction({ digest: result.digest });
};

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});

// node_modules/.pnpm/@mysten+sui@1.43.1_typescript@5.9.2/node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
  pure: createPure((value) => (tx) => tx.pure(value)),
  object: createObjectMethods((value) => (tx) => tx.object(value)),
  sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),
  objectRef: (...args) => (tx) => tx.objectRef(...args),
  receivingRef: (...args) => (tx) => tx.receivingRef(...args)
};

// node_modules/.pnpm/@mysten+wallet-standard@0.19.4_typescript@5.9.2/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignTransaction.js
var SuiSignTransaction = "sui:signTransaction";

// node_modules/.pnpm/@mysten+wallet-standard@0.19.4_typescript@5.9.2/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignAndExecuteTransaction.js
var SuiSignAndExecuteTransaction = "sui:signAndExecuteTransaction";

// node_modules/.pnpm/@mysten+wallet-standard@0.19.4_typescript@5.9.2/node_modules/@mysten/wallet-standard/dist/esm/features/suiSignPersonalMessage.js
var SuiSignPersonalMessage = "sui:signPersonalMessage";

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/features.js
var EnokiGetMetadata = "enoki:getMetadata";
var EnokiGetSession = "enoki:getSession";

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/state.js
var __typeError13 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck13 = (obj, member, msg) => member.has(obj) || __typeError13("Cannot " + msg);
var __privateGet13 = (obj, member, getter) => (__accessCheck13(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd12 = (obj, member, value) => member.has(obj) ? __typeError13("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet13 = (obj, member, value, setter) => (__accessCheck13(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod8 = (obj, member, method) => (__accessCheck13(obj, member, "access private method"), method);
var _encryption2;
var _encryptionKey2;
var _stateStore;
var _sessionContextByNetwork;
var _zkLoginState;
var _EnokiWalletState_instances;
var createZkLoginState_fn;
var sessionKey = "zklogin-session";
var stateKey = "zklogin-state";
var EnokiWalletState = class {
  constructor(config) {
    __privateAdd12(this, _EnokiWalletState_instances);
    __privateAdd12(this, _encryption2);
    __privateAdd12(this, _encryptionKey2);
    __privateAdd12(this, _stateStore);
    __privateAdd12(this, _sessionContextByNetwork);
    __privateAdd12(this, _zkLoginState);
    __privateSet13(this, _encryptionKey2, config.apiKey);
    __privateSet13(this, _encryption2, createDefaultEncryption());
    __privateSet13(this, _stateStore, createStore(`${config.apiKey}_${config.clientId}`, "enoki"));
    __privateSet13(this, _zkLoginState, __privateMethod8(this, _EnokiWalletState_instances, createZkLoginState_fn).call(this));
    __privateSet13(this, _sessionContextByNetwork, config.clients.reduce((accumulator, client) => {
      const network = client.network;
      const idbStore = createStore(`${config.apiKey}_${network}_${config.clientId}`, "enoki");
      const sessionContext = {
        $zkLoginSession: atom({ initialized: false, value: null }),
        client,
        idbStore
      };
      onMount(sessionContext.$zkLoginSession, () => {
        this.getSession(sessionContext);
      });
      return accumulator.set(network, sessionContext);
    }, /* @__PURE__ */ new Map()));
  }
  get zkLoginState() {
    return __privateGet13(this, _zkLoginState);
  }
  get sessionContextByNetwork() {
    return __privateGet13(this, _sessionContextByNetwork);
  }
  getSessionContext(network) {
    const context = __privateGet13(this, _sessionContextByNetwork).get(network);
    if (!context) {
      throw new Error(`The network ${network} isn't supported.`);
    }
    return context;
  }
  async logout() {
    __privateGet13(this, _zkLoginState).set(null);
    await clear(__privateGet13(this, _stateStore));
    for (const context of __privateGet13(this, _sessionContextByNetwork).values()) {
      await this.setSession(context, null);
      await clear(context.idbStore);
    }
  }
  async setSession(context, newValue) {
    if (newValue) {
      const storedValue = await __privateGet13(this, _encryption2).encrypt(
        __privateGet13(this, _encryptionKey2),
        JSON.stringify(newValue)
      );
      await set(sessionKey, storedValue, context.idbStore);
    } else {
      await del(sessionKey, context.idbStore);
    }
    context.$zkLoginSession.set({ initialized: true, value: newValue });
  }
  async getSession({ $zkLoginSession, idbStore }) {
    if ($zkLoginSession.get().initialized) {
      return $zkLoginSession.get().value;
    }
    try {
      const storedValue = await get(sessionKey, idbStore);
      if (!storedValue) return null;
      const state = JSON.parse(
        await __privateGet13(this, _encryption2).decrypt(__privateGet13(this, _encryptionKey2), storedValue)
      );
      if (state?.expiresAt && Date.now() > state.expiresAt) {
        await this.logout();
      } else {
        $zkLoginSession.set({ initialized: true, value: state });
      }
    } catch {
      $zkLoginSession.set({ initialized: true, value: null });
    }
    return $zkLoginSession.get().value;
  }
};
_encryption2 = /* @__PURE__ */ new WeakMap();
_encryptionKey2 = /* @__PURE__ */ new WeakMap();
_stateStore = /* @__PURE__ */ new WeakMap();
_sessionContextByNetwork = /* @__PURE__ */ new WeakMap();
_zkLoginState = /* @__PURE__ */ new WeakMap();
_EnokiWalletState_instances = /* @__PURE__ */ new WeakSet();
createZkLoginState_fn = function() {
  const $zkLoginState = atom(null);
  onMount($zkLoginState, () => {
    task(async () => {
      try {
        const rawStoredValue = await get(stateKey, __privateGet13(this, _stateStore));
        if (rawStoredValue) {
          $zkLoginState.set(JSON.parse(rawStoredValue));
        }
      } catch {
      }
    });
  });
  onSet($zkLoginState, ({ newValue }) => {
    set(stateKey, JSON.stringify(newValue), __privateGet13(this, _stateStore));
  });
  return $zkLoginState;
};

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/wallet.js
var __typeError14 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck14 = (obj, member, msg) => member.has(obj) || __typeError14("Cannot " + msg);
var __privateGet14 = (obj, member, getter) => (__accessCheck14(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd13 = (obj, member, value) => member.has(obj) ? __typeError14("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet14 = (obj, member, value, setter) => (__accessCheck14(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod9 = (obj, member, method) => (__accessCheck14(obj, member, "access private method"), method);
var _events;
var _accounts;
var _name;
var _icon;
var _enokiClient2;
var _state;
var _provider;
var _clientId;
var _redirectUrl;
var _extraParams;
var _getCurrentNetwork;
var _windowFeatures;
var _signTransaction;
var _signAndExecuteTransaction;
var _signPersonalMessage;
var _getMetadata;
var _getSession;
var _on;
var _connect;
var _disconnect;
var _EnokiWallet_instances;
var getAuthorizedAccounts_fn;
var getKeypair_fn;
var getSignerContext_fn;
var createSession_fn;
var getPKCEFlowContext_fn;
var createAuthorizationURL_fn;
var handleAuthCallback_fn;
var pkceTokenExchange_fn;
var pkceFlowProviders = {
  playtron: {
    tokenEndpoint: "https://oauth2.playtron.one/oauth2/token"
  }
};
var EnokiWallet = class {
  constructor({
    name,
    icon,
    provider,
    clientId,
    redirectUrl,
    extraParams,
    windowFeatures,
    getCurrentNetwork,
    apiKey,
    apiUrl,
    clients
  }) {
    __privateAdd13(this, _EnokiWallet_instances);
    __privateAdd13(this, _events);
    __privateAdd13(this, _accounts);
    __privateAdd13(this, _name);
    __privateAdd13(this, _icon);
    __privateAdd13(this, _enokiClient2);
    __privateAdd13(this, _state);
    __privateAdd13(this, _provider);
    __privateAdd13(this, _clientId);
    __privateAdd13(this, _redirectUrl);
    __privateAdd13(this, _extraParams);
    __privateAdd13(this, _getCurrentNetwork);
    __privateAdd13(this, _windowFeatures);
    __privateAdd13(this, _signTransaction, async ({ transaction, chain, account, signal }) => {
      signal?.throwIfAborted();
      const { client, keypair } = await __privateMethod9(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      return keypair.signTransaction(await parsedTransaction.build({ client }));
    });
    __privateAdd13(this, _signAndExecuteTransaction, async ({
      transaction,
      chain,
      account,
      signal
    }) => {
      signal?.throwIfAborted();
      const { client, keypair } = await __privateMethod9(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const parsedTransaction = Transaction.from(await transaction.toJSON());
      const bytes = await parsedTransaction.build({ client });
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      parsedTransaction.setSenderIfNotSet(suiAddress);
      const result = await keypair.signAndExecuteTransaction({
        transaction: parsedTransaction,
        client
      });
      return {
        bytes: toBase64(bytes),
        signature: result.signatures[0],
        digest: result.digest,
        effects: toBase64(result.effects.bcs)
      };
    });
    __privateAdd13(this, _signPersonalMessage, async ({ message, account, chain }) => {
      const { keypair } = await __privateMethod9(this, _EnokiWallet_instances, getSignerContext_fn).call(this, chain);
      const suiAddress = keypair.toSuiAddress();
      if (suiAddress !== account.address) {
        throw new Error(
          `The specified account ${account.address} does not match the currently connected Enoki address ${suiAddress}.`
        );
      }
      return keypair.signPersonalMessage(message);
    });
    __privateAdd13(this, _getMetadata, () => {
      return {
        provider: __privateGet14(this, _provider)
      };
    });
    __privateAdd13(this, _getSession, async (input) => {
      const sessionContext = __privateGet14(this, _state).getSessionContext(
        input?.network ?? __privateGet14(this, _getCurrentNetwork).call(this)
      );
      return await __privateGet14(this, _state).getSession(sessionContext);
    });
    __privateAdd13(this, _on, (event, listener) => {
      __privateGet14(this, _events).on(event, listener);
      return () => __privateGet14(this, _events).off(event, listener);
    });
    __privateAdd13(this, _connect, async (input) => {
      await allTasks();
      if (input?.silent || __privateGet14(this, _accounts).length > 0) {
        return { accounts: __privateGet14(this, _accounts) };
      }
      const currentNetwork = __privateGet14(this, _getCurrentNetwork).call(this);
      await __privateMethod9(this, _EnokiWallet_instances, createSession_fn).call(this, { network: currentNetwork });
      return { accounts: __privateGet14(this, _accounts) };
    });
    __privateAdd13(this, _disconnect, async () => {
      await __privateGet14(this, _state).logout();
      __privateSet14(this, _accounts, []);
      __privateGet14(this, _events).emit("change", { accounts: __privateGet14(this, _accounts) });
    });
    __privateSet14(this, _events, mitt_default());
    __privateSet14(this, _name, name);
    __privateSet14(this, _icon, icon);
    __privateSet14(this, _enokiClient2, new EnokiClient({ apiKey, apiUrl }));
    __privateSet14(this, _state, new EnokiWalletState({ apiKey, clientId, clients }));
    __privateSet14(this, _provider, provider);
    __privateSet14(this, _clientId, clientId);
    __privateSet14(this, _redirectUrl, redirectUrl || window.location.href.split("#")[0]);
    __privateSet14(this, _extraParams, extraParams);
    __privateSet14(this, _windowFeatures, windowFeatures);
    __privateSet14(this, _getCurrentNetwork, getCurrentNetwork);
    __privateSet14(this, _accounts, []);
    __privateGet14(this, _state).zkLoginState.subscribe(() => {
      __privateSet14(this, _accounts, __privateMethod9(this, _EnokiWallet_instances, getAuthorizedAccounts_fn).call(this));
      __privateGet14(this, _events).emit("change", { accounts: __privateGet14(this, _accounts) });
    });
  }
  get name() {
    return __privateGet14(this, _name);
  }
  get provider() {
    return __privateGet14(this, _provider);
  }
  get icon() {
    return __privateGet14(this, _icon);
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [...__privateGet14(this, _state).sessionContextByNetwork.keys()].map(
      (network) => `sui:${network}`
    );
  }
  get accounts() {
    return __privateGet14(this, _accounts);
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __privateGet14(this, _connect)
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __privateGet14(this, _disconnect)
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __privateGet14(this, _on)
      },
      [SuiSignTransaction]: {
        version: "2.0.0",
        signTransaction: __privateGet14(this, _signTransaction)
      },
      [SuiSignAndExecuteTransaction]: {
        version: "2.0.0",
        signAndExecuteTransaction: __privateGet14(this, _signAndExecuteTransaction)
      },
      [SuiSignPersonalMessage]: {
        version: "1.1.0",
        signPersonalMessage: __privateGet14(this, _signPersonalMessage)
      },
      [EnokiGetMetadata]: {
        version: "1.0.0",
        getMetadata: __privateGet14(this, _getMetadata)
      },
      [EnokiGetSession]: {
        version: "1.0.0",
        getSession: __privateGet14(this, _getSession)
      }
    };
  }
};
_events = /* @__PURE__ */ new WeakMap();
_accounts = /* @__PURE__ */ new WeakMap();
_name = /* @__PURE__ */ new WeakMap();
_icon = /* @__PURE__ */ new WeakMap();
_enokiClient2 = /* @__PURE__ */ new WeakMap();
_state = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_clientId = /* @__PURE__ */ new WeakMap();
_redirectUrl = /* @__PURE__ */ new WeakMap();
_extraParams = /* @__PURE__ */ new WeakMap();
_getCurrentNetwork = /* @__PURE__ */ new WeakMap();
_windowFeatures = /* @__PURE__ */ new WeakMap();
_signTransaction = /* @__PURE__ */ new WeakMap();
_signAndExecuteTransaction = /* @__PURE__ */ new WeakMap();
_signPersonalMessage = /* @__PURE__ */ new WeakMap();
_getMetadata = /* @__PURE__ */ new WeakMap();
_getSession = /* @__PURE__ */ new WeakMap();
_on = /* @__PURE__ */ new WeakMap();
_connect = /* @__PURE__ */ new WeakMap();
_disconnect = /* @__PURE__ */ new WeakMap();
_EnokiWallet_instances = /* @__PURE__ */ new WeakSet();
getAuthorizedAccounts_fn = function() {
  const zkLoginState = __privateGet14(this, _state).zkLoginState.get();
  if (zkLoginState) {
    return [
      new ReadonlyWalletAccount({
        address: zkLoginState.address,
        chains: this.chains,
        icon: this.icon,
        features: [SuiSignPersonalMessage, SuiSignTransaction, SuiSignAndExecuteTransaction],
        publicKey: fromBase64(zkLoginState.publicKey)
      })
    ];
  }
  return [];
};
getKeypair_fn = async function(sessionContext) {
  const session = await __privateGet14(this, _state).getSession(sessionContext);
  if (!session?.jwt || Date.now() > session.expiresAt) {
    await __privateMethod9(this, _EnokiWallet_instances, createSession_fn).call(this, { network: sessionContext.client.network });
  }
  const storedNativeSigner = await get(
    "ephemeralKeyPair",
    sessionContext.idbStore
  );
  if (!storedNativeSigner) {
    throw new Error("Native signer not found in store.");
  }
  const updatedSession = await __privateGet14(this, _state).getSession(sessionContext);
  if (!updatedSession?.jwt) {
    throw new Error("Failed to retrieve an active session.");
  }
  const ephemeralKeypair = WebCryptoSigner.import(storedNativeSigner);
  const proof = updatedSession.proof ?? await __privateGet14(this, _enokiClient2).createZkLoginZkp({
    network: sessionContext.client.network,
    jwt: updatedSession.jwt,
    maxEpoch: updatedSession.maxEpoch,
    randomness: updatedSession.randomness,
    ephemeralPublicKey: ephemeralKeypair.getPublicKey()
  });
  await __privateGet14(this, _state).setSession(sessionContext, { ...updatedSession, proof });
  return new EnokiKeypair({
    address: this.accounts[0].address,
    maxEpoch: updatedSession.maxEpoch,
    ephemeralKeypair,
    proof
  });
};
getSignerContext_fn = async function(chain) {
  const sessionContext = chain ? __privateGet14(this, _state).getSessionContext(chain.split(":")[1]) : null;
  if (!sessionContext) {
    throw new Error(
      `A valid Sui chain identifier was not provided in the request. Please report this issue to the dApp developer. Examples of valid Sui chain identifiers are 'sui:testnet' and 'sui:mainnet'. Consider using the '@mysten/dapp-kit' package, which provides this value automatically.`
    );
  }
  const keypair = await __privateMethod9(this, _EnokiWallet_instances, getKeypair_fn).call(this, sessionContext);
  return { client: sessionContext.client, keypair };
};
createSession_fn = async function({ network }) {
  const popup = window.open(
    void 0,
    "_blank",
    typeof __privateGet14(this, _windowFeatures) === "function" ? __privateGet14(this, _windowFeatures).call(this) : __privateGet14(this, _windowFeatures)
  );
  if (!popup) {
    throw new Error("Failed to open popup");
  }
  const sessionContext = __privateGet14(this, _state).getSessionContext(network);
  const pkceContext = await __privateMethod9(this, _EnokiWallet_instances, getPKCEFlowContext_fn).call(this);
  popup.location = await __privateMethod9(this, _EnokiWallet_instances, createAuthorizationURL_fn).call(this, sessionContext, pkceContext);
  return await new Promise((resolve, reject) => {
    const interval = setInterval(() => {
      try {
        if (popup.closed) {
          clearInterval(interval);
          reject(new Error("Popup closed"));
        }
        if (!pkceContext && !popup.location.hash || pkceContext && !popup.location.search) {
          return;
        }
      } catch {
        return;
      }
      clearInterval(interval);
      __privateMethod9(this, _EnokiWallet_instances, handleAuthCallback_fn).call(this, {
        hash: popup.location.hash,
        sessionContext,
        search: popup.location.search,
        pkceContext
      }).then(() => resolve(), reject);
      try {
        popup.close();
      } catch (e) {
        console.error(e);
      }
    }, 16);
  });
};
getPKCEFlowContext_fn = async function() {
  if (!pkceFlowProviders[__privateGet14(this, _provider)]) {
    return;
  }
  const array2 = new Uint8Array(64);
  crypto.getRandomValues(array2);
  const codeVerifier = toBase64(array2).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  const codeChallenge = toBase64(
    new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(codeVerifier)))
  ).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  return { codeVerifier, codeChallenge };
};
createAuthorizationURL_fn = async function(sessionContext, pkceContext) {
  const ephemeralKeyPair = await WebCryptoSigner.generate();
  const { nonce, randomness, maxEpoch, estimatedExpiration } = await __privateGet14(this, _enokiClient2).createZkLoginNonce({
    network: sessionContext.client.network,
    ephemeralPublicKey: ephemeralKeyPair.getPublicKey()
  });
  const extraParams = typeof __privateGet14(this, _extraParams) === "function" ? __privateGet14(this, _extraParams).call(this) : __privateGet14(this, _extraParams);
  const params = new URLSearchParams({
    ...extraParams,
    nonce,
    client_id: __privateGet14(this, _clientId),
    redirect_uri: __privateGet14(this, _redirectUrl),
    response_type: "id_token",
    scope: ["openid", ...extraParams?.scope ? extraParams.scope.split(" ") : []].filter(Boolean).join(" "),
    ...pkceContext ? {
      response_type: "code",
      code_challenge_method: "S256",
      code_challenge: pkceContext.codeChallenge
    } : void 0
  });
  let oauthUrl;
  switch (__privateGet14(this, _provider)) {
    case "google":
      oauthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
      break;
    case "facebook":
      oauthUrl = `https://www.facebook.com/v17.0/dialog/oauth?${params}`;
      break;
    case "twitch":
      params.set("force_verify", "true");
      oauthUrl = `https://id.twitch.tv/oauth2/authorize?${params}`;
      break;
    case "onefc":
      oauthUrl = `https://login.onepassport.onefc.com/de3ee5c1-5644-4113-922d-e8336569a462/b2c_1a_prod_signupsignin_onesuizklogin/oauth2/v2.0/authorize?${params}`;
      break;
    case "playtron":
      oauthUrl = `https://oauth2.playtron.one/oauth2/auth?${params}`;
      break;
    default:
      throw new Error(`Invalid provider: ${__privateGet14(this, _provider)}`);
  }
  await set("ephemeralKeyPair", ephemeralKeyPair.export(), sessionContext.idbStore);
  await __privateGet14(this, _state).setSession(sessionContext, {
    expiresAt: estimatedExpiration,
    maxEpoch,
    randomness
  });
  return oauthUrl;
};
handleAuthCallback_fn = async function({
  hash,
  sessionContext,
  pkceContext,
  search
}) {
  const params = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
  const zkp = await __privateGet14(this, _state).getSession(sessionContext);
  if (!zkp?.maxEpoch || !zkp.randomness) {
    throw new Error(
      "Start of sign-in flow could not be found. Ensure you have started the sign-in flow before calling this."
    );
  }
  const jwt = pkceContext ? await __privateMethod9(this, _EnokiWallet_instances, pkceTokenExchange_fn).call(this, search, pkceContext) : params.get("id_token");
  if (!jwt) {
    throw new Error("Missing ID Token");
  }
  decodeJwt(jwt);
  const { address, publicKey } = await __privateGet14(this, _enokiClient2).getZkLogin({ jwt });
  __privateGet14(this, _state).zkLoginState.set({ address, publicKey });
  await __privateGet14(this, _state).setSession(sessionContext, { ...zkp, jwt });
  return params.get("state");
};
pkceTokenExchange_fn = async function(search, pkceContext) {
  const params = new URLSearchParams(search);
  const code = params.get("code");
  if (!code) {
    throw new Error("Missing code");
  }
  const tokenEndpoint = pkceFlowProviders[__privateGet14(this, _provider)]?.tokenEndpoint;
  if (!tokenEndpoint) {
    throw new Error(`PKCE flow not supported for provider: ${__privateGet14(this, _provider)}`);
  }
  const response = await fetch(tokenEndpoint, {
    method: "POST",
    body: new URLSearchParams({
      grant_type: "authorization_code",
      client_id: __privateGet14(this, _clientId),
      redirect_uri: __privateGet14(this, _redirectUrl),
      code,
      code_verifier: pkceContext.codeVerifier
    })
  });
  return (await response.json()).id_token;
};

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/utils.js
function isEnokiNetwork(network) {
  return network === "mainnet" || network === "testnet" || network === "devnet";
}

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/providers.js
var ENOKI_PROVIDER_WALLETS_INFO = [
  {
    provider: "google",
    name: "Sign in with Google",
    icon: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzIgMGgtMzJ2MzJoMzJ6IiBmaWxsPSIjZmZmIi8+PGcgY2xpcC1ydWxlPSJldmVub2RkIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Im0yMy44Mjk5IDE2LjE4MThjMC0uNTY3Mi0uMDUwOS0xLjExMjctLjE0NTQtMS42MzYzaC03LjUzNDZ2My4wOTQ1aDQuMzA1NWMtLjE4NTUgMS0uNzQ5MSAxLjg0NzMtMS41OTY0IDIuNDE0NnYyLjAwNzNoMi41ODU1YzEuNTEyNy0xLjM5MjggMi4zODU0LTMuNDQzNyAyLjM4NTQtNS44ODAxeiIgZmlsbD0iIzQyODVmNCIvPjxwYXRoIGQ9Im0xNi4xNDk2IDI0YzIuMTYgMCAzLjk3MDktLjcxNjQgNS4yOTQ2LTEuOTM4MmwtMi41ODU1LTIuMDA3M2MtLjcxNjQuNDgtMS42MzI3Ljc2MzYtMi43MDkxLjc2MzYtMi4wODM2IDAtMy44NDczLTEuNDA3Mi00LjQ3NjQtMy4yOTgxaC0yLjY3MjcxdjIuMDcyN2MxLjMxNjQxIDIuNjE0NSA0LjAyMTgxIDQuNDA3MyA3LjE0OTExIDQuNDA3M3oiIGZpbGw9IiMzNGE4NTMiLz48cGF0aCBkPSJtMTEuNjczNSAxNy41MmMtLjE2LS40OC0uMjUwOS0uOTkyOC0uMjUwOS0xLjUyIDAtLjUyNzMuMDkwOS0xLjA0LjI1MDktMS41MnYtMi4wNzI4aC0yLjY3MjY5Yy0uNTQxODIgMS4wOC0uODUwOTEgMi4zMDE4LS44NTA5MSAzLjU5MjggMCAxLjI5MDkuMzA5MDkgMi41MTI3Ljg1MDkxIDMuNTkyN3oiIGZpbGw9IiNmYmJjMDUiLz48cGF0aCBkPSJtMTYuMTQ5NiAxMS4xODE4YzEuMTc0NSAwIDIuMjI5MS40MDM3IDMuMDU4MiAxLjE5NjRsMi4yOTQ1LTIuMjk0NmMtMS4zODU0LTEuMjkwODctMy4xOTYzLTIuMDgzNi01LjM1MjctMi4wODM2LTMuMTI3MyAwLTUuODMyNyAxLjc5MjczLTcuMTQ5MTEgNC40MDczbDIuNjcyNzEgMi4wNzI3Yy42MjkxLTEuODkwOSAyLjM5MjgtMy4yOTgyIDQuNDc2NC0zLjI5ODJ6IiBmaWxsPSIjZWE0MzM1Ii8+PC9nPjwvc3ZnPg=="
  },
  {
    provider: "facebook",
    name: "Sign in with Facebook",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgZmlsbD0iIzE4NzdGMiIgdmVyc2lvbj0iMS4wIiB2aWV3Qm94PSIwIDAgMjA4NCAyMDg0Ij48cGF0aCBkPSJNOTkyIDJDODU4LjcgOS4xIDczNi42IDM4LjEgNjE5IDkwLjVjLTI4NS41IDEyNy4yLTQ5OS4xIDM3NS45LTU4MS41IDY3Ny0yNS45IDk0LjYtMzcuOCAxOTAuMi0zNi4yIDI5MSAuOCA0Ni43IDIuOCA3NS4zIDguMyAxMTguNSAxNi4xIDEyNi42IDU2LjcgMjUxLjUgMTE4IDM2My44IDEwMS44IDE4NiAyNTYuOSAzMzYuMiA0NDUuOSA0MzEuNyA2Mi4xIDMxLjMgMTI3LjggNTYuNiAxOTMgNzQuMyA5LjkgMi43IDE5LjIgNS4yIDIwLjggNS42bDIuNy42di02OTJsLTEwNy4yLS4yLTEwNy4zLS4zdi0zMThsMTA3LjEtLjMgMTA3LjItLjIuNS05Mi44Yy41LTkwIC45LTEwMyA0LjMtMTM5LjIgMTctMTgzLjIgOTAtMzA1LjUgMjIwLjUtMzY5LjUgNTguNy0yOC44IDEyOC4zLTQ1LjcgMjE1LjktNTIuNSAyMi44LTEuOCA4Mi40LTIuNCAxMDYtMS4xIDU3LjEgMy4yIDEyMC40IDEwLjYgMTYzIDE5LjEgMTAuNyAyLjIgMjAuOSA0LjMgMjIuNSA0LjhsMyAuOC4zIDE0NC45LjIgMTQ0LjgtNi4yLS42Yy0yOS4zLTMtMTMzLjEtNC4yLTE1OC4zLTEuOS02NS42IDYtMTA4LjYgMjIuMy0xMzkgNTIuNy0yMi45IDIyLjktMzcuOCA1My00NS45IDkyLjgtNi40IDMxLjEtNy42IDUyLjgtNy42IDEzMi45djY0LjhoMTcwYzkzLjUgMCAxNzAgLjQgMTcwIC44IDAgLjUtMTMgNzEuOS0yOSAxNTguNy0xNS45IDg2LjgtMjkgMTU4LjItMjkgMTU4LjcgMCAuNC02My40LjgtMTQxIC44aC0xNDF2MzU3LjVjMCAyODUuMy4zIDM1Ny41IDEuMyAzNTcuNSAzLjMgMCA0NC43LTYuNCA2MS42LTkuNSAxNjMtMjkuOSAzMTYuNy05OC44IDQ0OS4xLTIwMS40IDU1LjgtNDMuMiAxMTMuOS05OS4xIDE1OS42LTE1My43IDQxLjMtNDkuMSA4MC41LTEwNi4yIDExMi44LTE2My45IDE5LjctMzUuMiA0Ny05My42IDYxLjctMTMyLjMgNzAuNi0xODQuOCA4Ny4yLTM4Ni4xIDQ3LjgtNTgxLjUtNDUuNy0yMjYuNi0xNjkuNC00MzUuNi0zNDYuOS01ODUuOC0xNDQuNS0xMjIuMi0zMTYuNC0yMDItNTAxLjUtMjMyLjktMzEuMy01LjItNjYuNC05LjItMTA0LTEyLTE4LjMtMS40LTk4LjctMi4xLTExOC41LTF6Ii8+PC9zdmc+"
  },
  {
    provider: "twitch",
    name: "Sign in with Twitch",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiCgl2aWV3Qm94PSItNDAwIC00MDAgMjgwMCAzMjAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4KCTxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+CgkJLnN0MCB7CgkJCWZpbGw6ICNGRkZGRkY7CgkJfQoKCQkuc3QxIHsKCQkJZmlsbDogIzkxNDZGRjsKCQl9Cgk8L3N0eWxlPgoJPHRpdGxlPkFzc2V0IDI8L3RpdGxlPgoJPGc+CgkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIyMjAwLDEzMDAgMTgwMCwxNzAwIDE0MDAsMTcwMCAxMDUwLDIwNTAgMTA1MCwxNzAwIDYwMCwxNzAwIDYwMCwyMDAgMjIwMCwyMDAgCSIgLz4KCQk8Zz4KCQkJPGcgaWQ9IkxheWVyXzEtMiI+CgkJCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNTAwLDBMMCw1MDB2MTgwMGg2MDB2NTAwbDUwMC01MDBoNDAwbDkwMC05MDBWMEg1MDB6IE0yMjAwLDEzMDBsLTQwMCw0MDBoLTQwMGwtMzUwLDM1MHYtMzUwSDYwMFYyMDBoMTYwMAoJCQkJVjEzMDB6IiAvPgoJCQkJPHJlY3QgeD0iMTcwMCIgeT0iNTUwIiBjbGFzcz0ic3QxIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjYwMCIgLz4KCQkJCTxyZWN0IHg9IjExNTAiIHk9IjU1MCIgY2xhc3M9InN0MSIgd2lkdGg9IjIwMCIgaGVpZ2h0PSI2MDAiIC8+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo="
  },
  {
    provider: "onefc",
    name: "Sign in with ONE Championship",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAxmVYSWZJSSoACAAAAAcAEgEDAAEAAAABAAAAGgEFAAEAAABiAAAAGwEFAAEAAABqAAAAKAEDAAEAAAACAAAAMQECAAYAAAByAAAAEwIDAAEAAAABAAAAaYcEAAEAAAB4AAAAAAAAAEgAAAABAAAASAAAAAEAAABiZkB2MQAGAACQBwAEAAAAMDIxMAGRBwAEAAAAAQIDAACgBwAEAAAAMDEwMAGgAwABAAAA//8AAAKgBAABAAAAQAAAAAOgBAABAAAAQAAAAAAAAAAkG5CYAAAI50lEQVR4nO1YS0gVYRt+53pmzsVLaEGaYYRoihVI0IWoFt2oFroIOqBBtKgIgyJr1yraJLToYot02SI0S6WUMrppWFHmhbQ0qmN5O+d4rjPzzXzfv3j/huhvrBP+u/MsDjPfmXm/9/q87zcAaaSRRhpppJFGGmmkkUYav4BLEVlZWQAgCIIoigAgSdL8chZKT36hBIXDYZ7nBUEwTVMURVTRNuP/B3EBZWVkZITDYQAwTRNXeD5lBzkFhzH22/UFiwDHcYZh4HV+fr4gCDzP67q+UPKdsGAGMMYSiQQAuN3u2traoqKi+fPHqTaYA1JWKNUiBgBBEGRZXrx4cSgU8vv9uJKqHN4BTnouWAREUZRl2TCMrVu3ZmVlbd++HZwTeh6kaoAj/iECiLa2tng8PjExkZmZmaqQfzDY8QWO4xhjLpdL13VBEA4cOFBZWen1elVVTSQSPM97vd5IJOJ2uyORSENDQ2trq9frVRRlZGQkOzsbAPbu3dvR0SFJkq7rkiQRQo4fP75t27ZgMBiPxy9cuPD9+/ejR49WVFTIsswYi8fjsizzPE8IkSTJ4/HMzMy4XC7kg1evXtXX19vqIWUTQhwtw4QGgJUrVz569CiRSDDGLMsyTROvGWPJZNI0TcbY6OhoaWkpABw7dowxFgqFGGNNTU0oRJZlSZIWLVo0MDBgWRal9NmzZwCQl5c3Pj7OGItGo3axWpaFxszNzeFKLBajlFZXV7tcLkVRJEn624zieT47O/vx48eMMcMwULNoNDo9PT07OxsIBOxdA4FAYWEhADx8+NBWaHBwMCcnB35UwqZNmyzLQjlHjhwBgH379hFCLMuyPYLqMsYIIT9TUDgcLisrAwAMiJ1pPM87NjKv15tIJIqKijZu3BiJRDIyMt6+fVtdXU0IycjImJmZqa6uPnv2LM/zjLHh4eFAIFBaWlpRURGPx71eLwAUFBRs2LChvb0dNz548CDP85TSRCLR1taGaSkIQiQSyczMbGlp6enpoZQqimKapmEYXq/XsqxYLOZ2u0dHR4eHhwHgl8YiCMIfgtDY2IgxZYydO3cO3enxeDiOa2trY4xRSi3LQo/W1tZi9BljmqYxxi5fvoxysrKyRkdHg8EgpbSzsxMA3G73zMyM7ePNmzcLgoAKof0AgGMVPmxrzP2gbJif5dxut8vlGh4exg0MwygpKfF4PD6fDwBWrVoVi8UMwyCETExM5ObmYv7ouq7rOmPMNE1K6cjISG5ursfj2blzp61rTU0NANTU1GDCRKPRrq4uVVWRiG3t8SIzMxMvOI5De1D1v5qy9u/fj6pMTU09ePDA4/HYzjh9+rSdqTdv3gSA0tJSVJoxNjs7a6u7detWALh69SrefvjwYdmyZS6X69atW6ZpIgdomvb06dN3794NDQ0NDAy8efMmGAzeuXPnt1rZ0+6fbbh+/bpNKYcPH0YnoVeePHmCSZJIJCorK2VZPnPmDFrLGLt+/frnz58ZY7quX7lyRRCEqakpy7IIIc3NzT6fr6CgIBAIoP2EECxiu5QppXNzc9euXQMADLgoijzPY8KgB22S/G8sFEXBMKmqii8sWbJkbm4OEzqZTBYUFPh8PnwgPz8fdwqFQqOjo5g/3d3daFIwGCwqKmptbUVO7Ovrq66utiwLa6mqqorjuEOHDtmEgyCEIEElk0lcWb16NfzIcrsYfhsQkRCiaRr2mmQyyXGcaZq7d+8WBIExBgBdXV1TU1OapgFAMpk8efIkAIRCoezs7M7Ozunp6XXr1m3ZsgUlvnz5cmRkpLu7e9euXZIklZWVYfXzPD85Odnb28sY27Jli2VZmJM3btwYHx9HPxqGoapqKBRKJBLT09MAgH3Tns9/A7spYBDwHY7jWlpa0CWMMb/fL0mSoiiKovh8vu7ubrtM165dCwB1dXWUUmSVU6dOAcCaNWsmJycxo5ADKKWNjY2KouTl5WFgMVzYAXmeRzdjKf8huX+OAKUUfa9pGh4ICSEFBQXr169Hr4yNjXV1daG6lmVt2LABnW2a5tjY2MePH1VV9fv9HMdlZWXF4/HW1lae57EiN23aZJomIUSWZY7j2tvbGWN79+51u91I9uFwuLy8vLi4mDGmKArP89FoNCcnJx6PU0oNw7h9+7Ysy6Io4qz+e+ATAMBxHJJUbW0tmhSLxe7evbtixYrly5fn5ua6XK4rV64QQoLBIGOsrq7O4/GUlJTEYjFkz+bmZgBwuVwAcOLECaxI5JlwOLx06VIAuH///s8dAEUlk0m7+2qaFolELMu6du3an6kGUwhrxa70jo4OuxlFIpHBwcEvX74EAoFv374lEgmki97e3kWLFgHAxYsX2Y9Zw+/3Iz9wHFdYWBgKhWy1cDQqLy+fmpqyyc0eeHRdNwwDCx1NYozt2bMHAHA0dITdzPAkjnE8f/48etR2oX2N2r948aK4uBgA8vLy+vv78d+vX7+WlZWh+3GEvHfvns2PVVVVkiSdPn0ahyg7MvhrG4BsyxgbGhpCDsVfxxpgjImiaFebKIqaptXX14dCoeLiYhxZkRC9Xm88Huc47vXr1w0NDdgaRVF8/vx5b2+vqqrv379///49jrhYS62trTt27JAk6cOHD/39/YSQ2dnZvr6+T58++Xy+WCyGzGFZlqqqyHKojCAIPT098XgcAKLRKC7+IZf+EvMfRH6+VhQlNzd3enraMIympiYAUFUVc3oeXk/1oOM4WIsOcBTE879sput6LBbr7e2VJOnWrVuSJGGlulwuDHVK8lM2gDrA6XlseeynzwfILd3d3TMzM48ePbJHX57n8ViTknwnOFrsJMspmrbqjDE8juLt06dPL126ZBiGYRhoQzKZ/Af5TpjvTDy/ovMDdaWUqqoqy7KmaZqmqaqq6zqlVBCEVJ3ttO+CGYAaW5aFt9heMBqUUjyL2WQiiqL95F8iZQNSBcdxeLy0XYuJhOcsQogoijiMAADa4yTnt+tOBizkp0VK6f/yKdYrx3GEEEEQkEb/4ftPGmmkkUYaaaSRRhpppJHGr/gPrRmLNs+cA/AAAAAASUVORK5CYII="
  },
  {
    provider: "playtron",
    name: "Sign in with Playtron",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABg2lDQ1BJQ0MgUHJvZmlsZQAAeJx9kT1Iw0AcxV9bpSoVBzOIOASpTu2iIo5ahSJUCLVCqw4ml35Bk4YkxcVRcC04+LFYdXBx1tXBVRAEP0CcHZwUXaTE/yWFFjEeHPfj3b3H3Tsg2KgwzeqaBTTdNtPJhJjNrYrhV4TRCwExjMrMMuYkKQXf8XWPAF/v4jzL/9yfo1/NWwwIiMSzzDBt4g3i6U3b4LxPLLCSrBKfE8dMuiDxI9cVj984F10O8kzBzKTniQVisdjBSgezkqkRTxFHVU2n/GDWY5XzFmetUmOte/IXRvL6yjLXaY4giUUsQYIIBTWUUYGNOK06KRbStJ/w8Q+7folcCrnKYORYQBUaZNcP/ge/u7UKkxNeUiQBdL84zscYEN4FmnXH+T52nOYJEHoGrvS2v9oAZj5Jr7e16BEwsA1cXLc1ZQ+43AGGngzZlF0pRDNYKADvZ/RNOWDwFuhb83pr7eP0AchQV6kb4OAQGC9S9rrPu3s6e/v3TKu/H7prcsNwAs3sAAALU0lEQVR4nO2dW28bRRTH/zOzs7abRKW0lIRLK9S0Ve+NglSaVIhLKoSAF5544iPBV0A89Q2pgEQKAgF5ASVtk0Ie2iKVtrQgQRq5ib23meHBnW3sOGnsnV27mflJfojXuzvr+c+Zc+accQgABYe10F43wNFbnAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALKfvBEAI6XUTrMLrdQPWQgiBUmrde5vR+vmnjbXPRwgBIQRSysKei6APfySKMQbf96GUQhAEvW5O4VBKwRiDlDJ3MfSlAIDGaCiXy08UwHayAEDxz9NXUwDQUL+UEi+88ALGx8etmgIAQEqJW7du4ebNm6jX64W0QfXTixCiGGPqgw8+UEIIZSOfffZZ+l3k/X33ZRQghMDrr7+OJEkgpdzws+opH/0b8f333wMAPC9/A913U4CUEpxznD9/HoyytlOAUmrbdH7r862srODHH38E53yd+NtFSVnpOwEAwLPPPovDhw+DeWxdZ2+Xjt+Ie/fu4Z9//gEACCFyv19fCmB0dBTlchlSyrYWoDV23k7cuHEjjXy0Q6xDYiHE028BdGjHGMPIyAief/75puO+7+Ojjz4C0PgClFLbrpM3Y3Z2FqdOnUKlUkEYhiCEgFKKarWKmzdv5nLPwj19zrninKuffvqprRecxIlSSqkgCNYdk1I2vbYbtVpNRVGklFIqDMP0/bNnz6pSqWS8Lwq3AKVSCUBjdL/yyiubfnazCKBfURksllIKPvdT38fzPARBgJWVFVy/fj2X76MnYWAYhhgbG8PI8Ejb48xjAIBKpbLumF4v169+IQxDBEGQeY6mjKbXIIQgjmPUajVUq9VcnMLCBaAfbmxsDJT13TJE1/i+D9/3M4my3blDQ0P4+uuvcxN84VOAEAK+7+Odd97pixGcdcQCyN0iffnll7mFhIULQCkF3/cxNjaWy/U79ZSzCEDP95RSlEolcM6xd+9eo0Ko1Wq4detWrlnBwqOA48ePG/WcpZQqiRP1ySefFP4s+rV79261uLiYevCmuHv3rmKMKc55Lu3uySR8+vRpiMScSYuiCMxjmJ+fN3bNTiCEYNeuXRgeHjY+Si9evAghBDzPQ7lcNnptoEdRwFtvvYV6YC7V6fs+RCLwyy+/GLtmJ/fmnOPMmTPYuXOncT9gdnYWjLE0yjBNTwRw6tQpxHFs5Fp6tey/pf9w9+5dI9fsBCEECCGYmJhAkiSZr9dqQf766y9QSnN1mAudK0dHR9WDBw+MzZWrq6tKKaUuXLhQSP683atSqag//vhDKdVYxcyyUqnPkVKq27dvN+ZpSnN7tsItwMkTJ/HMM88gCAKEYZj5eowxxHGMhYWFnoSVjDHs2bMHe/fubSSvaPY26CTY77//nv5t2rfQFB4GTkxOAAAGBgZAaXb9lUolBEGAH374AZ7nIYqirq7TrXgopTh+/DgGBwchEpGuYnYLIQRJkoBSipmZmUzX2gqFWQDd2VNTU2kEYMqpkVJifn6+JxYgSRIcO3YMAIyMfuCxH6AtQJ4UZgE8z8OePXvSBJAQIk0MZWVubg61Wg2+72/5HFNiIYTg/fffh5QSQojMVk0PjocPH+LSpUsmmrgpuVsA3/dBKUWSJNi/fz8GdgxAKgnP84x1wtzcHAAY8cI7ZWhoCKOjoxBCGMnWSdWY/xcXFwupfsrdAqhHy6VCCExOThrvfJEITE9PA8iWPu62PUePHsWLL76YtiUrnudBComZmZlC0uG5W4A4jiGEAGMMZ86cMdr5AJCIBJcvX97Q/Ot75eUfvPrqq2k0k9UBBB4llmgjAjC1VrIZhUYBExMTxjvi2rVrqFarT5x7CSHwPA8XLlzAu+++CwDwuY9EJGkmjxIKqToLuRhlxpw/zcrKCi5dulSIBchdAIw1RsXIyAh2795t/PoLCwsAGvkAzvm6UaOUAmMstUInT55EpVJJP6f34WkBMbCOBGBa0HEc4++//8aDBw9yKQNvJXcB6M0Nb775pjGvfy06WSKlTMXWilIKlFIcPXoUo6OjAABKKJjHwLD+nF7WKTDGMDs7a6S6aCvk7gOoR3X9U1NTuSQz5ubmkCRJWj7VDl1aPTHRWIR6+PAhhMy/5r4bKKWYn5/PZbC0vV8RN2GM4dChQ8YeSs+Ni4uL+Pfff9uOFL27GHhciHrw4EFIKTEwMABGszts3aCU2tS5U0rhiy++QL1eb5v+NV0TmbsAKKXwPA/j4+NGTFoURakluX79euqBazNfKpXSFK3OFIZhCM/zMDU19bhda4ovi0JbQ855+p5e59ev27dvY2lpCQC6XtbuhNx9gDAM8eGHHzY5WlnQhZd6D93aTpRS4tixY7h48WK6pj40NIQwDMEYw+DgYOb7Z0G32/d9fPvtt/j444/XfaZer6cCL6LyOXcB+L6Pc+fOIYoiYxUtnudBCIGZmZnUw9fs27cPzz33HHzfR61WQ7lcbhKeHmm9YmBgAEIIfPPNN1heXm46pq2l3j2lnytPEeQugCiKcPjw4bRqx8RiSZIkqFaruHHjBjjnaVEG5xxvvPFG+oXt2LGj7fm99PJ1ccfCwgI4501mXgjRtvp3rWBNtz13H6BSqeDs2bMQQiCMsuf/gYZTefny5TT5wjlPrcLk5CQ451BKGak3yIPV1VVcu3atL3Y65y6A8+fPp46PiR88kFKCUorp6WnEcdyUABoZGcGBAwcQxzEIIYWFUp3y66+/Ynl5uS/2ReQyBehtzUBjq/dGprgblFQAbcT/cRw3LZceOnQIO3fuTHcVJ0lizPk0hZQS3333Xd+0y7gAtKrL5TLCMGwKvUzE3pRRRFGE3377bZ0JnZ2dxZEjRzY9v/Wc1lGYd6csLy+jXq+DMdZ2I2nR00IuApBSIggCVCoVvPbaa4+PGUiaEEJw5cqV1MxrlFKoVquoVquZ75EneifR2r+B4jteY1wAa03ykSNHUC6XUa/X4Xle0wJItyilMD09nY4i/asZaxMnm82tT7IAuZZfP7r3Wk+/135AbmHg0NAQxsfH09jflMKlkLhy5UpTjLyVju81G60/5BnibQXjAtAp2ZWVlab5f6sPF8dxGh/r38ZZSz2oY3FxEYODg1hdXU3f71Zgref1MjTbyr1Nt8+4AHSig3OO06dPd3y+rvPXFT6tD3znzh38+eefCMOwbf7f0Rm5TQEvv/wy9u/f3/F5lFJQSvH555/j008/XeeVR1GEJElc5xsiNwEcPHiwqx81qFarKJfL+Pnnn3H16tWmY7qsSz36yTRHdowHvXrR5+233+7q/EqlkiZLWtGLO71O6GwnjAugXq+DEIL33nuvq6VfIQTu37+PpaWlDUu8NP3s9T8tGBeAUgovvfQSdu3a1dFOHQ0hBHNzcwjD8Kn8mbinDeMC4Jxj3759GB4e7mqjRKlUwtWrV9uGgA7z5PIfQ06cOIEDBw6kyZhO+eqrrzZ08nq9dr7dMC4AXZjxpOLHzWit8mm9/lqcALJhNAzUy7K6yqXXiQ7HkzEqAN3RlUolrdAJgqBjb90JpjhymQI0m3XkZqLQKeWtCMeJJRu9L0lpg+vU4uhLAQBukaco+lYAjmLo2/8c6igGZwEsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAsxwnAcpwALMcJwHKcACzHCcBynAAs538C/i1KSc+86gAAAABJRU5ErkJggg=="
  }
];

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/register.js
function registerEnokiWallets({
  providers,
  windowFeatures = defaultWindowFeatures,
  ...config
}) {
  const clients = "clients" in config ? config.clients : [Object.assign(config.client, { network: config.network ?? "mainnet" })];
  const enokiCompatibleClients = clients.filter(({ network }) => isEnokiNetwork(network));
  if (enokiCompatibleClients.length === 0) {
    throw new Error("None of the specified clients are compatible with Enoki.");
  }
  const getCurrentNetwork = "clients" in config ? config.getCurrentNetwork : () => clients[0].network;
  const walletsApi = getWallets();
  const wallets = {};
  for (const { name, icon, provider } of ENOKI_PROVIDER_WALLETS_INFO) {
    const providerOptions = providers[provider];
    if (providerOptions) {
      wallets[provider] = new EnokiWallet({
        ...providerOptions,
        name,
        icon,
        provider,
        windowFeatures,
        getCurrentNetwork,
        apiKey: config.apiKey,
        apiUrl: config.apiUrl,
        clients: enokiCompatibleClients
      });
    }
  }
  const unregister = walletsApi.register(...Object.values(wallets));
  return { wallets, unregister };
}
function defaultWindowFeatures() {
  const width = 500;
  const height = 800;
  const left = (screen.width - width) / 2;
  const top = (screen.height - height) / 4;
  return `popup=1;toolbar=0;status=0;resizable=1,width=${width},height=${height},top=${top},left=${left}`;
}

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/initializer.js
function enokiWalletsInitializer(options) {
  return {
    id: "enoki-wallets-initializer",
    async initialize({
      networks,
      getClient: getClient3
    }) {
      const { unregister } = registerEnokiWallets({
        ...options,
        getCurrentNetwork: () => getClient3().network,
        clients: networks.map(getClient3)
      });
      return { unregister };
    }
  };
}

// node_modules/.pnpm/@wallet-standard+ui-registry@1.0.1/node_modules/@wallet-standard/ui-registry/lib/esm/UiWalletHandleRegistry_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.js
var uiWalletHandlesToWallets = /* @__PURE__ */ new WeakMap();
function getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle) {
  const wallet = uiWalletHandlesToWallets.get(uiWalletHandle);
  if (!wallet) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND);
    safeCaptureStackTrace(err, getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);
    throw err;
  }
  return wallet;
}

// node_modules/.pnpm/@wallet-standard+ui-features@1.0.1/node_modules/@wallet-standard/ui-features/lib/esm/getWalletFeature.js
function getWalletFeature(uiWalletHandle, featureName) {
  const wallet = getWalletForHandle_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(uiWalletHandle);
  if (!(featureName in wallet.features)) {
    const err = new WalletStandardError(WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED, {
      featureName,
      supportedChains: [...wallet.chains],
      supportedFeatures: Object.keys(wallet.features),
      walletName: wallet.name
    });
    safeCaptureStackTrace(err, getWalletFeature);
    throw err;
  }
  return wallet.features[featureName];
}

// node_modules/.pnpm/@mysten+enoki@0.12.8_@types+react@18.3.24_react@18.3.1_typescript@5.9.2/node_modules/@mysten/enoki/dist/esm/wallet/utils.js
function isEnokiWallet(wallet) {
  if (isWalletHandle(wallet)) {
    return wallet.features.includes(EnokiGetMetadata);
  }
  return EnokiGetMetadata in wallet.features;
}
function getWalletMetadata(wallet) {
  if (isWalletHandle(wallet)) {
    try {
      const { getMetadata } = getWalletFeature(
        wallet,
        EnokiGetMetadata
      );
      return getMetadata();
    } catch {
      return null;
    }
  } else if (EnokiGetMetadata in wallet.features) {
    const walletWithFeature = wallet;
    return walletWithFeature.features[EnokiGetMetadata].getMetadata();
  }
  return null;
}
async function getSession(wallet, input) {
  if (isWalletHandle(wallet)) {
    try {
      const { getSession: getSession2 } = getWalletFeature(
        wallet,
        EnokiGetSession
      );
      return await getSession2(input);
    } catch {
      return null;
    }
  } else if (EnokiGetSession in wallet.features) {
    const walletWithFeature = wallet;
    return await walletWithFeature.features[EnokiGetSession].getSession(input);
  }
  return null;
}
function isGoogleWallet(wallet) {
  return getWalletMetadata(wallet)?.provider === "google";
}
function isTwitchWallet(wallet) {
  return getWalletMetadata(wallet)?.provider === "twitch";
}
function isFacebookWallet(wallet) {
  return getWalletMetadata(wallet)?.provider === "facebook";
}
function isWalletHandle(wallet) {
  return Array.isArray(wallet.features);
}
export {
  EnokiClient,
  EnokiClientError,
  EnokiFlow,
  EnokiKeypair,
  EnokiPublicKey,
  createDefaultEncryption,
  createInMemoryStorage,
  createLocalStorage,
  createSessionStorage,
  enokiWalletsInitializer,
  getSession,
  getWalletMetadata,
  isEnokiNetwork,
  isEnokiWallet,
  isFacebookWallet,
  isGoogleWallet,
  isTwitchWallet,
  registerEnokiWallets
};
/*! Bundled license information:

@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/nist.js:
@noble/curves/esm/p256.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@mysten_enoki.js.map
