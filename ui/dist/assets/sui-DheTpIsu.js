import{b as as,a as Fe,p as S,o as l,n as tt,l as p,u as _,c as C,d as E,i as T,t as os,s as f,e as vn,f as xt,g as v,h as g,j as Ct,r as At,k as bt,m as je,q as $,v as yn,w as cs,S as ju,x as Cu,y as Au,z as Va,A as _u,B as Pu,C as xu,D as Nu,R as Uu,E as Ii,F as zr,G as Ru,H as La,I as Wa,J as ut,K as Ns,L as Vr,M as Bu,N as Du}from"./vendor-other-BEKRNCjF.js";const zu="â€¦";function Mm(n){if(n.length<=6)return n;const e=n.startsWith("0x")?2:0;return`0x${n.slice(e,e+4)}${zu}${n.slice(-4)}`}const us=n=>as.encode(n),Qn=n=>as.decode(n);function se(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0))}const ms=8192;function F(n){if(n.length<ms)return btoa(String.fromCharCode(...n));let e="";for(var t=0;t<n.length;t+=ms){const r=n.slice(t,t+ms);e+=String.fromCharCode(...r)}return btoa(e)}function $i(n){const e=n.startsWith("0x")?n.slice(2):n,t=e.length%2===0?e:`0${e}`,r=t.match(/[0-9a-fA-F]{2}/g)?.map(s=>parseInt(s,16))??[];if(r.length!==t.length/2)throw new Error(`Invalid hex string ${n}`);return Uint8Array.from(r)}function Qt(n){return n.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function ls(n,e){return Array.from({length:Math.ceil(n.length/e)},(t,r)=>n.slice(r*e,(r+1)*e))}function Vu(){let n,e;return{promise:new Promise((r,s)=>{n=r,e=s}),resolve:n,reject:e}}let Fa=class{constructor(e,t){if(typeof e!="function")throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${e}.`);this._batchLoadFn=e,this._maxBatchSize=Gu(t),this._batchScheduleFn=Ku(t),this._cacheKeyFn=qu(t),this._cacheMap=Ju(t),this._batch=null,this.name=Zu(t)}load(e){if(e==null)throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(e)}.`);const t=Wu(this),r=this._cacheMap;let s;if(r){s=this._cacheKeyFn(e);const a=r.get(s);if(a){const u=t.cacheHits||(t.cacheHits=[]);return new Promise(d=>{u.push(()=>{d(a)})})}}t.keys.push(e);const i=new Promise((a,u)=>{t.callbacks.push({resolve:a,reject:u})});return r&&r.set(s,i),i}loadMany(e){if(!Ga(e))throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${e}.`);const t=[];for(let r=0;r<e.length;r++)t.push(this.load(e[r]).catch(s=>s));return Promise.all(t)}clear(e){const t=this._cacheMap;if(t){const r=this._cacheKeyFn(e);t.delete(r)}return this}clearAll(){const e=this._cacheMap;return e&&e.clear(),this}prime(e,t){const r=this._cacheMap;if(r){const s=this._cacheKeyFn(e);if(r.get(s)===void 0){let i;t instanceof Error?(i=Promise.reject(t),i.catch(()=>{})):i=Promise.resolve(t),r.set(s,i)}}return this}};const Lu=typeof process=="object"&&typeof process.nextTick=="function"?function(n){ys||(ys=Promise.resolve()),ys.then(()=>{process.nextTick(n)})}:typeof setImmediate=="function"?function(n){setImmediate(n)}:function(n){setTimeout(n)};let ys;function Wu(n){const e=n._batch;if(e!==null&&!e.hasDispatched&&e.keys.length<n._maxBatchSize)return e;const t={hasDispatched:!1,keys:[],callbacks:[]};return n._batch=t,n._batchScheduleFn(()=>{Fu(n,t)}),t}function Fu(n,e){if(e.hasDispatched=!0,e.keys.length===0){Us(e);return}let t;try{t=n._batchLoadFn(e.keys)}catch(r){return ws(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(r)}.`))}if(!t||typeof t.then!="function")return ws(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(t)}.`));Promise.resolve(t).then(r=>{if(!Ga(r))throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(r)}.`);if(r.length!==e.keys.length)throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(e.keys)}

Values:
${String(r)}`);Us(e);for(let s=0;s<e.callbacks.length;s++){const i=r[s];i instanceof Error?e.callbacks[s].reject(i):e.callbacks[s].resolve(i)}}).catch(r=>{ws(n,e,r)})}function ws(n,e,t){Us(e);for(let r=0;r<e.keys.length;r++)n.clear(e.keys[r]),e.callbacks[r].reject(t)}function Us(n){if(n.cacheHits)for(let e=0;e<n.cacheHits.length;e++)n.cacheHits[e]()}function Gu(n){if(!(!n||n.batch!==!1))return 1;const t=n&&n.maxBatchSize;if(t===void 0)return 1/0;if(typeof t!="number"||t<1)throw new TypeError(`maxBatchSize must be a positive number: ${t}`);return t}function Ku(n){const e=n&&n.batchScheduleFn;if(e===void 0)return Lu;if(typeof e!="function")throw new TypeError(`batchScheduleFn must be a function: ${e}`);return e}function qu(n){const e=n&&n.cacheKeyFn;if(e===void 0)return t=>t;if(typeof e!="function")throw new TypeError(`cacheKeyFn must be a function: ${e}`);return e}function Ju(n){if(!(!n||n.cache!==!1))return null;const t=n&&n.cacheMap;if(t===void 0)return new Map;if(t!==null){const s=["get","set","delete","clear"].filter(i=>t&&typeof t[i]!="function");if(s.length!==0)throw new TypeError("Custom cacheMap missing methods: "+s.join(", "))}return t}function Zu(n){return n&&n.name?n.name:null}function Ga(n){return typeof n=="object"&&n!==null&&"length"in n&&typeof n.length=="number"&&(n.length===0||n.length>0&&Object.prototype.hasOwnProperty.call(n,n.length-1))}function Lr(n){const e=[];let t=0;if(n===0)return[0];for(;n>0;)e[t]=n&127,(n>>=7)&&(e[t]|=128),t+=1;return e}function Hu(n){let e=0,t=0,r=0;for(;;){const s=n[r];if(r+=1,e|=(s&127)<<t,(s&128)===0)break;t+=7}return{value:e,length:r}}let Qu=class{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength)}shift(e){return this.bytePosition+=e,this}read8(){const e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){const e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){const e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){const e=this.read32(),r=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){const e=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){const e=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(e){const t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){const e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:s}=Hu(t);return this.shift(s),r}readVec(e){const t=this.readULEB(),r=[];for(let s=0;s<t;s++)r.push(e(this,s,t));return r}};function Yu(n,e){switch(e){case"base58":return us(n);case"base64":return F(n);case"hex":return Qt(n);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function Ka(n,e=["<",">"]){const[t,r]=e,s=[];let i="",a=0;for(let u=0;u<n.length;u++){const d=n[u];if(d===t&&a++,d===r&&a--,a===0&&d===","){s.push(i.trim()),i="";continue}i+=d}return s.push(i.trim()),s}let Xu=class{constructor({initialSize:e=1024,maxSize:t=1/0,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const r=Math.min(this.maxSize,this.size+this.allocateSize);if(t>r)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=r;const s=new ArrayBuffer(this.size);new Uint8Array(s).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(s)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return bs(BigInt(e),8).forEach(t=>this.write8(t)),this}write128(e){return bs(BigInt(e),16).forEach(t=>this.write8(t)),this}write256(e){return bs(BigInt(e),32).forEach(t=>this.write8(t)),this}writeULEB(e){return Lr(e).forEach(t=>this.write8(t)),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach((r,s)=>t(this,r,s,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return Yu(this.toBytes(),e)}};function bs(n,e){const t=new Uint8Array(e);let r=0;for(;n>0;)t[r]=Number(n%BigInt(256)),n=n/BigInt(256),r+=1;return t}var qa=n=>{throw TypeError(n)},Ja=(n,e,t)=>e.has(n)||qa("Cannot "+t),xe=(n,e,t)=>(Ja(n,e,"read from private field"),t?t.call(n):e.get(n)),Wr=(n,e,t)=>e.has(n)?qa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Fr=(n,e,t,r)=>(Ja(n,e,"write to private field"),e.set(n,t),t),on,jn,mr,St;const el=class Za{constructor(e){Wr(this,on),Wr(this,jn),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),Fr(this,on,e.write),Fr(this,jn,e.serialize??((t,r)=>{const s=new Xu({initialSize:this.serializedSize(t)??void 0,...r});return xe(this,on).call(this,t,s),s.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),xe(this,on).call(this,e,t)}serialize(e,t){return this.validate(e),new tl(this,xe(this,jn).call(this,e,t))}parse(e){const t=new Qu(e);return this.read(t)}fromHex(e){return this.parse($i(e))}fromBase58(e){return this.parse(Qn(e))}fromBase64(e){return this.parse(se(e))}transform({name:e,input:t,output:r,validate:s}){return new Za({name:e??this.name,read:i=>r?r(this.read(i)):this.read(i),write:(i,a)=>xe(this,on).call(this,t?t(i):i,a),serializedSize:i=>this.serializedSize(t?t(i):i),serialize:(i,a)=>xe(this,jn).call(this,t?t(i):i,a),validate:i=>{s?.(i),this.validate(t?t(i):i)}})}};on=new WeakMap;jn=new WeakMap;let nt=el;const Ha=Symbol.for("@mysten/serialized-bcs");function Ei(n){return!!n&&typeof n=="object"&&n[Ha]===!0}let tl=class{constructor(e,t){Wr(this,mr),Wr(this,St),Fr(this,mr,e),Fr(this,St,t)}get[Ha](){return!0}toBytes(){return xe(this,St)}toHex(){return Qt(xe(this,St))}toBase64(){return F(xe(this,St))}toBase58(){return us(xe(this,St))}parse(){return xe(this,mr).parse(xe(this,St))}};mr=new WeakMap;St=new WeakMap;function Gr({size:n,...e}){return new nt({...e,serializedSize:()=>n})}function vs({readMethod:n,writeMethod:e,...t}){return Gr({...t,read:r=>r[n](),write:(r,s)=>s[e](r),validate:r=>{if(r<0||r>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${r}. Expected value in range 0-${t.maxValue}`);t.validate?.(r)}})}function Ss({readMethod:n,writeMethod:e,...t}){return Gr({...t,read:r=>r[n](),write:(r,s)=>s[e](BigInt(r)),validate:r=>{const s=BigInt(r);if(s<0||s>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${s}. Expected value in range 0-${t.maxValue}`);t.validate?.(s)}})}function nl({serialize:n,...e}){const t=new nt({...e,serialize:n,write:(r,s)=>{for(const i of t.serialize(r).toBytes())s.write8(i)}});return t}function rl({toBytes:n,fromBytes:e,...t}){return new nt({...t,read:r=>{const s=r.readULEB(),i=r.readBytes(s);return e(i)},write:(r,s)=>{const i=n(r);s.writeULEB(i.length);for(let a=0;a<i.length;a++)s.write8(i[a])},serialize:r=>{const s=n(r),i=Lr(s.length),a=new Uint8Array(i.length+s.length);return a.set(i,0),a.set(s,i.length),a},validate:r=>{if(typeof r!="string")throw new TypeError(`Invalid ${t.name} value: ${r}. Expected string`);t.validate?.(r)}})}function sl(n){let e=null;function t(){return e||(e=n()),e}return new nt({name:"lazy",read:r=>t().read(r),serializedSize:r=>t().serializedSize(r),write:(r,s)=>t().write(r,s),serialize:(r,s)=>t().serialize(r,s).toBytes()})}let il=class extends nt{constructor({name:e,fields:t,...r}){const s=Object.entries(t);super({name:e,serializedSize:i=>{let a=0;for(const[u,d]of s){const b=d.serializedSize(i[u]);if(b==null)return null;a+=b}return a},read:i=>{const a={};for(const[u,d]of s)a[u]=d.read(i);return a},write:(i,a)=>{for(const[u,d]of s)d.write(i[u],a)},...r,validate:i=>{if(r?.validate?.(i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})}},al=class extends nt{constructor({fields:e,...t}){const r=Object.entries(e);super({read:s=>{const i=s.readULEB(),a=r[i];if(!a)throw new TypeError(`Unknown value ${i} for enum ${name}`);const[u,d]=a;return{[u]:d?.read(s)??!0,$kind:u}},write:(s,i)=>{const[a,u]=Object.entries(s).filter(([d])=>Object.hasOwn(e,d))[0];for(let d=0;d<r.length;d++){const[b,h]=r[d];if(b===a){i.writeULEB(d),h?.write(u,i);return}}},...t,validate:s=>{if(t?.validate?.(s),typeof s!="object"||s==null)throw new TypeError(`Expected object, found ${typeof s}`);const i=Object.keys(s).filter(u=>s[u]!==void 0&&Object.hasOwn(e,u));if(i.length!==1)throw new TypeError(`Expected object with one key, but found ${i.length} for type ${name}}`);const[a]=i;if(!Object.hasOwn(e,a))throw new TypeError(`Invalid enum variant ${a}`)}})}},ol=class extends nt{constructor({fields:e,name:t,...r}){super({name:t??`(${e.map(s=>s.name).join(", ")})`,serializedSize:s=>{let i=0;for(let a=0;a<e.length;a++){const u=e[a].serializedSize(s[a]);if(u==null)return null;i+=u}return i},read:s=>{const i=[];for(const a of e)i.push(a.read(s));return i},write:(s,i)=>{for(let a=0;a<e.length;a++)e[a].write(s[a],i)},...r,validate:s=>{if(r?.validate?.(s),!Array.isArray(s))throw new TypeError(`Expected array, found ${typeof s}`);if(s.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${s.length}`)}})}};function cl(n,e,t){return new nt({read:r=>{const s=new Array(n);for(let i=0;i<n;i++)s[i]=e.read(r);return s},write:(r,s)=>{for(const i of r)e.write(i,s)},...t,name:t?.name??`${e.name}[${n}]`,validate:r=>{if(t?.validate?.(r),!r||typeof r!="object"||!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==n)throw new TypeError(`Expected array of length ${n}, found ${r.length}`)}})}function ul(n){return o.enum(`Option<${n.name}>`,{None:null,Some:n}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>e.$kind==="Some"?e.Some:null})}function ll(n,e){return new nt({read:t=>{const r=t.readULEB(),s=new Array(r);for(let i=0;i<r;i++)s[i]=n.read(t);return s},write:(t,r)=>{r.writeULEB(t.length);for(const s of t)n.write(s,r)},...e,name:e?.name??`vector<${n.name}>`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`)}})}function dl(n,e){return o.vector(o.tuple([n,e])).transform({name:`Map<${n.name}, ${e.name}>`,input:t=>[...t.entries()],output:t=>{const r=new Map;for(const[s,i]of t)r.set(s,i);return r}})}const o={u8(n){return vs({readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...n,name:n?.name??"u8"})},u16(n){return vs({readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...n,name:n?.name??"u16"})},u32(n){return vs({readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...n,name:n?.name??"u32"})},u64(n){return Ss({readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...n,name:n?.name??"u64"})},u128(n){return Ss({readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...n,name:n?.name??"u128"})},u256(n){return Ss({readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...n,name:n?.name??"u256"})},bool(n){return Gr({size:1,read:e=>e.read8()===1,write:(e,t)=>t.write8(e?1:0),...n,name:n?.name??"bool",validate:e=>{if(n?.validate?.(e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(n){return nl({read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Lr(e)),...n,name:n?.name??"uleb128"})},bytes(n,e){return Gr({size:n,read:t=>t.readBytes(n),write:(t,r)=>{const s=new Uint8Array(t);for(let i=0;i<n;i++)r.write8(s[i]??0)},...e,name:e?.name??`bytes[${n}]`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`);if(t.length!==n)throw new TypeError(`Expected array of length ${n}, found ${t.length}`)}})},byteVector(n){return new nt({read:e=>{const t=e.readULEB();return e.readBytes(t)},write:(e,t)=>{const r=new Uint8Array(e);t.writeULEB(r.length);for(let s=0;s<r.length;s++)t.write8(r[s]??0)},...n,name:n?.name??"vector<u8>",serializedSize:e=>{const t="length"in e?e.length:null;return t==null?null:Lr(t).length+t},validate:e=>{if(n?.validate?.(e),!e||typeof e!="object"||!("length"in e))throw new TypeError(`Expected array, found ${typeof e}`)}})},string(n){return rl({toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...n,name:n?.name??"string"})},fixedArray:cl,option:ul,vector:ll,tuple(n,e){return new ol({fields:n,...e})},struct(n,e,t){return new il({name:n,fields:e,...t})},enum(n,e,t){return new al({name:n,fields:e,...t})},map:dl,lazy(n){return sl(n)}},Qa=/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i,Ya=/^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i,hl=235;function pl(n){return n.length>hl?!1:n.includes("@")?Qa.test(n):Ya.test(n)}function gl(n,e="at"){const t=n.toLowerCase();let r;if(t.includes("@")){if(!Qa.test(t))throw new Error(`Invalid SuiNS name ${n}`);const[s,i]=t.split("@");r=[...s?s.split("."):[],i]}else{if(!Ya.test(t))throw new Error(`Invalid SuiNS name ${n}`);r=t.split(".").slice(0,-1)}return e==="dot"?`${r.join(".")}.sui`:`${r.slice(0,-1).join(".")}@${r[r.length-1]}`}const fl=/^([a-z0-9]+(?:-[a-z0-9]+)*)$/,ml=/^\d+$/,yl=64,Xa="/",me=n=>{const e=n.split(Xa);if(e.length<2||e.length>3)return!1;const[t,r,s]=e;return s!==void 0&&!ml.test(s)||!pl(t)?!1:fl.test(r)&&r.length<yl},wl=n=>{const e=n.split(/::|<|>|,/);for(const t of e)if(t.includes(Xa)&&!me(t))return!1;return!0},bl=32;function na(n){try{return Qn(n).length===bl}catch{return!1}}const ir=32;function Ne(n){return Sl(n)&&kl(n)===ir}function cr(n){return Ne(n)}function vl(n){return n.includes("::")?Yt(n):n}function Yt(n){const[e,t]=n.split("::"),r=me(e),s=n.slice(e.length+t.length+4),i=s.includes("<")?s.slice(0,s.indexOf("<")):s,a=s.includes("<")?Ka(s.slice(s.indexOf("<")+1,s.lastIndexOf(">"))).map(u=>vl(u.trim())):[];return{address:r?e:P(e),module:t,name:i,typeParams:a}}function Kr(n){const{address:e,module:t,name:r,typeParams:s}=typeof n=="string"?Yt(n):n,i=s?.length>0?`<${s.map(a=>typeof a=="string"?a:Kr(a)).join(",")}>`:"";return`${e}::${t}::${r}${i}`}function P(n,e=!1){let t=n.toLowerCase();return!e&&t.startsWith("0x")&&(t=t.slice(2)),`0x${t.padStart(ir*2,"0")}`}function gt(n,e=!1){return P(n,e)}function Sl(n){return/^(0x|0X)?[a-fA-F0-9]+$/.test(n)&&n.length%2===0}function kl(n){return/^(0x|0X)/.test(n)?(n.length-2)/2:n.length/2}BigInt(1e9);const Ol="0x1",eo="0x2";gt("0x6");const Il=`${eo}::sui::SUI`;gt("0x5");const $l=/^vector<(.+)>$/,El=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;let Yn=class cn{static parseFromStr(e,t=!1){if(e==="address")return{address:null};if(e==="bool")return{bool:null};if(e==="u8")return{u8:null};if(e==="u16")return{u16:null};if(e==="u32")return{u32:null};if(e==="u64")return{u64:null};if(e==="u128")return{u128:null};if(e==="u256")return{u256:null};if(e==="signer")return{signer:null};const r=e.match($l);if(r)return{vector:cn.parseFromStr(r[1],t)};const s=e.match(El);if(s)return{struct:{address:t?P(s[1]):s[1],module:s[2],name:s[3],typeParams:s[5]===void 0?[]:cn.parseStructTypeArgs(s[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return Ka(e).map(r=>cn.parseFromStr(r,t))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${cn.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(cn.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}};function Tl(n){return o.u64({name:"unsafe_u64",...n}).transform({input:e=>e,output:e=>Number(e)})}function Ml(n){return o.enum("Option",{None:null,Some:n})}const B=o.bytes(ir).transform({validate:n=>{const e=typeof n=="string"?n:Qt(n);if(!e||!Ne(P(e)))throw new Error(`Invalid Sui address ${e}`)},input:n=>typeof n=="string"?$i(P(n)):n,output:n=>P(Qt(n))}),Ve=o.vector(o.u8()).transform({name:"ObjectDigest",input:n=>Qn(n),output:n=>us(new Uint8Array(n)),validate:n=>{if(Qn(n).length!==32)throw new Error("ObjectDigest must be 32 bytes")}}),ke=o.struct("SuiObjectRef",{objectId:B,version:o.u64(),digest:Ve}),to=o.struct("SharedObjectRef",{objectId:B,initialSharedVersion:o.u64(),mutable:o.bool()}),no=o.enum("ObjectArg",{ImmOrOwnedObject:ke,SharedObject:to,Receiving:ke}),Wt=o.enum("Owner",{AddressOwner:B,ObjectOwner:B,Shared:o.struct("Shared",{initialSharedVersion:o.u64()}),Immutable:null,ConsensusAddressOwner:o.struct("ConsensusAddressOwner",{owner:B,startVersion:o.u64()})}),ro=o.enum("CallArg",{Pure:o.struct("Pure",{bytes:o.vector(o.u8()).transform({input:n=>typeof n=="string"?se(n):n,output:n=>F(new Uint8Array(n))})}),Object:no}),Ti=o.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:o.lazy(()=>Ti),struct:o.lazy(()=>uo),u16:null,u32:null,u256:null}),Mi=Ti.transform({input:n=>typeof n=="string"?Yn.parseFromStr(n,!0):n,output:n=>Yn.tagToString(n)}),Je=o.enum("Argument",{GasCoin:null,Input:o.u16(),Result:o.u16(),NestedResult:o.tuple([o.u16(),o.u16()])}),so=o.struct("ProgrammableMoveCall",{package:B,module:o.string(),function:o.string(),typeArguments:o.vector(Mi),arguments:o.vector(Je)}),io=o.enum("Command",{MoveCall:so,TransferObjects:o.struct("TransferObjects",{objects:o.vector(Je),address:Je}),SplitCoins:o.struct("SplitCoins",{coin:Je,amounts:o.vector(Je)}),MergeCoins:o.struct("MergeCoins",{destination:Je,sources:o.vector(Je)}),Publish:o.struct("Publish",{modules:o.vector(o.vector(o.u8()).transform({input:n=>typeof n=="string"?se(n):n,output:n=>F(new Uint8Array(n))})),dependencies:o.vector(B)}),MakeMoveVec:o.struct("MakeMoveVec",{type:Ml(Mi).transform({input:n=>n===null?{None:!0}:{Some:n},output:n=>n.Some??null}),elements:o.vector(Je)}),Upgrade:o.struct("Upgrade",{modules:o.vector(o.vector(o.u8()).transform({input:n=>typeof n=="string"?se(n):n,output:n=>F(new Uint8Array(n))})),dependencies:o.vector(B),package:B,ticket:Je})}),ao=o.struct("ProgrammableTransaction",{inputs:o.vector(ro),commands:o.vector(io)}),oo=o.enum("TransactionKind",{ProgrammableTransaction:ao,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),co=o.enum("TransactionExpiration",{None:null,Epoch:Tl()}),uo=o.struct("StructTag",{address:B,module:o.string(),name:o.string(),typeParams:o.vector(Ti)}),lo=o.struct("GasData",{payment:o.vector(ke),owner:B,price:o.u64(),budget:o.u64()}),ho=o.struct("TransactionDataV1",{kind:oo,sender:B,gasData:lo,expiration:co}),po=o.enum("TransactionData",{V1:ho}),go=o.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),fo=o.enum("IntentVersion",{V0:null}),mo=o.enum("AppId",{Sui:null}),yo=o.struct("Intent",{scope:go,version:fo,appId:mo});function wo(n){return o.struct(`IntentMessage<${n.name}>`,{intent:yo,value:n})}const bo=o.enum("CompressedSignature",{ED25519:o.fixedArray(64,o.u8()),Secp256k1:o.fixedArray(64,o.u8()),Secp256r1:o.fixedArray(64,o.u8()),ZkLogin:o.vector(o.u8()),Passkey:o.vector(o.u8())}),vo=o.enum("PublicKey",{ED25519:o.fixedArray(32,o.u8()),Secp256k1:o.fixedArray(33,o.u8()),Secp256r1:o.fixedArray(33,o.u8()),ZkLogin:o.vector(o.u8()),Passkey:o.fixedArray(33,o.u8())}),So=o.struct("MultiSigPkMap",{pubKey:vo,weight:o.u8()}),ko=o.struct("MultiSigPublicKey",{pk_map:o.vector(So),threshold:o.u16()}),jl=o.struct("MultiSig",{sigs:o.vector(bo),bitmap:o.u16(),multisig_pk:ko}),Cl=o.vector(o.u8()).transform({input:n=>typeof n=="string"?se(n):n,output:n=>F(new Uint8Array(n))}),Oo=o.struct("SenderSignedTransaction",{intentMessage:wo(po),txSignatures:o.vector(Cl)}),Al=o.vector(Oo,{name:"SenderSignedData"}),_l=o.struct("PasskeyAuthenticator",{authenticatorData:o.vector(o.u8()),clientDataJson:o.string(),userSignature:o.vector(o.u8())}),Pl=o.enum("PackageUpgradeError",{UnableToFetchPackage:o.struct("UnableToFetchPackage",{packageId:B}),NotAPackage:o.struct("NotAPackage",{objectId:B}),IncompatibleUpgrade:null,DigestDoesNotMatch:o.struct("DigestDoesNotMatch",{digest:o.vector(o.u8())}),UnknownUpgradePolicy:o.struct("UnknownUpgradePolicy",{policy:o.u8()}),PackageIDDoesNotMatch:o.struct("PackageIDDoesNotMatch",{packageId:B,ticketId:B})}),xl=o.struct("ModuleId",{address:B,name:o.string()}),ra=o.struct("MoveLocation",{module:xl,function:o.u16(),instruction:o.u16(),functionName:o.option(o.string())}),Nl=o.enum("CommandArgumentError",{TypeMismatch:null,InvalidBCSBytes:null,InvalidUsageOfPureArg:null,InvalidArgumentToPrivateEntryFunction:null,IndexOutOfBounds:o.struct("IndexOutOfBounds",{idx:o.u16()}),SecondaryIndexOutOfBounds:o.struct("SecondaryIndexOutOfBounds",{resultIdx:o.u16(),secondaryIdx:o.u16()}),InvalidResultArity:o.struct("InvalidResultArity",{resultIdx:o.u16()}),InvalidGasCoinUsage:null,InvalidValueUsage:null,InvalidObjectByValue:null,InvalidObjectByMutRef:null,SharedObjectOperationNotAllowed:null}),Ul=o.enum("TypeArgumentError",{TypeNotFound:null,ConstraintNotSatisfied:null}),Rl=o.enum("ExecutionFailureStatus",{InsufficientGas:null,InvalidGasObject:null,InvariantViolation:null,FeatureNotYetSupported:null,MoveObjectTooBig:o.struct("MoveObjectTooBig",{objectSize:o.u64(),maxObjectSize:o.u64()}),MovePackageTooBig:o.struct("MovePackageTooBig",{objectSize:o.u64(),maxObjectSize:o.u64()}),CircularObjectOwnership:o.struct("CircularObjectOwnership",{object:B}),InsufficientCoinBalance:null,CoinBalanceOverflow:null,PublishErrorNonZeroAddress:null,SuiMoveVerificationError:null,MovePrimitiveRuntimeError:o.option(ra),MoveAbort:o.tuple([ra,o.u64()]),VMVerificationOrDeserializationError:null,VMInvariantViolation:null,FunctionNotFound:null,ArityMismatch:null,TypeArityMismatch:null,NonEntryFunctionInvoked:null,CommandArgumentError:o.struct("CommandArgumentError",{argIdx:o.u16(),kind:Nl}),TypeArgumentError:o.struct("TypeArgumentError",{argumentIdx:o.u16(),kind:Ul}),UnusedValueWithoutDrop:o.struct("UnusedValueWithoutDrop",{resultIdx:o.u16(),secondaryIdx:o.u16()}),InvalidPublicFunctionReturnType:o.struct("InvalidPublicFunctionReturnType",{idx:o.u16()}),InvalidTransferObject:null,EffectsTooLarge:o.struct("EffectsTooLarge",{currentSize:o.u64(),maxSize:o.u64()}),PublishUpgradeMissingDependency:null,PublishUpgradeDependencyDowngrade:null,PackageUpgradeError:o.struct("PackageUpgradeError",{upgradeError:Pl}),WrittenObjectsTooLarge:o.struct("WrittenObjectsTooLarge",{currentSize:o.u64(),maxSize:o.u64()}),CertificateDenied:null,SuiMoveVerificationTimedout:null,SharedObjectOperationNotAllowed:null,InputObjectDeleted:null,ExecutionCancelledDueToSharedObjectCongestion:o.struct("ExecutionCancelledDueToSharedObjectCongestion",{congestedObjects:o.vector(B)}),AddressDeniedForCoin:o.struct("AddressDeniedForCoin",{address:B,coinType:o.string()}),CoinTypeGlobalPause:o.struct("CoinTypeGlobalPause",{coinType:o.string()}),ExecutionCancelledDueToRandomnessUnavailable:null}),Io=o.enum("ExecutionStatus",{Success:null,Failed:o.struct("ExecutionFailed",{error:Rl,command:o.option(o.u64())})}),$o=o.struct("GasCostSummary",{computationCost:o.u64(),storageCost:o.u64(),storageRebate:o.u64(),nonRefundableStorageFee:o.u64()}),Bl=o.struct("TransactionEffectsV1",{status:Io,executedEpoch:o.u64(),gasUsed:$o,modifiedAtVersions:o.vector(o.tuple([B,o.u64()])),sharedObjects:o.vector(ke),transactionDigest:Ve,created:o.vector(o.tuple([ke,Wt])),mutated:o.vector(o.tuple([ke,Wt])),unwrapped:o.vector(o.tuple([ke,Wt])),deleted:o.vector(ke),unwrappedThenDeleted:o.vector(ke),wrapped:o.vector(ke),gasObject:o.tuple([ke,Wt]),eventsDigest:o.option(Ve),dependencies:o.vector(Ve)}),ji=o.tuple([o.u64(),Ve]),Dl=o.enum("ObjectIn",{NotExist:null,Exist:o.tuple([ji,Wt])}),zl=o.enum("ObjectOut",{NotExist:null,ObjectWrite:o.tuple([Ve,Wt]),PackageWrite:ji}),Vl=o.enum("IDOperation",{None:null,Created:null,Deleted:null}),Ll=o.struct("EffectsObjectChange",{inputState:Dl,outputState:zl,idOperation:Vl}),Wl=o.enum("UnchangedSharedKind",{ReadOnlyRoot:ji,MutateDeleted:o.u64(),ReadDeleted:o.u64(),Cancelled:o.u64(),PerEpochConfig:null}),Fl=o.struct("TransactionEffectsV2",{status:Io,executedEpoch:o.u64(),gasUsed:$o,transactionDigest:Ve,gasObjectIndex:o.option(o.u32()),eventsDigest:o.option(Ve),dependencies:o.vector(Ve),lamportVersion:o.u64(),changedObjects:o.vector(o.tuple([B,Ll])),unchangedSharedObjects:o.vector(o.tuple([B,Wl])),auxDataDigest:o.option(Ve)}),Gl=o.enum("TransactionEffects",{V1:Bl,V2:Fl});function Fn(n){switch(n){case"u8":return o.u8();case"u16":return o.u16();case"u32":return o.u32();case"u64":return o.u64();case"u128":return o.u128();case"u256":return o.u256();case"bool":return o.bool();case"string":return o.string();case"id":case"address":return B}const e=n.match(/^(vector|option)<(.+)>$/);if(e){const[t,r]=e.slice(1);return t==="vector"?o.vector(Fn(r)):o.option(Fn(r))}throw new Error(`Invalid Pure type name: ${n}`)}const I={...o,U8:o.u8(),U16:o.u16(),U32:o.u32(),U64:o.u64(),U128:o.u128(),U256:o.u256(),ULEB128:o.uleb128(),Bool:o.bool(),String:o.string(),Address:B,AppId:mo,Argument:Je,CallArg:ro,Command:io,CompressedSignature:bo,GasData:lo,Intent:yo,IntentMessage:wo,IntentScope:go,IntentVersion:fo,MultiSig:jl,MultiSigPkMap:So,MultiSigPublicKey:ko,ObjectArg:no,ObjectDigest:Ve,Owner:Wt,PasskeyAuthenticator:_l,ProgrammableMoveCall:so,ProgrammableTransaction:ao,PublicKey:vo,SenderSignedData:Al,SenderSignedTransaction:Oo,SharedObjectRef:to,StructTag:uo,SuiObjectRef:ke,TransactionData:po,TransactionDataV1:ho,TransactionEffects:Gl,TransactionExpiration:co,TransactionKind:oo,TypeTag:Mi};function Kl(n,e,t){const r=I.Address.serialize(n).toBytes(),s=I.TypeTag.serialize(e).toBytes(),i=I.u64().serialize(t.length).toBytes(),a=Fe.create({dkLen:32});return a.update(new Uint8Array([240])),a.update(r),a.update(i),a.update(t),a.update(s),`0x${Qt(a.digest().slice(0,32))}`}const ql="object",Jl="ID",Zl="ascii",Hl="String",Ql="string",Yl="String",Xl="option",ed="Option";function td(n){const e=typeof n.body=="object"&&"datatype"in n.body?n.body.datatype:null;return!!e&&P(e.package)===P("0x2")&&e.module==="tx_context"&&e.type==="TxContext"}function Rs(n){if(typeof n=="string")switch(n){case"address":return I.Address;case"bool":return I.Bool;case"u8":return I.U8;case"u16":return I.U16;case"u32":return I.U32;case"u64":return I.U64;case"u128":return I.U128;case"u256":return I.U256;default:throw new Error(`Unknown type signature ${n}`)}if("vector"in n){if(n.vector==="u8")return I.vector(I.U8).transform({input:t=>typeof t=="string"?new TextEncoder().encode(t):t,output:t=>t});const e=Rs(n.vector);return e?I.vector(e):null}if("datatype"in n){const e=P(n.datatype.package);if(e===P(Ol)){if(n.datatype.module===Zl&&n.datatype.type===Hl||n.datatype.module===Ql&&n.datatype.type===Yl)return I.String;if(n.datatype.module===Xl&&n.datatype.type===ed){const t=Rs(n.datatype.typeParameters[0]);return t?I.vector(t):null}}if(e===P(eo)&&n.datatype.module===ql&&n.datatype.type===Jl)return I.Address}return null}function nd(n){return typeof n=="object"&&"Reference"in n?{ref:"&",body:Gn(n.Reference)}:typeof n=="object"&&"MutableReference"in n?{ref:"&mut",body:Gn(n.MutableReference)}:{ref:null,body:Gn(n)}}function Gn(n){if(typeof n=="string")switch(n){case"Address":return"address";case"Bool":return"bool";case"U8":return"u8";case"U16":return"u16";case"U32":return"u32";case"U64":return"u64";case"U128":return"u128";case"U256":return"u256";default:throw new Error(`Unexpected type ${n}`)}if("Vector"in n)return{vector:Gn(n.Vector)};if("Struct"in n)return{datatype:{package:n.Struct.address,module:n.Struct.module,type:n.Struct.name,typeParameters:n.Struct.typeArguments.map(Gn)}};if("TypeParameter"in n)return{typeParameter:n.TypeParameter};throw new Error(`Unexpected type ${JSON.stringify(n)}`)}function rd(n){return{$kind:"Pure",Pure:{bytes:n instanceof Uint8Array?F(n):n.toBase64()}}}const we={Pure:rd,ObjectRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"ImmOrOwnedObject",ImmOrOwnedObject:{digest:e,version:t,objectId:P(n)}}}},SharedObjectRef({objectId:n,mutable:e,initialSharedVersion:t}){return{$kind:"Object",Object:{$kind:"SharedObject",SharedObject:{mutable:e,initialSharedVersion:t,objectId:P(n)}}}},ReceivingRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"Receiving",Receiving:{digest:e,version:t,objectId:P(n)}}}}};function nn(n){const e=Object.entries(n).map(([t,r])=>l({[t]:r}));return S(_(e),vn(t=>({...t,$kind:Object.keys(t)[0]})))}const Sn=S(f(),vn(n=>P(n)),xt(Ne)),be=Sn,Xt=f(),he=S(_([f(),S(E(),T())]),xt(n=>{try{return BigInt(n),BigInt(n)>=0&&BigInt(n)<=18446744073709551615n}catch{return!1}},"Invalid u64")),_t=l({objectId:Sn,version:he,digest:f()}),V=S(_([l({GasCoin:p(!0)}),l({Input:S(E(),T()),type:C(p("pure"))}),l({Input:S(E(),T()),type:C(p("object"))}),l({Result:S(E(),T())}),l({NestedResult:os([S(E(),T()),S(E(),T())])})]),vn(n=>({...n,$kind:Object.keys(n)[0]}))),sd=l({budget:v(he),price:v(he),owner:v(Sn),payment:v(g(_t))}),Bs=_([p("address"),p("bool"),p("u8"),p("u16"),p("u32"),p("u64"),p("u128"),p("u256"),l({vector:Ct(()=>Bs)}),l({datatype:l({package:f(),module:f(),type:f(),typeParameters:g(Ct(()=>Bs))})}),l({typeParameter:S(E(),T())})]),id=l({ref:v(_([p("&"),p("&mut")])),body:Bs}),ad=l({package:be,module:f(),function:f(),typeArguments:g(f()),arguments:g(V),_argumentTypes:C(v(g(id)))}),od=l({name:f(),inputs:At(f(),_([V,g(V)])),data:At(f(),je())}),cd=nn({MoveCall:ad,TransferObjects:l({objects:g(V),address:V}),SplitCoins:l({coin:V,amounts:g(V)}),MergeCoins:l({destination:V,sources:g(V)}),Publish:l({modules:g(Xt),dependencies:g(be)}),MakeMoveVec:l({type:v(f()),elements:g(V)}),Upgrade:l({modules:g(Xt),dependencies:g(be),package:be,ticket:V}),$Intent:od}),Eo=nn({ImmOrOwnedObject:_t,SharedObject:l({objectId:be,initialSharedVersion:he,mutable:bt()}),Receiving:_t}),ud=nn({Object:Eo,Pure:l({bytes:Xt}),UnresolvedPure:l({value:je()}),UnresolvedObject:l({objectId:be,version:C(v(he)),digest:C(v(f())),initialSharedVersion:C(v(he))})}),sa=nn({Object:Eo,Pure:l({bytes:Xt})}),To=nn({None:p(!0),Epoch:he}),yr=l({version:p(2),sender:tt(Sn),expiration:tt(To),gasData:sd,inputs:g(ud),commands:g(cd)}),Nt={MoveCall(n){const[e,t="",r=""]="target"in n?n.target.split("::"):[n.package,n.module,n.function];return{$kind:"MoveCall",MoveCall:{package:e,module:t,function:r,typeArguments:n.typeArguments??[],arguments:n.arguments??[]}}},TransferObjects(n,e){return{$kind:"TransferObjects",TransferObjects:{objects:n.map(t=>$(V,t)),address:$(V,e)}}},SplitCoins(n,e){return{$kind:"SplitCoins",SplitCoins:{coin:$(V,n),amounts:e.map(t=>$(V,t))}}},MergeCoins(n,e){return{$kind:"MergeCoins",MergeCoins:{destination:$(V,n),sources:e.map(t=>$(V,t))}}},Publish({modules:n,dependencies:e}){return{$kind:"Publish",Publish:{modules:n.map(t=>typeof t=="string"?t:F(new Uint8Array(t))),dependencies:e.map(t=>gt(t))}}},Upgrade({modules:n,dependencies:e,package:t,ticket:r}){return{$kind:"Upgrade",Upgrade:{modules:n.map(s=>typeof s=="string"?s:F(new Uint8Array(s))),dependencies:e.map(s=>gt(s)),package:t,ticket:$(V,r)}}},MakeMoveVec({type:n,elements:e}){return{$kind:"MakeMoveVec",MakeMoveVec:{type:n??null,elements:e.map(t=>$(V,t))}}},Intent({name:n,inputs:e={},data:t={}}){return{$kind:"$Intent",$Intent:{name:n,inputs:Object.fromEntries(Object.entries(e).map(([r,s])=>[r,Array.isArray(s)?s.map(i=>$(V,i)):$(V,s)])),data:t}}}},Ds=l({digest:f(),objectId:f(),version:_([S(E(),T()),f(),cs()])}),ld=nn({ImmOrOwned:Ds,Shared:l({objectId:be,initialSharedVersion:he,mutable:bt()}),Receiving:Ds}),ia=nn({Object:ld,Pure:g(S(E(),T()))}),Mo=_([l({kind:p("Input"),index:S(E(),T()),value:je(),type:C(p("object"))}),l({kind:p("Input"),index:S(E(),T()),value:je(),type:p("pure")})]),dd=_([l({Epoch:S(E(),T())}),l({None:v(p(!0))})]),aa=S(_([E(),f(),cs()]),xt(n=>{if(!["string","number","bigint"].includes(typeof n))return!1;try{return BigInt(n),!0}catch{return!1}})),Ci=_([l({bool:v(p(!0))}),l({u8:v(p(!0))}),l({u64:v(p(!0))}),l({u128:v(p(!0))}),l({address:v(p(!0))}),l({signer:v(p(!0))}),l({vector:Ct(()=>Ci)}),l({struct:Ct(()=>hd)}),l({u16:v(p(!0))}),l({u32:v(p(!0))}),l({u256:v(p(!0))})]),hd=l({address:f(),module:f(),name:f(),typeParams:g(Ci)}),pd=l({budget:C(aa),price:C(aa),payment:C(g(Ds)),owner:C(f())}),gd=[Mo,l({kind:p("GasCoin")}),l({kind:p("Result"),index:S(E(),T())}),l({kind:p("NestedResult"),index:S(E(),T()),resultIndex:S(E(),T())})],ft=_([...gd]),fd=l({kind:p("MoveCall"),target:S(f(),xt(n=>n.split("::").length===3)),typeArguments:g(f()),arguments:g(ft)}),md=l({kind:p("TransferObjects"),objects:g(ft),address:ft}),yd=l({kind:p("SplitCoins"),coin:ft,amounts:g(ft)}),wd=l({kind:p("MergeCoins"),destination:ft,sources:g(ft)}),bd=l({kind:p("MakeMoveVec"),type:_([l({Some:Ci}),l({None:v(p(!0))})]),objects:g(ft)}),vd=l({kind:p("Publish"),modules:g(g(S(E(),T()))),dependencies:g(f())}),Sd=l({kind:p("Upgrade"),modules:g(g(S(E(),T()))),dependencies:g(f()),packageId:f(),ticket:ft}),kd=[fd,md,yd,wd,vd,Sd,bd],Od=_([...kd]);l({version:p(1),sender:C(f()),expiration:tt(dd),gasConfig:pd,inputs:g(Mo),transactions:g(Od)});function oa(n){const e=n.inputs.map((t,r)=>{if(t.Object)return{kind:"Input",index:r,value:{Object:t.Object.ImmOrOwnedObject?{ImmOrOwned:t.Object.ImmOrOwnedObject}:t.Object.Receiving?{Receiving:{digest:t.Object.Receiving.digest,version:t.Object.Receiving.version,objectId:t.Object.Receiving.objectId}}:{Shared:{mutable:t.Object.SharedObject.mutable,initialSharedVersion:t.Object.SharedObject.initialSharedVersion,objectId:t.Object.SharedObject.objectId}}},type:"object"};if(t.Pure)return{kind:"Input",index:r,value:{Pure:Array.from(se(t.Pure.bytes))},type:"pure"};if(t.UnresolvedPure)return{kind:"Input",type:"pure",index:r,value:t.UnresolvedPure.value};if(t.UnresolvedObject)return{kind:"Input",type:"object",index:r,value:t.UnresolvedObject.objectId};throw new Error("Invalid input")});return{version:1,sender:n.sender??void 0,expiration:n.expiration?.$kind==="Epoch"?{Epoch:Number(n.expiration.Epoch)}:n.expiration?{None:!0}:null,gasConfig:{owner:n.gasData.owner??void 0,budget:n.gasData.budget??void 0,price:n.gasData.price??void 0,payment:n.gasData.payment??void 0},inputs:e,transactions:n.commands.map(t=>{if(t.MakeMoveVec)return{kind:"MakeMoveVec",type:t.MakeMoveVec.type===null?{None:!0}:{Some:Yn.parseFromStr(t.MakeMoveVec.type)},objects:t.MakeMoveVec.elements.map(r=>it(r,e))};if(t.MergeCoins)return{kind:"MergeCoins",destination:it(t.MergeCoins.destination,e),sources:t.MergeCoins.sources.map(r=>it(r,e))};if(t.MoveCall)return{kind:"MoveCall",target:`${t.MoveCall.package}::${t.MoveCall.module}::${t.MoveCall.function}`,typeArguments:t.MoveCall.typeArguments,arguments:t.MoveCall.arguments.map(r=>it(r,e))};if(t.Publish)return{kind:"Publish",modules:t.Publish.modules.map(r=>Array.from(se(r))),dependencies:t.Publish.dependencies};if(t.SplitCoins)return{kind:"SplitCoins",coin:it(t.SplitCoins.coin,e),amounts:t.SplitCoins.amounts.map(r=>it(r,e))};if(t.TransferObjects)return{kind:"TransferObjects",objects:t.TransferObjects.objects.map(r=>it(r,e)),address:it(t.TransferObjects.address,e)};if(t.Upgrade)return{kind:"Upgrade",modules:t.Upgrade.modules.map(r=>Array.from(se(r))),dependencies:t.Upgrade.dependencies,packageId:t.Upgrade.package,ticket:it(t.Upgrade.ticket,e)};throw new Error(`Unknown transaction ${Object.keys(t)}`)})}}function it(n,e){if(n.$kind==="GasCoin")return{kind:"GasCoin"};if(n.$kind==="Result")return{kind:"Result",index:n.Result};if(n.$kind==="NestedResult")return{kind:"NestedResult",index:n.NestedResult[0],resultIndex:n.NestedResult[1]};if(n.$kind==="Input")return e[n.Input];throw new Error(`Invalid argument ${Object.keys(n)}`)}function Id(n){return $(yr,{version:2,sender:n.sender??null,expiration:n.expiration?"Epoch"in n.expiration?{Epoch:n.expiration.Epoch}:{None:!0}:null,gasData:{owner:n.gasConfig.owner??null,budget:n.gasConfig.budget?.toString()??null,price:n.gasConfig.price?.toString()??null,payment:n.gasConfig.payment?.map(e=>({digest:e.digest,objectId:e.objectId,version:e.version.toString()}))??null},inputs:n.inputs.map(e=>{if(e.kind==="Input"){if(yn(ia,e.value)){const t=$(ia,e.value);if(t.Object){if(t.Object.ImmOrOwned)return{Object:{ImmOrOwnedObject:{objectId:t.Object.ImmOrOwned.objectId,version:String(t.Object.ImmOrOwned.version),digest:t.Object.ImmOrOwned.digest}}};if(t.Object.Shared)return{Object:{SharedObject:{mutable:t.Object.Shared.mutable??null,initialSharedVersion:t.Object.Shared.initialSharedVersion,objectId:t.Object.Shared.objectId}}};if(t.Object.Receiving)return{Object:{Receiving:{digest:t.Object.Receiving.digest,version:String(t.Object.Receiving.version),objectId:t.Object.Receiving.objectId}}};throw new Error("Invalid object input")}return{Pure:{bytes:F(new Uint8Array(t.Pure))}}}return e.type==="object"?{UnresolvedObject:{objectId:e.value}}:{UnresolvedPure:{value:e.value}}}throw new Error("Invalid input")}),commands:n.transactions.map(e=>{switch(e.kind){case"MakeMoveVec":return{MakeMoveVec:{type:"Some"in e.type?Yn.tagToString(e.type.Some):null,elements:e.objects.map(t=>at(t))}};case"MergeCoins":return{MergeCoins:{destination:at(e.destination),sources:e.sources.map(t=>at(t))}};case"MoveCall":{const[t,r,s]=e.target.split("::");return{MoveCall:{package:t,module:r,function:s,typeArguments:e.typeArguments,arguments:e.arguments.map(i=>at(i))}}}case"Publish":return{Publish:{modules:e.modules.map(t=>F(Uint8Array.from(t))),dependencies:e.dependencies}};case"SplitCoins":return{SplitCoins:{coin:at(e.coin),amounts:e.amounts.map(t=>at(t))}};case"TransferObjects":return{TransferObjects:{objects:e.objects.map(t=>at(t)),address:at(e.address)}};case"Upgrade":return{Upgrade:{modules:e.modules.map(t=>F(Uint8Array.from(t))),dependencies:e.dependencies,package:e.packageId,ticket:at(e.ticket)}}}throw new Error(`Unknown transaction ${Object.keys(e)}`)})})}function at(n){switch(n.kind){case"GasCoin":return{GasCoin:!0};case"Result":return{Result:n.index};case"NestedResult":return{NestedResult:[n.index,n.resultIndex]};case"Input":return{Input:n.index}}}function ar(n){return _(Object.entries(n).map(([e,t])=>l({[e]:t})))}const _e=ar({GasCoin:p(!0),Input:S(E(),T()),Result:S(E(),T()),NestedResult:os([S(E(),T()),S(E(),T())])}),$d=l({budget:v(he),price:v(he),owner:v(Sn),payment:v(g(_t))}),Ed=l({package:be,module:f(),function:f(),typeArguments:g(f()),arguments:g(_e)}),Td=l({name:f(),inputs:At(f(),_([_e,g(_e)])),data:At(f(),je())}),Md=ar({MoveCall:Ed,TransferObjects:l({objects:g(_e),address:_e}),SplitCoins:l({coin:_e,amounts:g(_e)}),MergeCoins:l({destination:_e,sources:g(_e)}),Publish:l({modules:g(Xt),dependencies:g(be)}),MakeMoveVec:l({type:v(f()),elements:g(_e)}),Upgrade:l({modules:g(Xt),dependencies:g(be),package:be,ticket:_e}),$Intent:Td}),jd=ar({ImmOrOwnedObject:_t,SharedObject:l({objectId:be,initialSharedVersion:he,mutable:bt()}),Receiving:_t}),Cd=ar({Object:jd,Pure:l({bytes:Xt}),UnresolvedPure:l({value:je()}),UnresolvedObject:l({objectId:be,version:C(v(he)),digest:C(v(f())),initialSharedVersion:C(v(he))})}),Ad=ar({None:p(!0),Epoch:he}),_d=l({version:p(2),sender:tt(Sn),expiration:tt(Ad),gasData:$d,inputs:g(Cd),commands:g(Md),digest:C(v(f()))}),Pd=50,xd=1000n,Nd=5e10;function jo(n){return async function(t,r,s){return await zd(t,n),await Dd(t,n),r.onlyTransactionKind||(await Ud(t,n),await Rd(t,n),await Bd(t,n)),await s()}}async function Ud(n,e){n.gasConfig.price||(n.gasConfig.price=String(await e.getReferenceGasPrice()))}async function Rd(n,e){if(n.gasConfig.budget)return;const t=await e.dryRunTransactionBlock({transactionBlock:n.build({overrides:{gasData:{budget:String(Nd),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=xd*BigInt(n.gasConfig.price||1n),s=BigInt(t.effects.gasUsed.computationCost)+r,i=s+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);n.gasConfig.budget=String(i>s?i:s)}async function Bd(n,e){if(!n.gasConfig.payment){const r=(await e.getCoins({owner:n.gasConfig.owner||n.sender,coinType:Il})).data.filter(s=>!n.inputs.find(a=>a.Object?.ImmOrOwnedObject?s.coinObjectId===a.Object.ImmOrOwnedObject.objectId:!1)).map(s=>({objectId:s.coinObjectId,digest:s.digest,version:s.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");n.gasConfig.payment=r.map(s=>$(_t,s))}}async function Dd(n,e){const t=n.inputs.filter(h=>h.UnresolvedObject&&!(h.UnresolvedObject.version||h.UnresolvedObject?.initialSharedVersion)),r=[...new Set(t.map(h=>gt(h.UnresolvedObject.objectId)))],s=r.length?ls(r,Pd):[],i=(await Promise.all(s.map(h=>e.multiGetObjects({ids:h,options:{showOwner:!0}})))).flat(),a=new Map(r.map((h,w)=>[h,i[w]])),u=Array.from(a).filter(([h,w])=>w.error).map(([h,w])=>JSON.stringify(w.error));if(u.length)throw new Error(`The following input objects are invalid: ${u.join(", ")}`);const d=i.map(h=>{if(h.error||!h.data)throw new Error(`Failed to fetch object: ${h.error}`);const w=h.data.owner,j=w&&typeof w=="object"?"Shared"in w?w.Shared.initial_shared_version:"ConsensusAddressOwner"in w?w.ConsensusAddressOwner.start_version:null:null;return{objectId:h.data.objectId,digest:h.data.digest,version:h.data.version,initialSharedVersion:j}}),b=new Map(r.map((h,w)=>[h,d[w]]));for(const[h,w]of n.inputs.entries()){if(!w.UnresolvedObject)continue;let j;const G=P(w.UnresolvedObject.objectId),x=b.get(G);w.UnresolvedObject.initialSharedVersion??x?.initialSharedVersion?j=we.SharedObjectRef({objectId:G,initialSharedVersion:w.UnresolvedObject.initialSharedVersion||x?.initialSharedVersion,mutable:Vd(n,h)}):Ld(n,h)&&(j=we.ReceivingRef({objectId:G,digest:w.UnresolvedObject.digest??x?.digest,version:w.UnresolvedObject.version??x?.version})),n.inputs[n.inputs.indexOf(w)]=j??we.ObjectRef({objectId:G,digest:w.UnresolvedObject.digest??x?.digest,version:w.UnresolvedObject.version??x?.version})}}async function zd(n,e){const{inputs:t,commands:r}=n,s=[],i=new Set;r.forEach(u=>{if(u.MoveCall){if(u.MoveCall._argumentTypes)return;if(u.MoveCall.arguments.map(h=>h.$kind==="Input"?n.inputs[h.Input]:null).some(h=>h?.UnresolvedPure||h?.UnresolvedObject)){const h=`${u.MoveCall.package}::${u.MoveCall.module}::${u.MoveCall.function}`;i.add(h),s.push(u.MoveCall)}}});const a=new Map;i.size>0&&await Promise.all([...i].map(async u=>{const[d,b,h]=u.split("::"),w=await e.getNormalizedMoveFunction({package:d,module:b,function:h});a.set(u,w.parameters.map(j=>nd(j)))})),s.length&&await Promise.all(s.map(async u=>{const d=a.get(`${u.package}::${u.module}::${u.function}`);if(!d)return;const h=d.length>0&&td(d.at(-1))?d.slice(0,d.length-1):d;u._argumentTypes=h})),r.forEach(u=>{if(!u.MoveCall)return;const d=u.MoveCall,b=`${d.package}::${d.module}::${d.function}`,h=d._argumentTypes;if(h){if(h.length!==u.MoveCall.arguments.length)throw new Error(`Incorrect number of arguments for ${b}`);h.forEach((w,j)=>{const G=d.arguments[j];if(G.$kind!=="Input")return;const x=t[G.Input];if(!x.UnresolvedPure&&!x.UnresolvedObject)return;const st=x.UnresolvedPure?.value??x.UnresolvedObject?.objectId,In=Rs(w.body);if(In){G.type="pure",t[t.indexOf(x)]=we.Pure(In.serialize(st));return}if(typeof st!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(st,null,2)}`);G.type="object";const fs=x.UnresolvedPure?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:st}}:x;t[G.Input]=fs})}})}function Vd(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=s.MoveCall._argumentTypes[i].ref!=="&"||t}(s.$kind==="MakeMoveVec"||s.$kind==="MergeCoins"||s.$kind==="SplitCoins"||s.$kind==="TransferObjects")&&(t=!0)}),t}function Ld(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=Wd(s.MoveCall._argumentTypes[i])||t}}),t}function Wd(n){return typeof n.body!="object"||!("datatype"in n.body)?!1:n.body.datatype.package==="0x2"&&n.body.datatype.module==="transfer"&&n.body.datatype.type==="Receiving"}function Co(n,e){return!!(n.inputs.some(t=>t.UnresolvedObject||t.UnresolvedPure)||!e.onlyTransactionKind&&(!n.gasConfig.price||!n.gasConfig.budget||!n.gasConfig.payment))}async function Fd(n,e,t){if(Kd(n),!Co(n,e))return await ca(n),t();const r=Gd(e);return(r.core?.resolveTransactionPlugin()??jo(r))(n,e,async()=>{await ca(n),await t()})}function ca(n){n.inputs.forEach((e,t)=>{if(e.$kind!=="Object"&&e.$kind!=="Pure")throw new Error(`Input at index ${t} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(e)}`)})}function Gd(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}function Kd(n){for(const e of n.commands)switch(e.$kind){case"SplitCoins":e.SplitCoins.amounts.forEach(t=>{ua(t,I.U64,n)});break;case"TransferObjects":ua(e.TransferObjects.address,I.Address,n);break}}function ua(n,e,t){if(n.$kind!=="Input")return;const r=t.inputs[n.Input];r.$kind==="UnresolvedPure"&&(t.inputs[n.Input]=we.Pure(e.serialize(r.UnresolvedPure.value)))}function qd(n){function e(t){return n(t)}return e.system=t=>{const r=t?.mutable;return e(r!==void 0?we.SharedObjectRef({objectId:"0x5",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x5",initialSharedVersion:1}})},e.clock=()=>e(we.SharedObjectRef({objectId:"0x6",initialSharedVersion:1,mutable:!1})),e.random=()=>e(we.SharedObjectRef({objectId:"0x8",initialSharedVersion:1,mutable:!1})),e.denyList=t=>{const r=t?.mutable;return e(r!==void 0?we.SharedObjectRef({objectId:"0x403",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x403",initialSharedVersion:1}})},e.option=({type:t,value:r})=>s=>s.moveCall({typeArguments:[t],target:`0x1::option::${r===null?"none":"some"}`,arguments:r===null?[]:[s.object(r)]}),e}function Jd(n){function e(t,r){if(typeof t=="string")return n(Fn(t).serialize(r));if(t instanceof Uint8Array||Ei(t))return n(t);throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value")}return e.u8=t=>n(I.U8.serialize(t)),e.u16=t=>n(I.U16.serialize(t)),e.u32=t=>n(I.U32.serialize(t)),e.u64=t=>n(I.U64.serialize(t)),e.u128=t=>n(I.U128.serialize(t)),e.u256=t=>n(I.U256.serialize(t)),e.bool=t=>n(I.Bool.serialize(t)),e.string=t=>n(I.String.serialize(t)),e.address=t=>n(I.Address.serialize(t)),e.id=e.address,e.vector=(t,r)=>n(I.vector(Fn(t)).serialize(r)),e.option=(t,r)=>n(I.option(Fn(t)).serialize(r)),e}function Zd(n,e){const t=Array.from(`${n}::`).map(s=>s.charCodeAt(0)),r=new Uint8Array(t.length+e.length);return r.set(t),r.set(e,t.length),Fe(r,{dkLen:32})}function la(n){return P(n).replace("0x","")}let Lt=class Bt{constructor(e){this.version=2,this.sender=e?.sender??null,this.expiration=e?.expiration??null,this.inputs=e?.inputs??[],this.commands=e?.commands??[],this.gasData=e?.gasData??{budget:null,price:null,owner:null,payment:null}}static fromKindBytes(e){const r=I.TransactionKind.parse(e).ProgrammableTransaction;if(!r)throw new Error("Unable to deserialize from bytes.");return Bt.restore({version:2,sender:null,expiration:null,gasData:{budget:null,owner:null,payment:null,price:null},inputs:r.inputs,commands:r.commands})}static fromBytes(e){const r=I.TransactionData.parse(e)?.V1,s=r.kind.ProgrammableTransaction;if(!r||!s)throw new Error("Unable to deserialize from bytes.");return Bt.restore({version:2,sender:r.sender,expiration:r.expiration,gasData:r.gasData,inputs:s.inputs,commands:s.commands})}static restore(e){return e.version===2?new Bt($(yr,e)):new Bt($(yr,Id(e)))}static getDigestFromBytes(e){const t=Zd("TransactionData",e);return us(t)}get gasConfig(){return this.gasData}set gasConfig(e){this.gasData=e}build({maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}={}){const s=this.inputs,i=this.commands,a={ProgrammableTransaction:{inputs:s,commands:i}};if(r)return I.TransactionKind.serialize(a,{maxSize:e}).toBytes();const u=t?.expiration??this.expiration,d=t?.sender??this.sender,b={...this.gasData,...t?.gasConfig,...t?.gasData};if(!d)throw new Error("Missing transaction sender");if(!b.budget)throw new Error("Missing gas budget");if(!b.payment)throw new Error("Missing gas payment");if(!b.price)throw new Error("Missing gas price");const h={sender:la(d),expiration:u||{None:!0},gasData:{payment:b.payment,owner:la(this.gasData.owner??d),price:BigInt(b.price),budget:BigInt(b.budget)},kind:{ProgrammableTransaction:{inputs:s,commands:i}}};return I.TransactionData.serialize({V1:h},{maxSize:e}).toBytes()}addInput(e,t){const r=this.inputs.length;return this.inputs.push(t),{Input:r,type:e,$kind:"Input"}}getInputUses(e,t){this.mapArguments((r,s)=>(r.$kind==="Input"&&r.Input===e&&t(r,s),r))}mapCommandArguments(e,t){const r=this.commands[e];switch(r.$kind){case"MoveCall":r.MoveCall.arguments=r.MoveCall.arguments.map(i=>t(i,r,e));break;case"TransferObjects":r.TransferObjects.objects=r.TransferObjects.objects.map(i=>t(i,r,e)),r.TransferObjects.address=t(r.TransferObjects.address,r,e);break;case"SplitCoins":r.SplitCoins.coin=t(r.SplitCoins.coin,r,e),r.SplitCoins.amounts=r.SplitCoins.amounts.map(i=>t(i,r,e));break;case"MergeCoins":r.MergeCoins.destination=t(r.MergeCoins.destination,r,e),r.MergeCoins.sources=r.MergeCoins.sources.map(i=>t(i,r,e));break;case"MakeMoveVec":r.MakeMoveVec.elements=r.MakeMoveVec.elements.map(i=>t(i,r,e));break;case"Upgrade":r.Upgrade.ticket=t(r.Upgrade.ticket,r,e);break;case"$Intent":const s=r.$Intent.inputs;r.$Intent.inputs={};for(const[i,a]of Object.entries(s))r.$Intent.inputs[i]=Array.isArray(a)?a.map(u=>t(u,r,e)):t(a,r,e);break;case"Publish":break;default:throw new Error(`Unexpected transaction kind: ${r.$kind}`)}}mapArguments(e){for(const t of this.commands.keys())this.mapCommandArguments(t,e)}replaceCommand(e,t,r=e){if(!Array.isArray(t)){this.commands[e]=t;return}const s=t.length-1;this.commands.splice(e,1,...t),s!==0&&this.mapArguments((i,a,u)=>{if(u<e+t.length)return i;switch(i.$kind){case"Result":i.Result===e&&(i.Result=r),i.Result>e&&(i.Result+=s);break;case"NestedResult":i.NestedResult[0]===e&&(i.NestedResult[0]=r),i.NestedResult[0]>e&&(i.NestedResult[0]+=s);break}return i})}getDigest(){const e=this.build({onlyTransactionKind:!1});return Bt.getDigestFromBytes(e)}snapshot(){return $(yr,this)}shallowClone(){return new Bt({version:this.version,sender:this.sender,expiration:this.expiration,gasData:{...this.gasData},inputs:[...this.inputs],commands:[...this.commands]})}};function da(n){if(typeof n=="string")return P(n);if(n.Object)return n.Object.ImmOrOwnedObject?P(n.Object.ImmOrOwnedObject.objectId):n.Object.Receiving?P(n.Object.Receiving.objectId):P(n.Object.SharedObject.objectId);if(n.UnresolvedObject)return P(n.UnresolvedObject.objectId)}var Ao=n=>{throw TypeError(n)},_o=(n,e,t)=>e.has(n)||Ao("Cannot "+t),ee=(n,e,t)=>(_o(n,e,"read from private field"),e.get(n)),ha=(n,e,t)=>e.has(n)?Ao("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),pa=(n,e,t,r)=>(_o(n,e,"write to private field"),e.set(n,t),t),Dt,ae;const Hd=class Po{constructor({prefix:e,cache:t}={}){ha(this,Dt),ha(this,ae),pa(this,Dt,e??[]),pa(this,ae,t??new Map)}read(e,t){const r=[ee(this,Dt),...e].join(":");if(ee(this,ae).has(r))return ee(this,ae).get(r);const s=t();return ee(this,ae).set(r,s),typeof s=="object"&&s!==null&&"then"in s?Promise.resolve(s).then(i=>(ee(this,ae).set(r,i),i)).catch(i=>{throw ee(this,ae).delete(r),i}):s}readSync(e,t){const r=[ee(this,Dt),...e].join(":");if(ee(this,ae).has(r))return ee(this,ae).get(r);const s=t();return ee(this,ae).set(r,s),s}clear(e){const t=[...ee(this,Dt),...e??[]].join(":");if(!t){ee(this,ae).clear();return}for(const r of ee(this,ae).keys())r.startsWith(t)&&ee(this,ae).delete(r)}scope(e){return new Po({prefix:[...ee(this,Dt),...Array.isArray(e)?e:[e]],cache:ee(this,ae)})}};Dt=new WeakMap;ae=new WeakMap;let Qd=Hd;const xo="1.37.5",Yd="1.56.0";var No=n=>{throw TypeError(n)},Ai=(n,e,t)=>e.has(n)||No("Cannot "+t),Q=(n,e,t)=>(Ai(n,e,"read from private field"),t?t.call(n):e.get(n)),$n=(n,e,t)=>e.has(n)?No("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),ur=(n,e,t,r)=>(Ai(n,e,"write to private field"),e.set(n,t),t),ds=(n,e,t)=>(Ai(n,e,"access private method"),t),Xn,mt,er,$t,He,zs,Vs,Uo,Ro,_i;const Xd="/",eh={"Mvr-Source":`@mysten/sui@${xo}`};let th=class{constructor({cache:e,url:t,pageSize:r=50,overrides:s}){$n(this,He),$n(this,Xn),$n(this,mt),$n(this,er),$n(this,$t),ur(this,Xn,e),ur(this,mt,t),ur(this,er,r),ur(this,$t,{packages:s?.packages,types:s?.types}),nh(Q(this,$t))}async resolvePackage({package:e}){return{package:await Q(this,He,zs).load(e)}}async resolveType({type:e}){const t=[...Ls(e)],r=await Q(this,He,Vs).loadMany(t),s={};for(let i=0;i<t.length;i++){const a=r[i];if(a instanceof Error)throw a;s[t[i]]=a}return{type:Ws(e,s)}}async resolve({types:e=[],packages:t=[]}){const r=new Set;for(const h of e??[])Ls(h,r);const s=[...r],[i,a]=await Promise.all([s.length>0?Q(this,He,Vs).loadMany(s):[],t.length>0?Q(this,He,zs).loadMany(t):[]]),u={...Q(this,$t)?.types};for(const[h,w]of s.entries()){const j=i[h];if(j instanceof Error)throw j;u[w]=j}const d={};for(const h of e??[]){const w=Ws(h,u);d[h]={type:w}}const b={};for(const[h,w]of(t??[]).entries()){const j=Q(this,$t)?.packages?.[w]??a[h];if(j instanceof Error)throw j;b[w]={package:j}}return{types:d,packages:b}}};Xn=new WeakMap;mt=new WeakMap;er=new WeakMap;$t=new WeakMap;He=new WeakSet;zs=function(){return Q(this,Xn).readSync(["#mvrPackageDataLoader",Q(this,mt)??""],()=>{const n=new Fa(async t=>{if(!Q(this,mt))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await ds(this,He,Uo).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve package: ${s}`))}),e=Q(this,$t)?.packages;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})};Vs=function(){return Q(this,Xn).readSync(["#mvrTypeDataLoader",Q(this,mt)??""],()=>{const n=new Fa(async t=>{if(!Q(this,mt))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await ds(this,He,Ro).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve type: ${s}`))}),e=Q(this,$t)?.types;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})};Uo=async function(n){if(n.length===0)return{};const e=ls(n,Q(this,er)),t={};return await Promise.all(e.map(async r=>{const s=await ds(this,He,_i).call(this,"/v1/resolution/bulk",{names:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.package_id;a&&(t[i]=a)}})),t};Ro=async function(n){if(n.length===0)return{};const e=ls(n,Q(this,er)),t={};return await Promise.all(e.map(async r=>{const s=await ds(this,He,_i).call(this,"/v1/struct-definition/bulk",{types:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.type_tag;a&&(t[i]=a)}})),t};_i=async function(n,e){if(!Q(this,mt))throw new Error("MVR Api URL is not set for the current client");const t=await fetch(`${Q(this,mt)}${n}`,{method:"POST",headers:{"Content-Type":"application/json",...eh},body:JSON.stringify(e)});if(!t.ok){const r=await t.json().catch(()=>({}));throw new Error(`Failed to resolve types: ${r?.message}`)}return t.json()};function nh(n){if(n?.packages)for(const[e,t]of Object.entries(n.packages)){if(!me(e))throw new Error(`Invalid package name: ${e}`);if(!Ne(P(t)))throw new Error(`Invalid package ID: ${t}`)}if(n?.types)for(const[e,t]of Object.entries(n.types)){if(Yt(e).typeParams.length>0)throw new Error("Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.");const r=Yt(t);if(!Ne(r.address))throw new Error(`Invalid type: ${t}`)}}function Ls(n,e=new Set){if(typeof n=="string"&&!de(n))return e;const t=Bo(n)?n:Yt(n);de(t.address)&&e.add(`${t.address}::${t.module}::${t.name}`);for(const r of t.typeParams)Ls(r,e);return e}function Ws(n,e){const t=Bo(n)?n:Yt(n),r=`${t.address}::${t.module}::${t.name}`,s=e[r];return Kr({...t,address:s?s.split("::")[0]:t.address,typeParams:t.typeParams.map(i=>Ws(i,e))})}function de(n){return n.includes(Xd)||n.includes("@")||n.includes(".sui")}function Bo(n){return typeof n=="object"&&"address"in n&&"module"in n&&"name"in n&&"typeParams"in n}function rh(n){const e=new Set,t=new Set;for(const r of n.commands)switch(r.$kind){case"MakeMoveVec":r.MakeMoveVec.type&&ga([r.MakeMoveVec.type]).forEach(a=>{t.add(a)});break;case"MoveCall":const s=r.MoveCall,i=s.package.split("::")[0];if(de(i)){if(!me(i))throw new Error(`Invalid package name: ${i}`);e.add(i)}ga(s.typeArguments??[]).forEach(a=>{t.add(a)});break}return{packages:[...e],types:[...t]}}function sh(n,e){for(const t of n.commands){if(t.MakeMoveVec?.type){if(!de(t.MakeMoveVec.type))continue;if(!e.types[t.MakeMoveVec.type])throw new Error(`No resolution found for type: ${t.MakeMoveVec.type}`);t.MakeMoveVec.type=e.types[t.MakeMoveVec.type].type}const r=t.MoveCall;if(!r)continue;const s=r.package.split("::"),i=s[0];if(de(i)&&!e.packages[i])throw new Error(`No address found for package: ${i}`);de(i)&&(s[0]=e.packages[i].package,r.package=s.join("::"));const a=r.typeArguments;if(a){for(let u=0;u<a.length;u++)if(de(a[u])){if(!e.types[a[u]])throw new Error(`No resolution found for type: ${a[u]}`);a[u]=e.types[a[u]].type}r.typeArguments=a}}}function ga(n){const e=new Set;for(const t of n)if(de(t)){if(!wl(t))throw new Error(`Invalid type with names: ${t}`);e.add(t)}return e}const ih=n=>async(e,t,r)=>{const s=rh(e);if(s.types.length===0&&s.packages.length===0)return r();const i=await ah(t).core.mvr.resolve({types:s.types,packages:s.packages});sh(e,i),await r()};function ah(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}var Do=n=>{throw TypeError(n)},Pi=(n,e,t)=>e.has(n)||Do("Cannot "+t),m=(n,e,t)=>(Pi(n,e,"read from private field"),t?t.call(n):e.get(n)),Ge=(n,e,t)=>e.has(n)?Do("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),U=(n,e,t,r)=>(Pi(n,e,"write to private field"),e.set(n,t),t),Z=(n,e,t)=>(Pi(n,e,"access private method"),t),Ft,Zt,dt,Xe,$e,Ee,Be,Et,k,K,zo,wr,br,vr,qr,Fs,xi,Vo,Lo;function ks(n,e=1/0){const t={$kind:"Result",get Result(){return typeof n=="function"?n():n}},r=[],s=i=>r[i]??(r[i]={$kind:"NestedResult",get NestedResult(){return[typeof n=="function"?n():n,i]}});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,a){if(a in i)return Reflect.get(i,a);if(a===Symbol.iterator)return function*(){let d=0;for(;d<e;)yield s(d),d++};if(typeof a=="symbol")return;const u=parseInt(a,10);if(!(Number.isNaN(u)||u<0))return s(u)}})}const Wo=Symbol.for("@mysten/transaction");function Fo(n){return!!n&&typeof n=="object"&&n[Wo]===!0}const fa={buildPlugins:new Map,serializationPlugins:new Map},Os=Symbol.for("@mysten/transaction/registry");function En(){try{const n=globalThis;return n[Os]||(n[Os]=fa),n[Os]}catch{return fa}}const Go=class Gs{constructor(){Ge(this,K),Ge(this,Ft),Ge(this,Zt),Ge(this,dt,new Map),Ge(this,Xe,[]),Ge(this,$e,[]),Ge(this,Ee,new Set),Ge(this,Be,new Set),Ge(this,Et,new Map),Ge(this,k),this.object=qd(t=>{if(typeof t=="function")return this.object(this.add(t));if(typeof t=="object"&&yn(V,t))return t;const r=da(t),s=m(this,k).inputs.find(i=>r===da(i));return s?.Object?.SharedObject&&typeof t=="object"&&t.Object?.SharedObject&&(s.Object.SharedObject.mutable=s.Object.SharedObject.mutable||t.Object.SharedObject.mutable),s?{$kind:"Input",Input:m(this,k).inputs.indexOf(s),type:"object"}:Z(this,K,br).call(this,"object",typeof t=="string"?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:P(t)}}:t)});const e=En();U(this,k,new Lt),U(this,Zt,[...e.buildPlugins.values()]),U(this,Ft,[...e.serializationPlugins.values()])}static fromKind(e){const t=new Gs;return U(t,k,Lt.fromKindBytes(typeof e=="string"?se(e):e)),U(t,Xe,m(t,k).inputs.slice()),U(t,$e,m(t,k).commands.slice()),U(t,Ee,new Set(m(t,$e).map((r,s)=>s))),t}static from(e){const t=new Gs;return Fo(e)?U(t,k,new Lt(e.getData())):typeof e!="string"||!e.startsWith("{")?U(t,k,Lt.fromBytes(typeof e=="string"?se(e):e)):U(t,k,Lt.restore(JSON.parse(e))),U(t,Xe,m(t,k).inputs.slice()),U(t,$e,m(t,k).commands.slice()),U(t,Ee,new Set(m(t,$e).map((r,s)=>s))),t}static registerGlobalSerializationPlugin(e,t){En().serializationPlugins.set(e,t??e)}static unregisterGlobalSerializationPlugin(e){En().serializationPlugins.delete(e)}static registerGlobalBuildPlugin(e,t){En().buildPlugins.set(e,t??e)}static unregisterGlobalBuildPlugin(e){En().buildPlugins.delete(e)}addSerializationPlugin(e){m(this,Ft).push(e)}addBuildPlugin(e){m(this,Zt).push(e)}addIntentResolver(e,t){if(m(this,dt).has(e)&&m(this,dt).get(e)!==t)throw new Error(`Intent resolver for ${e} already exists`);m(this,dt).set(e,t)}setSender(e){m(this,k).sender=e}setSenderIfNotSet(e){m(this,k).sender||(m(this,k).sender=e)}setExpiration(e){m(this,k).expiration=e?$(To,e):null}setGasPrice(e){m(this,k).gasConfig.price=String(e)}setGasBudget(e){m(this,k).gasConfig.budget=String(e)}setGasBudgetIfNotSet(e){m(this,k).gasData.budget==null&&(m(this,k).gasConfig.budget=String(e))}setGasOwner(e){m(this,k).gasConfig.owner=e}setGasPayment(e){m(this,k).gasConfig.payment=e.map(t=>$(_t,t))}get blockData(){return oa(m(this,k).snapshot())}getData(){return m(this,k).snapshot()}get[Wo](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Jd(e=>Ei(e)?Z(this,K,br).call(this,"pure",{$kind:"Pure",Pure:{bytes:e.toBase64()}}):Z(this,K,br).call(this,"pure",yn(sa,e)?$(sa,e):e instanceof Uint8Array?we.Pure(e):{$kind:"UnresolvedPure",UnresolvedPure:{value:e}}))}),this.pure}get gas(){return{$kind:"GasCoin",GasCoin:!0}}objectRef(...e){return this.object(we.ObjectRef(...e))}receivingRef(...e){return this.object(we.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(we.SharedObjectRef(...e))}add(e){if(typeof e=="function"){if(m(this,Et).has(e))return m(this,Et).get(e);const t=Z(this,K,zo).call(this),r=e(t);if(!(r&&typeof r=="object"&&"then"in r))return U(this,Ee,m(t,Ee)),m(this,Et).set(e,r),r;const s=Z(this,K,wr).call(this,{$kind:"$Intent",$Intent:{name:"AsyncTransactionThunk",inputs:{},data:{resultIndex:m(this,k).commands.length,result:null}}});m(this,Be).add(Promise.resolve(r).then(a=>{s.$Intent.data.result=a}));const i=ks(()=>s.$Intent.data.resultIndex);return m(this,Et).set(e,i),i}else Z(this,K,wr).call(this,e);return ks(m(this,k).commands.length-1)}splitCoins(e,t){const r=Nt.SplitCoins(typeof e=="string"?this.object(e):Z(this,K,qr).call(this,e),t.map(s=>typeof s=="number"||typeof s=="bigint"||typeof s=="string"?this.pure.u64(s):Z(this,K,vr).call(this,s)));return Z(this,K,wr).call(this,r),ks(m(this,k).commands.length-1,t.length)}mergeCoins(e,t){return this.add(Nt.MergeCoins(this.object(e),t.map(r=>this.object(r))))}publish({modules:e,dependencies:t}){return this.add(Nt.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,package:r,ticket:s}){return this.add(Nt.Upgrade({modules:e,dependencies:t,package:r,ticket:this.object(s)}))}moveCall({arguments:e,...t}){return this.add(Nt.MoveCall({...t,arguments:e?.map(r=>Z(this,K,vr).call(this,r))}))}transferObjects(e,t){return this.add(Nt.TransferObjects(e.map(r=>this.object(r)),typeof t=="string"?this.pure.address(t):Z(this,K,vr).call(this,t)))}makeMoveVec({type:e,elements:t}){return this.add(Nt.MakeMoveVec({type:e,elements:t.map(r=>this.object(r))}))}serialize(){return JSON.stringify(oa(m(this,k).snapshot()))}async toJSON(e={}){await this.prepareForSerialization(e);const t=this.isFullyResolved();return JSON.stringify($(_d,t?{...m(this,k).snapshot(),digest:m(this,k).getDigest()}:m(this,k).snapshot()),(r,s)=>typeof s=="bigint"?s.toString():s,2)}async sign(e){const{signer:t,...r}=e,s=await this.build(r);return t.signTransaction(s)}isFullyResolved(){return!(!m(this,k).sender||m(this,Be).size>0||m(this,k).commands.some(e=>e.$Intent)||Co(m(this,k),{}))}async build(e={}){return await this.prepareForSerialization(e),await Z(this,K,Fs).call(this,e),m(this,k).build({onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await this.prepareForSerialization(e),await Z(this,K,Fs).call(this,e),m(this,k).getDigest()}async prepareForSerialization(e){await Z(this,K,Vo).call(this),Z(this,K,Lo).call(this);const t=new Set;for(const s of m(this,k).commands)s.$Intent&&t.add(s.$Intent.name);const r=[...m(this,Ft)];for(const s of t)if(!e.supportedIntents?.includes(s)){if(!m(this,dt).has(s))throw new Error(`Missing intent resolver for ${s}`);r.push(m(this,dt).get(s))}r.push(ih()),await Z(this,K,xi).call(this,r,e)}};Ft=new WeakMap;Zt=new WeakMap;dt=new WeakMap;Xe=new WeakMap;$e=new WeakMap;Ee=new WeakMap;Be=new WeakMap;Et=new WeakMap;k=new WeakMap;K=new WeakSet;zo=function(){const n=new Go;return U(n,k,m(this,k)),U(n,Ft,m(this,Ft)),U(n,Zt,m(this,Zt)),U(n,dt,m(this,dt)),U(n,Be,m(this,Be)),U(n,Ee,new Set(m(this,Ee))),U(n,Et,m(this,Et)),m(this,Xe).push(m(n,Xe)),m(this,$e).push(m(n,$e)),n};wr=function(n){const e=m(this,k).commands.length;return m(this,$e).push(n),m(this,Ee).add(e),m(this,k).commands.push(n),m(this,k).mapCommandArguments(e,t=>{if(t.$kind==="Result"&&!m(this,Ee).has(t.Result))throw new Error(`Result { Result: ${t.Result} } is not available to use the current transaction`);if(t.$kind==="NestedResult"&&!m(this,Ee).has(t.NestedResult[0]))throw new Error(`Result { NestedResult: [${t.NestedResult[0]}, ${t.NestedResult[1]}] } is not available to use the current transaction`);if(t.$kind==="Input"&&t.Input>=m(this,k).inputs.length)throw new Error(`Input { Input: ${t.Input} } references an input that does not exist in the current transaction`);return t}),n};br=function(n,e){return m(this,Xe).push(e),m(this,k).addInput(n,e)};vr=function(n){return Ei(n)?this.pure(n):Z(this,K,qr).call(this,n)};qr=function(n){if(typeof n=="function"){const e=this.add(n);return typeof e=="function"?Z(this,K,qr).call(this,e):$(V,e)}return $(V,n)};Fs=async function(n){if(!n.onlyTransactionKind&&!m(this,k).sender)throw new Error("Missing transaction sender");await Z(this,K,xi).call(this,[...m(this,Zt),Fd],n)};xi=async function(n,e){try{const t=r=>{if(r>=n.length)return()=>{};const s=n[r];return async()=>{const i=t(r+1);let a=!1,u=!1;if(await s(m(this,k),e,async()=>{if(a)throw new Error(`next() was call multiple times in TransactionPlugin ${r}`);a=!0,await i(),u=!0}),!a)throw new Error(`next() was not called in TransactionPlugin ${r}`);if(!u)throw new Error(`next() was not awaited in TransactionPlugin ${r}`)}};await t(0)()}finally{U(this,Xe,m(this,k).inputs.slice()),U(this,$e,m(this,k).commands.slice())}};Vo=async function(){for(;m(this,Be).size>0;){const n=Promise.all(m(this,Be));m(this,Be).clear(),m(this,Be).add(n),await n,m(this,Be).delete(n)}};Lo=function(){const n=m(this,k).commands,e=m(this,k).inputs,t=m(this,$e).flat(1/0),r=m(this,Xe).flat(1/0);if(t.length!==n.length)throw new Error("Unexpected number of commands found in transaction data");if(r.length!==e.length)throw new Error("Unexpected number of inputs found in transaction data");const s=t.filter(a=>a.$Intent?.name!=="AsyncTransactionThunk");m(this,k).commands=s,m(this,k).inputs=r,U(this,$e,s),U(this,Xe,r),U(this,Ee,new Set(s.map((a,u)=>u)));function i(a){const u=n[a];if(u.$Intent?.name==="AsyncTransactionThunk"){const b=u.$Intent.data.result;if(b==null)throw new Error("AsyncTransactionThunk has not been resolved");return i(b.Result)}const d=s.indexOf(u);if(d===-1)throw new Error("Unable to find original index for command");return d}m(this,k).mapArguments(a=>{if(a.$kind==="Input"){const u=r.indexOf(e[a.Input]);if(u===-1)throw new Error("Input has not been resolved");return{...a,Input:u}}else if(a.$kind==="Result"){const u=i(a.Result);return{...a,Result:u}}else if(a.$kind==="NestedResult"){const u=i(a.NestedResult[0]);return{...a,NestedResult:[u,a.NestedResult[1]]}}return a});for(const[a,u]of n.entries())if(u.$Intent?.name==="AsyncTransactionThunk")try{u.$Intent.data.resultIndex=i(a)}catch{}};let Ko=Go;async function Rm(n,e){if(n.features["sui:signTransaction"])return n.features["sui:signTransaction"].signTransaction(e);if(!n.features["sui:signTransactionBlock"])throw new Error(`Provided wallet (${n.name}) does not support the signTransaction feature.`);const{signTransactionBlock:t}=n.features["sui:signTransactionBlock"],r=Ko.from(await e.transaction.toJSON()),{transactionBlockBytes:s,signature:i}=await t({transactionBlock:r,account:e.account,chain:e.chain});return{bytes:s,signature:i}}const oh=[ju,Cu];function Bm(n,e=[]){return[...oh,...e].every(t=>t in n.features)}const ch="sui:devnet",uh="sui:testnet",lh="sui:localnet",dh="sui:mainnet",qo=[ch,uh,lh,dh],hh=l({address:f(),publicKey:f()}),ph=l({exp:E(),iat:E(),iss:f(),aud:f(),payload:l({accounts:g(hh)})});function gh(n){const e=Au(n);return $(ph,e)}const fh=Va("type",[l({type:p("connect"),session:f("`session` is required")}),l({type:p("sign-transaction"),bytes:f(),signature:f()}),l({type:p("sign-and-execute-transaction"),bytes:f(),signature:f(),digest:f(),effects:f()}),l({type:p("sign-personal-message"),bytes:f(),signature:f()})]),mh=Va("type",[l({type:p("reject"),reason:C(f("`reason` must be a string"))}),l({type:p("resolve"),data:fh})]),yh=l({id:S(f(),_u()),source:p("web-wallet-channel"),payload:mh,version:p("1")});function wh(){return{version:"1",originUrl:window.location.href,userAgent:navigator.userAgent,screenResolution:`${window.screen.width}x${window.screen.height}`,language:navigator.language,platform:navigator.platform,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone,timestamp:Date.now()}}var Jo=n=>{throw TypeError(n)},Ni=(n,e,t)=>e.has(n)||Jo("Cannot "+t),J=(n,e,t)=>(Ni(n,e,"read from private field"),t?t.call(n):e.get(n)),ue=(n,e,t)=>e.has(n)?Jo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Se=(n,e,t,r)=>(Ni(n,e,"write to private field"),e.set(n,t),t),Is=(n,e,t)=>(Ni(n,e,"access private method"),t),zt,Ks,Cn,An,Sr,kr,Or,Ir,$r,Er,fn,Tr,Jr,_n,Mr;class bh{constructor({appName:e,hostOrigin:t,hostPathname:r="dapp-request",extraRequestOptions:s}){ue(this,_n),ue(this,zt),ue(this,Ks,"1"),ue(this,Cn),ue(this,An),ue(this,Sr),ue(this,kr),ue(this,Or),ue(this,Ir),ue(this,$r),ue(this,Er),ue(this,fn,null),ue(this,Tr,!1),ue(this,Jr,b=>{if(b.origin!==J(this,An))return;const{success:h,output:w}=Pu(yh,b.data);!h||w.id!==J(this,Cn)||(Is(this,_n,Mr).call(this),w.payload.type==="reject"?J(this,Er).call(this,new Error("User rejected the request")):w.payload.type==="resolve"&&J(this,$r).call(this,w.payload.data))});const i=window.open("about:blank","_blank");if(!i)throw new Error("Failed to open new window");Se(this,Cn,crypto.randomUUID()),Se(this,zt,i),Se(this,An,t),Se(this,Sr,r),Se(this,kr,e);const{promise:a,resolve:u,reject:d}=Vu();Se(this,Ir,a),Se(this,$r,u),Se(this,Er,d),Se(this,Or,s),Se(this,fn,setInterval(()=>{try{J(this,zt).closed&&(Is(this,_n,Mr).call(this),d(new Error("User closed the wallet window")))}catch{}},1e3))}send({type:e,...t}){if(J(this,zt).closed)throw new Error("User closed the wallet window");if(J(this,Tr))throw new Error("send() can only be called once");Se(this,Tr,!0),window.addEventListener("message",J(this,Jr));const r={version:J(this,Ks),requestId:J(this,Cn),appUrl:window.location.href.split("#")[0],appName:J(this,kr),payload:{type:e,...t},metadata:wh(),extraRequestOptions:J(this,Or)},s=encodeURIComponent(btoa(JSON.stringify(r)));return J(this,zt).location.assign(`${J(this,An)}/${J(this,Sr)}#${s}`),J(this,Ir)}close(){Is(this,_n,Mr).call(this),J(this,zt).close()}}zt=new WeakMap;Ks=new WeakMap;Cn=new WeakMap;An=new WeakMap;Sr=new WeakMap;kr=new WeakMap;Or=new WeakMap;Ir=new WeakMap;$r=new WeakMap;Er=new WeakMap;fn=new WeakMap;Tr=new WeakMap;Jr=new WeakMap;_n=new WeakSet;Mr=function(){J(this,fn)&&(clearInterval(J(this,fn)),Se(this,fn,null)),window.removeEventListener("message",J(this,Jr))};var Zo=n=>{throw TypeError(n)},Ui=(n,e,t)=>e.has(n)||Zo("Cannot "+t),re=(n,e,t)=>(Ui(n,e,"read from private field"),t?t.call(n):e.get(n)),ie=(n,e,t)=>e.has(n)?Zo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Ce=(n,e,t,r)=>(Ui(n,e,"write to private field"),e.set(n,t),t),vt=(n,e,t)=>(Ui(n,e,"access private method"),t),Pn,gn,Kn,Zr,xn,Nn,Hr,qs,Js,Zs,Hs,Qs,qe,Ys,Xs,Ho,ei,un;const vh="https://my.slush.app",Ri="slush:session",Dm="Slush",ma="com.mystenlabs.suiwallet",Sh="https://api.slush.app/api/wallet/metadata",kh={id:"com.mystenlabs.suiwallet.web",walletName:"Slush",description:"Trade and earn on Sui.",icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNENBMkZGIi8+CjxwYXRoIGQ9Ik0xMi4zNDczIDM0LjcyNTRDMTMuNTU1MyAzOS4yMzM2IDE4LjA2NzMgNDMuMzE0OCAyNy40MDI1IDQwLjgxMzRDMzYuMzA5NyAzOC40MjY3IDQxLjg5MjEgMzEuMDk5MyA0MC40NDQ2IDI1LjY5NzJDMzkuOTQ0NyAyMy44MzE3IDM4LjQzOTEgMjIuNTY4OSAzNi4xMTc4IDIyLjc3NDRMMTUuMzYxNSAyNC41MDM4QzE0LjA1NDQgMjQuNjA0MSAxMy40NTUgMjQuMzg5OCAxMy4xMDkyIDIzLjU2NjFDMTIuNzczOCAyMi43ODEyIDEyLjk2NDkgMjEuOTM4NSAxNC41NDM3IDIxLjE0MDZMMzAuMzM5NiAxMy4wMzQyQzMxLjU1MDMgMTIuNDE4MiAzMi4zNTY3IDEyLjE2MDUgMzMuMDkzNiAxMi40MjEzQzMzLjU1NTUgMTIuNTg5MSAzMy44NTk2IDEzLjI1NzQgMzMuNTgwMyAxNC4wODJMMzIuNTU2MSAxNy4xMDU2QzMxLjI5OTIgMjAuODE2NCAzMy45ODk5IDIxLjY3ODQgMzUuNTA2OCAyMS4yNzE5QzM3LjgwMTcgMjAuNjU3IDM4LjM0MTYgMTguNDcxMiAzNy42MDIzIDE1LjcxMTlDMzUuNzI3OCA4LjcxNjI5IDI4LjMwNTkgNy42MjI1NCAyMS41NzY4IDkuNDI1NTlDMTQuNzMxMSAxMS4yNTk5IDguNzk2ODEgMTYuODA3MiAxMC42MDg4IDIzLjU2OTZDMTEuMDM1OCAyNS4xNjMgMTIuNTAyNSAyNi40MzYyIDE0LjIwMTQgMjYuMzk3NUwxNi43OTUgMjYuMzkxMkMxNy4zMjg0IDI2LjM3ODggMTcuMTM2MyAyNi40MjI3IDE4LjE2NTMgMjYuMzM3NEMxOS4xOTQ0IDI2LjI1MjIgMjEuOTQyNSAyNS45MTQgMjEuOTQyNSAyNS45MTRMMzUuNDI3NSAyNC4zODhMMzUuNzc1IDI0LjMzNzVDMzYuNTYzNyAyNC4yMDMgMzcuMTU5NyAyNC40MDc5IDM3LjY2MzYgMjUuMjc2QzM4LjQxNzcgMjYuNTc1IDM3LjI2NzIgMjcuNTU0NiAzNS44ODk5IDI4LjcyNzJDMzUuODUzIDI4Ljc1ODYgMzUuODE2IDI4Ljc5MDEgMzUuNzc4OSAyOC44MjE4TDIzLjkyNSAzOS4wMzc3QzIxLjg5MzMgNDAuNzkwMSAyMC40NjYgNDAuMTMxMSAxOS45NjYyIDM4LjI2NTZMMTguMTk1OCAzMS42NTg3QzE3Ljc1ODUgMzAuMDI2NCAxNi4xNjQ2IDI4Ljc0NTYgMTQuMjk3NiAyOS4yNDU5QzExLjk2MzggMjkuODcxMiAxMS43NzQ2IDMyLjU4NzggMTIuMzQ3MyAzNC43MjU0WiIgZmlsbD0iIzA2MEQxNCIvPgo8L3N2Zz4K",enabled:!0},Oh=l({id:f("Wallet ID is required"),walletName:f("Wallet name is required"),icon:f("Icon must be a valid wallet icon format"),enabled:bt("Enabled is required")});function Ih(n){localStorage.setItem(Ri,n)}function Un(){const n=localStorage.getItem(Ri);if(!n)throw new Error("No session found");return n}const $h=["sui:signTransaction","sui:signAndExecuteTransaction","sui:signPersonalMessage","sui:signTransactionBlock","sui:signAndExecuteTransactionBlock"];function Qo(n){const{payload:e}=gh(n);return e.accounts.map(t=>new Uu({address:t.address,chains:qo,features:$h,publicKey:se(t.publicKey)}))}class Eh{constructor({name:e,origin:t,metadata:r}){ie(this,qe),ie(this,Pn),ie(this,gn),ie(this,Kn),ie(this,Zr),ie(this,xn),ie(this,Nn),ie(this,Hr),ie(this,qs,async({transactionBlock:s,account:i,chain:a})=>{const u=await s.toJSON(),b=await vt(this,qe,un).call(this).send({type:"sign-transaction",transaction:u,address:i.address,chain:a,session:Un()});return{transactionBlockBytes:b.bytes,signature:b.signature}}),ie(this,Js,async({transaction:s,account:i,chain:a})=>{const u=vt(this,qe,un).call(this),d=await s.toJSON(),b=await u.send({type:"sign-transaction",transaction:d,address:i.address,chain:a,session:Un()});return{bytes:b.bytes,signature:b.signature}}),ie(this,Zs,async({transaction:s,account:i,chain:a})=>{const u=vt(this,qe,un).call(this),d=await s.toJSON(),b=await u.send({type:"sign-and-execute-transaction",transaction:d,address:i.address,chain:a,session:Un()});return{bytes:b.bytes,signature:b.signature,digest:b.digest,effects:b.effects}}),ie(this,Hs,async({message:s,account:i,chain:a})=>{const d=await vt(this,qe,un).call(this).send({type:"sign-personal-message",message:F(s),address:i.address,chain:a??i.chains[0],session:Un()});return{bytes:d.bytes,signature:d.signature}}),ie(this,Qs,(s,i)=>(re(this,gn).on(s,i),()=>re(this,gn).off(s,i))),ie(this,Xs,async s=>{if(s?.silent)return{accounts:this.accounts};const a=await vt(this,qe,un).call(this).send({type:"connect"});return Ih(a.session),vt(this,qe,Ys).call(this,Qo(a.session)),{accounts:this.accounts}}),ie(this,ei,async()=>{localStorage.removeItem(Ri),vt(this,qe,Ys).call(this,[])}),Ce(this,Pn,r.id),Ce(this,Kn,vt(this,qe,Ho).call(this)),Ce(this,gn,Nu()),Ce(this,Zr,t||vh),Ce(this,Hr,e),Ce(this,xn,r.walletName),Ce(this,Nn,r.icon)}get name(){return re(this,xn)}get id(){return re(this,Pn)}get icon(){return re(this,Nn)}get version(){return"1.0.0"}get chains(){return qo}get accounts(){return re(this,Kn)}get features(){return{"standard:connect":{version:"1.0.0",connect:re(this,Xs)},"standard:disconnect":{version:"1.0.0",disconnect:re(this,ei)},"standard:events":{version:"1.0.0",on:re(this,Qs)},"sui:signTransactionBlock":{version:"1.0.0",signTransactionBlock:re(this,qs)},"sui:signTransaction":{version:"2.0.0",signTransaction:re(this,Js)},"sui:signPersonalMessage":{version:"1.1.0",signPersonalMessage:re(this,Hs)},"sui:signAndExecuteTransaction":{version:"2.0.0",signAndExecuteTransaction:re(this,Zs)}}}updateMetadata(e){Ce(this,Pn,e.id),Ce(this,xn,e.walletName),Ce(this,Nn,e.icon)}}Pn=new WeakMap;gn=new WeakMap;Kn=new WeakMap;Zr=new WeakMap;xn=new WeakMap;Nn=new WeakMap;Hr=new WeakMap;qs=new WeakMap;Js=new WeakMap;Zs=new WeakMap;Hs=new WeakMap;Qs=new WeakMap;qe=new WeakSet;Ys=function(n){Ce(this,Kn,n),re(this,gn).emit("change",{accounts:this.accounts})};Xs=new WeakMap;Ho=function(){try{return Qo(Un())}catch{return[]}};ei=new WeakMap;un=function(){return new bh({appName:re(this,Hr),hostOrigin:re(this,Zr)})};async function Th(n){const e=await fetch(n);if(!e.ok)throw new Error("Failed to fetch wallet metadata");const t=await e.json();return $(Oh,t)}function zm(n,{origin:e,metadataApiUrl:t=Sh}={}){const r=xu();let s=null;if(r.on("register",u=>{u.id===ma&&s?.()}),r.get().find(u=>u.id===ma))return;const a=new Eh({name:n,origin:e,metadata:kh});return s=r.register(a),Th(t).then(u=>{if(!u.enabled){console.log("Slush wallet is not currently enabled."),s?.();return}a.updateMetadata(u)}).catch(u=>{console.error("Error fetching metadata",u)}),{wallet:a,unregister:s}}const Mh={"-32700":"ParseError","-32701":"OversizedRequest","-32702":"OversizedResponse","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError","-32604":"ServerBusy","-32000":"CallExecutionFailed","-32001":"UnknownError","-32003":"SubscriptionClosed","-32004":"SubscriptionClosedWithError","-32005":"BatchesNotSupported","-32006":"TooManySubscriptions","-32050":"TransientError","-32002":"TransactionExecutionClientError"};class Yo extends Error{}class Xo extends Yo{constructor(e,t){super(e),this.code=t,this.type=Mh[t]??"ServerError"}}class jh extends Yo{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}var ec=n=>{throw TypeError(n)},Bi=(n,e,t)=>e.has(n)||ec("Cannot "+t),z=(n,e,t)=>(Bi(n,e,"read from private field"),t?t.call(n):e.get(n)),Ut=(n,e,t)=>e.has(n)?ec("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),mn=(n,e,t,r)=>(Bi(n,e,"write to private field"),e.set(n,t),t),tc=(n,e,t)=>(Bi(n,e,"access private method"),t),Ch=(n,e,t,r)=>({set _(s){mn(n,e,s)},get _(){return z(n,e,r)}}),kt,qn,ht,Gt,tr,Kt,Qr,nc,rc;function Ah(n){const e=new URL(n);return e.protocol=e.protocol.replace("http","ws"),e.toString()}const _h={WebSocketConstructor:typeof WebSocket<"u"?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Ph{constructor(e,t={}){if(Ut(this,Qr),Ut(this,kt,0),Ut(this,qn,0),Ut(this,ht,null),Ut(this,Gt,null),Ut(this,tr,new Set),Ut(this,Kt,new Map),this.endpoint=e,this.options={..._h,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=Ah(this.endpoint))}async makeRequest(e,t,r){const s=await tc(this,Qr,nc).call(this);return new Promise((i,a)=>{mn(this,kt,z(this,kt)+1),z(this,Kt).set(z(this,kt),{resolve:i,reject:a,timeout:setTimeout(()=>{z(this,Kt).delete(z(this,kt)),a(new Error(`Request timeout: ${e}`))},this.options.callTimeout)}),r?.addEventListener("abort",()=>{z(this,Kt).delete(z(this,kt)),a(r.reason)}),s.send(JSON.stringify({jsonrpc:"2.0",id:z(this,kt),method:e,params:t}))}).then(({error:i,result:a})=>{if(i)throw new Xo(i.message,i.code);return a})}async subscribe(e){const t=new xh(e);return z(this,tr).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}kt=new WeakMap;qn=new WeakMap;ht=new WeakMap;Gt=new WeakMap;tr=new WeakMap;Kt=new WeakMap;Qr=new WeakSet;nc=function(){return z(this,Gt)?z(this,Gt):(mn(this,Gt,new Promise(n=>{z(this,ht)?.close(),mn(this,ht,new this.options.WebSocketConstructor(this.endpoint)),z(this,ht).addEventListener("open",()=>{mn(this,qn,0),n(z(this,ht))}),z(this,ht).addEventListener("close",()=>{Ch(this,qn)._++,z(this,qn)<=this.options.maxReconnects&&setTimeout(()=>{tc(this,Qr,rc).call(this)},this.options.reconnectTimeout)}),z(this,ht).addEventListener("message",({data:e})=>{let t;try{t=JSON.parse(e)}catch(r){console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:r}));return}if("id"in t&&t.id!=null&&z(this,Kt).has(t.id)){const{resolve:r,timeout:s}=z(this,Kt).get(t.id);clearTimeout(s),r(t)}else if("params"in t){const{params:r}=t;z(this,tr).forEach(s=>{s.subscriptionId===r.subscription&&r.subscription===s.subscriptionId&&s.onMessage(r.result)})}})})),z(this,Gt))};rc=async function(){return z(this,ht)?.close(),mn(this,Gt,null),Promise.allSettled([...z(this,tr)].map(n=>n.subscribe(this)))};class xh{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,t==null?!1:(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params,this.input.signal);this.subscribed&&(this.subscriptionId=t)}}var sc=n=>{throw TypeError(n)},Di=(n,e,t)=>e.has(n)||sc("Cannot "+t),Ie=(n,e,t)=>(Di(n,e,"read from private field"),t?t.call(n):e.get(n)),lr=(n,e,t)=>e.has(n)?sc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),ti=(n,e,t,r)=>(Di(n,e,"write to private field"),e.set(n,t),t),Nh=(n,e,t)=>(Di(n,e,"access private method"),t),Rn,Ue,Jn,ni,ic;class Uh{constructor(e){lr(this,ni),lr(this,Rn,0),lr(this,Ue),lr(this,Jn),ti(this,Ue,e)}fetch(e,t){const r=Ie(this,Ue).fetch??fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){ti(this,Rn,Ie(this,Rn)+1);const t=await this.fetch(Ie(this,Ue).rpc?.url??Ie(this,Ue).url,{method:"POST",signal:e.signal,headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":xo,"Client-Target-Api-Version":Yd,"Client-Request-Method":e.method,...Ie(this,Ue).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:Ie(this,Rn),method:e.method,params:e.params})});if(!t.ok)throw new jh(`Unexpected status code: ${t.status}`,t.status,t.statusText);const r=await t.json();if("error"in r&&r.error!=null)throw new Xo(r.error.message,r.error.code);return r.result}async subscribe(e){const t=await Nh(this,ni,ic).call(this).subscribe(e);return e.signal&&(e.signal.throwIfAborted(),e.signal.addEventListener("abort",()=>{t()})),async()=>!!await t()}}Rn=new WeakMap;Ue=new WeakMap;Jn=new WeakMap;ni=new WeakSet;ic=function(){if(!Ie(this,Jn)){const n=Ie(this,Ue).WebSocketConstructor??WebSocket;if(!n)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");ti(this,Jn,new Ph(Ie(this,Ue).websocket?.url??Ie(this,Ue).url,{WebSocketConstructor:n,...Ie(this,Ue).websocket}))}return Ie(this,Jn)};function Vm(n){switch(n){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${n}`)}}let ac=class{constructor({network:e,base:t,cache:r=t?.cache??new Qd}){this.network=e,this.base=t??this,this.cache=r}$extend(...e){return Object.create(this,Object.fromEntries(e.map(t=>{if("experimental_asClientExtension"in t){const{name:r,register:s}=t.experimental_asClientExtension();return[r,{value:s(this)}]}return[t.name,{value:t.register(this)}]})))}};const Rh={mainnet:"https://mainnet.mvr.mystenlabs.com",testnet:"https://testnet.mvr.mystenlabs.com"};let Bh=class extends ac{constructor(e){super(e),this.core=this,this.mvr=new th({cache:this.cache.scope("core.mvr"),url:e.mvr?.url??Rh[this.network],pageSize:e.mvr?.pageSize,overrides:e.mvr?.overrides})}async getObject(e){const{objectId:t}=e,{objects:[r]}=await this.getObjects({objectIds:[t],signal:e.signal});if(r instanceof Error)throw r;return{object:r}}async getDynamicField(e){const t=Kl(e.parentId,Yn.parseFromStr(e.name.type),e.name.bcs),{objects:[r]}=await this.getObjects({objectIds:[t],signal:e.signal});if(r instanceof Error)throw r;const s=Yt(r.type),i=await r.content;return{dynamicField:{id:r.id,digest:r.digest,version:r.version,type:r.type,name:{type:typeof s.typeParams[0]=="string"?s.typeParams[0]:Kr(s.typeParams[0]),bcs:e.name.bcs},value:{type:typeof s.typeParams[1]=="string"?s.typeParams[1]:Kr(s.typeParams[1]),bcs:i.slice(ir+e.name.bcs.length)}}}}async waitForTransaction({signal:e,timeout:t=60*1e3,...r}){const s=e?AbortSignal.any([AbortSignal.timeout(t),e]):AbortSignal.timeout(t),i=new Promise((a,u)=>{s.addEventListener("abort",()=>u(s.reason))});for(i.catch(()=>{});;){s.throwIfAborted();try{return await this.getTransaction({...r,signal:s})}catch{await Promise.race([new Promise(u=>setTimeout(u,2e3)),i])}}}},Dh=class extends Error{},ya=class ln extends Dh{constructor(e,t){super(t),this.code=e}static fromResponse(e,t){switch(e.code){case"notExists":return new ln(e.code,`Object ${e.object_id} does not exist`);case"dynamicFieldNotFound":return new ln(e.code,`Dynamic field not found for object ${e.parent_object_id}`);case"deleted":return new ln(e.code,`Object ${e.object_id} has been deleted`);case"displayError":return new ln(e.code,`Display error: ${e.error}`);case"unknown":default:return new ln(e.code,`Unknown error while loading object${t?` ${t}`:""}`)}}};function zh(n){return{...Lt.fromBytes(n).snapshot(),bcs:n}}function Vh(n){const e=I.TransactionEffects.parse(n);switch(e.$kind){case"V1":return Lh({effects:e.V1});case"V2":return Wh({bytes:n,effects:e.V2});default:throw new Error(`Unknown transaction effects version: ${e.$kind}`)}}function Lh(n){throw new Error("V1 effects are not supported yet")}function Wh({bytes:n,effects:e}){const t=e.changedObjects.map(([r,s])=>({id:r,inputState:s.inputState.$kind==="Exist"?"Exists":"DoesNotExist",inputVersion:s.inputState.Exist?.[0][0]??null,inputDigest:s.inputState.Exist?.[0][1]??null,inputOwner:s.inputState.Exist?.[1]??null,outputState:s.outputState.$kind==="NotExist"?"DoesNotExist":s.outputState.$kind,outputVersion:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[0]:s.outputState.ObjectWrite?e.lamportVersion:null,outputDigest:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[1]:s.outputState.ObjectWrite?.[0]??null,outputOwner:s.outputState.ObjectWrite?s.outputState.ObjectWrite[1]:null,idOperation:s.idOperation.$kind}));return{bcs:n,digest:e.transactionDigest,version:2,status:e.status.$kind==="Success"?{success:!0,error:null}:{success:!1,error:e.status.Failed.error.$kind},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:e.gasObjectIndex===null?null:t[e.gasObjectIndex]??null,eventsDigest:e.eventsDigest,dependencies:e.dependencies,lamportVersion:e.lamportVersion,changedObjects:t,unchangedSharedObjects:e.unchangedSharedObjects.map(([r,s])=>({kind:s.$kind==="MutateDeleted"?"MutateConsensusStreamEnded":s.$kind==="ReadDeleted"?"ReadConsensusStreamEnded":s.$kind,objectId:r,version:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[0]:s[s.$kind],digest:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[1]:null})),auxiliaryDataDigest:e.auxDataDigest}}var oc=n=>{throw TypeError(n)},cc=(n,e,t)=>e.has(n)||oc("Cannot "+t),ge=(n,e,t)=>(cc(n,e,"read from private field"),t?t.call(n):e.get(n)),Fh=(n,e,t)=>e.has(n)?oc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Gh=(n,e,t,r)=>(cc(n,e,"write to private field"),e.set(n,t),t),ne;class Kh extends Bh{constructor({jsonRpcClient:e,mvr:t}){super({network:e.network,base:e,mvr:t}),Fh(this,ne),Gh(this,ne,e)}async getObjects(e){const t=ls(e.objectIds,50),r=[];for(const s of t){const i=await ge(this,ne).multiGetObjects({ids:s,options:{showOwner:!0,showType:!0,showBcs:!0},signal:e.signal});for(const[a,u]of i.entries())u.error?r.push(ya.fromResponse(u.error,s[a])):r.push(wa(u.data))}return{objects:r}}async getOwnedObjects(e){const t=await ge(this,ne).getOwnedObjects({owner:e.address,limit:e.limit,cursor:e.cursor,options:{showOwner:!0,showType:!0,showBcs:!0},filter:e.type?{StructType:e.type}:null,signal:e.signal});return{objects:t.data.map(r=>{if(r.error)throw ya.fromResponse(r.error);return wa(r.data)}),hasNextPage:t.hasNextPage,cursor:t.nextCursor??null}}async getCoins(e){const t=await ge(this,ne).getCoins({owner:e.address,coinType:e.coinType,limit:e.limit,cursor:e.cursor,signal:e.signal});return{objects:t.data.map(r=>({id:r.coinObjectId,version:r.version,digest:r.digest,balance:r.balance,type:`0x2::coin::Coin<${r.coinType}>`,content:Promise.resolve(Zh.serialize({id:r.coinObjectId,balance:{value:r.balance}}).toBytes()),owner:{$kind:"ObjectOwner",ObjectOwner:e.address}})),hasNextPage:t.hasNextPage,cursor:t.nextCursor??null}}async getBalance(e){const t=await ge(this,ne).getBalance({owner:e.address,coinType:e.coinType,signal:e.signal});return{balance:{coinType:t.coinType,balance:t.totalBalance}}}async getAllBalances(e){return{balances:(await ge(this,ne).getAllBalances({owner:e.address,signal:e.signal})).map(r=>({coinType:r.coinType,balance:r.totalBalance})),hasNextPage:!1,cursor:null}}async getTransaction(e){const t=await ge(this,ne).getTransactionBlock({digest:e.digest,options:{showRawInput:!0,showObjectChanges:!0,showRawEffects:!0,showEvents:!0,showEffects:!0},signal:e.signal});return{transaction:ba(t)}}async executeTransaction(e){const t=await ge(this,ne).executeTransactionBlock({transactionBlock:e.transaction,signature:e.signatures,options:{showRawEffects:!0,showEvents:!0,showObjectChanges:!0,showRawInput:!0,showEffects:!0},signal:e.signal});return{transaction:ba(t)}}async dryRunTransaction(e){const t=Ko.from(e.transaction),r=await ge(this,ne).dryRunTransactionBlock({transactionBlock:e.transaction,signal:e.signal}),{effects:s,objectTypes:i}=qh({effects:r.effects,objectChanges:r.objectChanges});return{transaction:{digest:await t.getDigest(),epoch:null,effects:s,objectTypes:Promise.resolve(i),signatures:[],transaction:zh(e.transaction)}}}async getReferenceGasPrice(e){const t=await ge(this,ne).getReferenceGasPrice({signal:e?.signal});return{referenceGasPrice:String(t)}}async getDynamicFields(e){const t=await ge(this,ne).getDynamicFields({parentId:e.parentId,limit:e.limit,cursor:e.cursor});return{dynamicFields:t.data.map(r=>({id:r.objectId,type:r.objectType,name:{type:r.name.type,bcs:se(r.bcsName)}})),hasNextPage:t.hasNextPage,cursor:t.nextCursor}}async verifyZkLoginSignature(e){const t=await ge(this,ne).verifyZkLoginSignature({bytes:e.bytes,signature:e.signature,intentScope:e.intentScope,author:e.author});return{success:t.success,errors:t.errors}}resolveNameServiceNames(e){return ge(this,ne).resolveNameServiceNames(e)}resolveTransactionPlugin(){return jo(ge(this,ne))}}ne=new WeakMap;function wa(n){return{id:n.objectId,version:n.version,digest:n.digest,type:n.type,content:Promise.resolve(n.bcs?.dataType==="moveObject"?se(n.bcs.bcsBytes):new Uint8Array),owner:dn(n.owner)}}function dn(n){if(n==="Immutable")return{$kind:"Immutable",Immutable:!0};if("ConsensusAddressOwner"in n)return{$kind:"ConsensusAddressOwner",ConsensusAddressOwner:{owner:n.ConsensusAddressOwner.owner,startVersion:n.ConsensusAddressOwner.start_version}};if("AddressOwner"in n)return{$kind:"AddressOwner",AddressOwner:n.AddressOwner};if("ObjectOwner"in n)return{$kind:"ObjectOwner",ObjectOwner:n.ObjectOwner};if("Shared"in n)return{$kind:"Shared",Shared:{initialSharedVersion:n.Shared.initial_shared_version}};throw new Error(`Unknown owner type: ${JSON.stringify(n)}`)}function ba(n){const e=I.SenderSignedData.parse(se(n.rawTransaction))[0],t={};n.objectChanges?.forEach(i=>{i.type!=="published"&&(t[i.objectId]=i.objectType)});const r=I.TransactionData.serialize(e.intentMessage.value).toBytes(),s=Lt.restore({version:2,sender:e.intentMessage.value.V1.sender,expiration:e.intentMessage.value.V1.expiration,gasData:e.intentMessage.value.V1.gasData,inputs:e.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,commands:e.intentMessage.value.V1.kind.ProgrammableTransaction.commands});return{digest:n.digest,epoch:n.effects?.executedEpoch??null,effects:Vh(new Uint8Array(n.rawEffects)),objectTypes:Promise.resolve(t),transaction:{...s,bcs:r},signatures:e.txSignatures}}function qh({bytes:n,effects:e,objectChanges:t}){const r=[],s=[],i={};return t?.forEach(a=>{switch(a.type){case"published":r.push({id:a.packageId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"PackageWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:null,idOperation:"Created"});break;case"transferred":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:a.digest,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:dn(a.recipient),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"mutated":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.previousVersion,inputDigest:null,inputOwner:dn(a.owner),outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:dn(a.owner),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"deleted":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:e.deleted?.find(u=>u.objectId===a.objectId)?.digest??null,inputOwner:null,outputState:"DoesNotExist",outputVersion:null,outputDigest:null,outputOwner:null,idOperation:"Deleted"}),i[a.objectId]=a.objectType;break;case"wrapped":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:null,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:e.wrapped?.find(u=>u.objectId===a.objectId)?.digest??null,outputOwner:{$kind:"ObjectOwner",ObjectOwner:a.sender},idOperation:"None"}),i[a.objectId]=a.objectType;break;case"created":r.push({id:a.objectId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:dn(a.owner),idOperation:"Created"}),i[a.objectId]=a.objectType;break}}),{objectTypes:i,effects:{bcs:n??null,digest:e.transactionDigest,version:2,status:e.status.status==="success"?{success:!0,error:null}:{success:!1,error:e.status.error},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:{id:e.gasObject?.reference.objectId,inputState:"Exists",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:e.gasObject.reference.version,outputDigest:e.gasObject.reference.digest,outputOwner:dn(e.gasObject.owner),idOperation:"None"},eventsDigest:e.eventsDigest??null,dependencies:e.dependencies??[],lamportVersion:e.gasObject.reference.version,changedObjects:r,unchangedSharedObjects:s,auxiliaryDataDigest:null}}}const Jh=I.struct("Balance",{value:I.u64()}),Zh=I.struct("Coin",{id:I.Address,balance:Jh}),uc=Symbol.for("@mysten/SuiClient");function Gm(n){return typeof n=="object"&&n!==null&&n[uc]===!0}class Km extends ac{constructor(e){super({network:e.network??"unknown"}),this.jsonRpc=this,this.transport=e.transport??new Uh({url:e.url}),this.core=new Kh({jsonRpcClient:this,mvr:e.mvr})}get[uc](){return!0}async getRpcApiVersion({signal:e}={}){return(await this.transport.request({method:"rpc.discover",params:[],signal:e})).info.version}async getCoins({coinType:e,owner:t,cursor:r,limit:s,signal:i}){if(!t||!Ne(P(t)))throw new Error("Invalid Sui address");return e&&de(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoins",params:[t,e,r,s],signal:i})}async getAllCoins(e){if(!e.owner||!Ne(P(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit],signal:e.signal})}async getBalance({owner:e,coinType:t,signal:r}){if(!e||!Ne(P(e)))throw new Error("Invalid Sui address");return t&&de(t)&&(t=(await this.core.mvr.resolveType({type:t})).type),await this.transport.request({method:"suix_getBalance",params:[e,t],signal:r})}async getAllBalances(e){if(!e.owner||!Ne(P(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner],signal:e.signal})}async getCoinMetadata({coinType:e,signal:t}){return e&&de(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoinMetadata",params:[e],signal:t})}async getTotalSupply({coinType:e,signal:t}){return e&&de(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getTotalSupply",params:[e],signal:t})}async call(e,t,{signal:r}={}){return await this.transport.request({method:e,params:t,signal:r})}async getMoveFunctionArgTypes({package:e,module:t,function:r,signal:s}){return e&&me(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e,t,r],signal:s})}async getNormalizedMoveModulesByPackage({package:e,signal:t}){return e&&me(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e],signal:t})}async getNormalizedMoveModule({package:e,module:t,signal:r}){return e&&me(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e,t],signal:r})}async getNormalizedMoveFunction({package:e,module:t,function:r,signal:s}){return e&&me(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e,t,r],signal:s})}async getNormalizedMoveStruct({package:e,module:t,struct:r,signal:s}){return e&&me(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e,t,r],signal:s})}async getOwnedObjects(e){if(!e.owner||!Ne(P(e.owner)))throw new Error("Invalid Sui address");const t=e.filter?{...e.filter}:void 0;return t&&"MoveModule"in t&&me(t.MoveModule.package)?t.MoveModule={module:t.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:t.MoveModule.package})).package}:t&&"StructType"in t&&de(t.StructType)&&(t.StructType=(await this.core.mvr.resolveType({type:t.StructType})).type),await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:t,options:e.options},e.cursor,e.limit],signal:e.signal})}async getObject(e){if(!e.id||!cr(gt(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options],signal:e.signal})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options],signal:e.signal})}async multiGetObjects(e){if(e.ids.forEach(r=>{if(!r||!cr(gt(r)))throw new Error(`Invalid Sui Object id ${r}`)}),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options],signal:e.signal})}async queryTransactionBlocks({filter:e,options:t,cursor:r,limit:s,order:i,signal:a}){return e&&"MoveFunction"in e&&me(e.MoveFunction.package)&&(e={...e,MoveFunction:{package:(await this.core.mvr.resolvePackage({package:e.MoveFunction.package})).package}}),await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e,options:t},r,s,(i||"descending")==="descending"],signal:a})}async getTransactionBlock(e){if(!na(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options],signal:e.signal})}async multiGetTransactionBlocks(e){if(e.digests.forEach(r=>{if(!na(r))throw new Error(`Invalid Transaction digest ${r}`)}),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options],signal:e.signal})}async executeTransactionBlock({transactionBlock:e,signature:t,options:r,requestType:s,signal:i}){const a=await this.transport.request({method:"sui_executeTransactionBlock",params:[typeof e=="string"?e:F(e),Array.isArray(t)?t:[t],r],signal:i});if(s==="WaitForLocalExecution")try{await this.waitForTransaction({digest:a.digest})}catch{}return a}async signAndExecuteTransaction({transaction:e,signer:t,...r}){let s;e instanceof Uint8Array?s=e:(e.setSenderIfNotSet(t.toSuiAddress()),s=await e.build({client:this}));const{signature:i,bytes:a}=await t.signTransaction(s);return this.executeTransactionBlock({transactionBlock:a,signature:i,...r})}async getTotalTransactionBlocks({signal:e}={}){const t=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[],signal:e});return BigInt(t)}async getReferenceGasPrice({signal:e}={}){const t=await this.transport.request({method:"suix_getReferenceGasPrice",params:[],signal:e});return BigInt(t)}async getStakes(e){if(!e.owner||!Ne(P(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner],signal:e.signal})}async getStakesByIds(e){return e.stakedSuiIds.forEach(t=>{if(!t||!cr(gt(t)))throw new Error(`Invalid Sui Stake id ${t}`)}),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds],signal:e.signal})}async getLatestSuiSystemState({signal:e}={}){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[],signal:e})}async queryEvents({query:e,cursor:t,limit:r,order:s,signal:i}){return e&&"MoveEventType"in e&&de(e.MoveEventType)&&(e={...e,MoveEventType:(await this.core.mvr.resolveType({type:e.MoveEventType})).type}),e&&"MoveEventModule"in e&&me(e.MoveEventModule.package)&&(e={...e,MoveEventModule:{module:e.MoveEventModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveEventModule.package})).package}}),"MoveModule"in e&&me(e.MoveModule.package)&&(e={...e,MoveModule:{module:e.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveModule.package})).package}}),await this.transport.request({method:"suix_queryEvents",params:[e,t,r,(s||"descending")==="descending"],signal:i})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async devInspectTransactionBlock(e){let t;if(Fo(e.transactionBlock))e.transactionBlock.setSenderIfNotSet(e.sender),t=F(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if(typeof e.transactionBlock=="string")t=e.transactionBlock;else if(e.transactionBlock instanceof Uint8Array)t=F(e.transactionBlock);else throw new Error("Unknown transaction block format.");return e.signal?.throwIfAborted(),await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,t,e.gasPrice?.toString(),e.epoch],signal:e.signal})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:[typeof e.transactionBlock=="string"?e.transactionBlock:F(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!cr(gt(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit],signal:e.signal})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name],signal:e.signal})}async getLatestCheckpointSequenceNumber({signal:e}={}){const t=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[],signal:e});return String(t)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id],signal:e.signal})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder],signal:e.signal})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch],signal:e?.signal})}async getNetworkMetrics({signal:e}={}){return await this.transport.request({method:"suix_getNetworkMetrics",params:[],signal:e})}async getAddressMetrics({signal:e}={}){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[],signal:e})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder],signal:e?.signal})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getMoveCallMetrics({signal:e}={}){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[],signal:e})}async getCurrentEpoch({signal:e}={}){return await this.transport.request({method:"suix_getCurrentEpoch",params:[],signal:e})}async getValidatorsApy({signal:e}={}){return await this.transport.request({method:"suix_getValidatorsApy",params:[],signal:e})}async getChainIdentifier({signal:e}={}){const t=await this.getCheckpoint({id:"0",signal:e}),r=Qn(t.digest);return Qt(r.slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name],signal:e.signal})}async resolveNameServiceNames({format:e="dot",...t}){const{nextCursor:r,hasNextPage:s,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit],signal:t.signal});return{hasNextPage:s,nextCursor:r,data:i.map(a=>gl(a,e))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version],signal:e?.signal})}async verifyZkLoginSignature(e){return await this.transport.request({method:"sui_verifyZkLoginSignature",params:[e.bytes,e.signature,e.intentScope,e.author],signal:e.signal})}async waitForTransaction({signal:e,timeout:t=60*1e3,pollInterval:r=2*1e3,...s}){const i=AbortSignal.timeout(t),a=new Promise((u,d)=>{i.addEventListener("abort",()=>d(i.reason))});for(a.catch(()=>{});!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(s)}catch{await Promise.race([new Promise(d=>setTimeout(d,r)),a])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}experimental_asClientExtension(){return{name:"jsonRPC",register:()=>this}}}function lc(n,e){return I.IntentMessage(I.fixedArray(e.length,I.u8())).serialize({intent:{scope:{[n]:!0},version:{V0:!0},appId:{Sui:!0}},value:e}).toBytes()}const zi={ED25519:0,Secp256k1:1,Secp256r1:2,MultiSig:3,ZkLogin:5,Passkey:6},Hh={ED25519:32,Secp256k1:33,Secp256r1:33,Passkey:33},dc={0:"ED25519",1:"Secp256k1",2:"Secp256r1",3:"MultiSig",5:"ZkLogin",6:"Passkey"};function hc(n,e){if(n===e)return!0;if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}let Qh=class{equals(e){return hc(this.toRawBytes(),e.toRawBytes())}toBase64(){return F(this.toRawBytes())}toString(){throw new Error("`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.")}toSuiPublicKey(){const e=this.toSuiBytes();return F(e)}verifyWithIntent(e,t,r){const s=lc(r,e),i=Fe(s,{dkLen:32});return this.verify(i,t)}verifyPersonalMessage(e,t){return this.verifyWithIntent(I.vector(I.u8()).serialize(e).toBytes(),t,"PersonalMessage")}verifyTransaction(e,t){return this.verifyWithIntent(e,t,"TransactionData")}verifyAddress(e){return this.toSuiAddress()===e}toSuiBytes(){const e=this.toRawBytes(),t=new Uint8Array(e.length+1);return t.set([this.flag()]),t.set(e,1),t}toSuiAddress(){return P(Ii(Fe(this.toSuiBytes(),{dkLen:32})).slice(0,ir*2))}};function Yh(n){const e=se(n),t=dc[e[0]];switch(t){case"ED25519":case"Secp256k1":case"Secp256r1":const r=Hh[t],s=e.slice(1,e.length-r),i=e.slice(1+s.length);return{serializedSignature:n,signatureScheme:t,signature:s,publicKey:i,bytes:e};default:throw new Error("Unsupported signature scheme")}}function Xh({signature:n,signatureScheme:e,publicKey:t}){if(!t)throw new Error("`publicKey` is required");const r=t.toRawBytes(),s=new Uint8Array(1+n.length+r.length);return s.set([zi[e]]),s.set(n,1),s.set(r,1+n.length),F(s)}const jr=32,pc="suiprivkey";let ep=class{async signWithIntent(e,t){const r=lc(t,e),s=Fe(r,{dkLen:32});return{signature:Xh({signature:await this.sign(s),signatureScheme:this.getKeyScheme(),publicKey:this.getPublicKey()}),bytes:F(e)}}async signTransaction(e){return this.signWithIntent(e,"TransactionData")}async signPersonalMessage(e){const{signature:t}=await this.signWithIntent(o.vector(o.u8()).serialize(e).toBytes(),"PersonalMessage");return{bytes:F(e),signature:t}}async signAndExecuteTransaction({transaction:e,client:t}){const r=await e.build({client:t}),{signature:s}=await this.signTransaction(r);return(await t.core.executeTransaction({transaction:r,signatures:[s]})).transaction}toSuiAddress(){return this.getPublicKey().toSuiAddress()}};class tp extends ep{}function np(n){const{prefix:e,words:t}=zr.decode(n);if(e!==pc)throw new Error("invalid private key prefix");const r=new Uint8Array(zr.fromWords(t)),s=r.slice(1),i=dc[r[0]];return{scheme:i,schema:i,secretKey:s}}function rp(n,e){if(n.length!==jr)throw new Error("Invalid bytes length");const t=zi[e],r=new Uint8Array(n.length+1);return r.set([t]),r.set(n,1),zr.encode(pc,zr.toWords(r))}function va(n){return!!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(n)}function sp(n){return Ru(n,"")}function ip(n){return Qt(sp(n))}const ap="ed25519 seed",op=2147483648,cp=new RegExp("^m(\\/[0-9]+')+$"),gc=n=>n.replace("'",""),up=n=>{const t=La.create(Wa,ap).update($i(n)).digest(),r=t.slice(0,32),s=t.slice(32);return{key:r,chainCode:s}},lp=({key:n,chainCode:e},t)=>{const r=new ArrayBuffer(4);new DataView(r).setUint32(0,t);const i=new Uint8Array(1+n.length+r.byteLength);i.set(new Uint8Array(1).fill(0)),i.set(n,1),i.set(new Uint8Array(r,0,r.byteLength),n.length+1);const a=La.create(Wa,e).update(i).digest(),u=a.slice(0,32),d=a.slice(32);return{key:u,chainCode:d}},dp=n=>cp.test(n)?!n.split("/").slice(1).map(gc).some(isNaN):!1,Sa=(n,e,t=op)=>{if(!dp(n))throw new Error("Invalid derivation path");const{key:r,chainCode:s}=up(e);return n.split("/").slice(1).map(gc).map(a=>parseInt(a,10)).reduce((a,u)=>lp(a,u+t),{key:r,chainCode:s})},ri=32;class fc extends Qh{constructor(e){if(super(),typeof e=="string"?this.data=se(e):e instanceof Uint8Array?this.data=e:this.data=Uint8Array.from(e),this.data.length!==ri)throw new Error(`Invalid public key input. Expected ${ri} bytes, got ${this.data.length}`)}equals(e){return super.equals(e)}toRawBytes(){return this.data}flag(){return zi.ED25519}async verify(e,t){let r;if(typeof t=="string"){const s=Yh(t);if(s.signatureScheme!=="ED25519")throw new Error("Invalid signature scheme");if(!hc(this.toRawBytes(),s.publicKey))throw new Error("Signature does not match public key");r=s.signature}else r=t;return ut.verify(r,e,this.toRawBytes())}}fc.SIZE=ri;const ka="m/44'/784'/0'/0'/0'";class Bn extends tp{constructor(e){if(super(),e)this.keypair={publicKey:e.publicKey,secretKey:e.secretKey.slice(0,32)};else{const t=ut.utils.randomPrivateKey();this.keypair={publicKey:ut.getPublicKey(t),secretKey:t}}}getKeyScheme(){return"ED25519"}static generate(){const e=ut.utils.randomPrivateKey();return new Bn({publicKey:ut.getPublicKey(e),secretKey:e})}static fromSecretKey(e,t){if(typeof e=="string"){const i=np(e);if(i.schema!=="ED25519")throw new Error(`Expected a ED25519 keypair, got ${i.schema}`);return this.fromSecretKey(i.secretKey,t)}const r=e.length;if(r!==jr)throw new Error(`Wrong secretKey size. Expected ${jr} bytes, got ${r}.`);const s={publicKey:ut.getPublicKey(e),secretKey:e};if(!t||!t.skipValidation){const a=new TextEncoder().encode("sui validation"),u=ut.sign(a,e);if(!ut.verify(u,a,s.publicKey))throw new Error("provided secretKey is invalid")}return new Bn(s)}getPublicKey(){return new fc(this.keypair.publicKey)}getSecretKey(){return rp(this.keypair.secretKey.slice(0,jr),this.getKeyScheme())}async sign(e){return ut.sign(e,this.keypair.secretKey)}static deriveKeypair(e,t){if(t==null&&(t=ka),!va(t))throw new Error("Invalid derivation path");const{key:r}=Sa(t,ip(e));return Bn.fromSecretKey(r)}static deriveKeypairFromSeed(e,t){if(t==null&&(t=ka),!va(t))throw new Error("Invalid derivation path");const{key:r}=Sa(t,e);return Bn.fromSecretKey(r)}}const hs=n=>as.encode(n),si=n=>as.decode(n);function N(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0))}const $s=8192;function W(n){if(n.length<$s)return btoa(String.fromCharCode(...n));let e="";for(var t=0;t<n.length;t+=$s){const r=n.slice(t,t+$s);e+=String.fromCharCode(...r)}return btoa(e)}function mc(n){const e=n.startsWith("0x")?n.slice(2):n,t=e.length%2===0?e:`0${e}`,r=t.match(/[0-9a-fA-F]{2}/g)?.map(s=>parseInt(s,16))??[];if(r.length!==t.length/2)throw new Error(`Invalid hex string ${n}`);return Uint8Array.from(r)}function wn(n){return n.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function Vi(n,e){return Array.from({length:Math.ceil(n.length/e)},(t,r)=>n.slice(r*e,(r+1)*e))}class yc{constructor(e,t){if(typeof e!="function")throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${e}.`);this._batchLoadFn=e,this._maxBatchSize=fp(t),this._batchScheduleFn=mp(t),this._cacheKeyFn=yp(t),this._cacheMap=wp(t),this._batch=null,this.name=bp(t)}load(e){if(e==null)throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(e)}.`);const t=pp(this),r=this._cacheMap;let s;if(r){s=this._cacheKeyFn(e);const a=r.get(s);if(a){const u=t.cacheHits||(t.cacheHits=[]);return new Promise(d=>{u.push(()=>{d(a)})})}}t.keys.push(e);const i=new Promise((a,u)=>{t.callbacks.push({resolve:a,reject:u})});return r&&r.set(s,i),i}loadMany(e){if(!wc(e))throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${e}.`);const t=[];for(let r=0;r<e.length;r++)t.push(this.load(e[r]).catch(s=>s));return Promise.all(t)}clear(e){const t=this._cacheMap;if(t){const r=this._cacheKeyFn(e);t.delete(r)}return this}clearAll(){const e=this._cacheMap;return e&&e.clear(),this}prime(e,t){const r=this._cacheMap;if(r){const s=this._cacheKeyFn(e);if(r.get(s)===void 0){let i;t instanceof Error?(i=Promise.reject(t),i.catch(()=>{})):i=Promise.resolve(t),r.set(s,i)}}return this}}const hp=typeof process=="object"&&typeof process.nextTick=="function"?function(n){Es||(Es=Promise.resolve()),Es.then(()=>{process.nextTick(n)})}:typeof setImmediate=="function"?function(n){setImmediate(n)}:function(n){setTimeout(n)};let Es;function pp(n){const e=n._batch;if(e!==null&&!e.hasDispatched&&e.keys.length<n._maxBatchSize)return e;const t={hasDispatched:!1,keys:[],callbacks:[]};return n._batch=t,n._batchScheduleFn(()=>{gp(n,t)}),t}function gp(n,e){if(e.hasDispatched=!0,e.keys.length===0){ii(e);return}let t;try{t=n._batchLoadFn(e.keys)}catch(r){return Ts(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(r)}.`))}if(!t||typeof t.then!="function")return Ts(n,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(t)}.`));Promise.resolve(t).then(r=>{if(!wc(r))throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(r)}.`);if(r.length!==e.keys.length)throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(e.keys)}

Values:
${String(r)}`);ii(e);for(let s=0;s<e.callbacks.length;s++){const i=r[s];i instanceof Error?e.callbacks[s].reject(i):e.callbacks[s].resolve(i)}}).catch(r=>{Ts(n,e,r)})}function Ts(n,e,t){ii(e);for(let r=0;r<e.keys.length;r++)n.clear(e.keys[r]),e.callbacks[r].reject(t)}function ii(n){if(n.cacheHits)for(let e=0;e<n.cacheHits.length;e++)n.cacheHits[e]()}function fp(n){if(!(!n||n.batch!==!1))return 1;const t=n&&n.maxBatchSize;if(t===void 0)return 1/0;if(typeof t!="number"||t<1)throw new TypeError(`maxBatchSize must be a positive number: ${t}`);return t}function mp(n){const e=n&&n.batchScheduleFn;if(e===void 0)return hp;if(typeof e!="function")throw new TypeError(`batchScheduleFn must be a function: ${e}`);return e}function yp(n){const e=n&&n.cacheKeyFn;if(e===void 0)return t=>t;if(typeof e!="function")throw new TypeError(`cacheKeyFn must be a function: ${e}`);return e}function wp(n){if(!(!n||n.cache!==!1))return null;const t=n&&n.cacheMap;if(t===void 0)return new Map;if(t!==null){const s=["get","set","delete","clear"].filter(i=>t&&typeof t[i]!="function");if(s.length!==0)throw new TypeError("Custom cacheMap missing methods: "+s.join(", "))}return t}function bp(n){return n&&n.name?n.name:null}function wc(n){return typeof n=="object"&&n!==null&&"length"in n&&typeof n.length=="number"&&(n.length===0||n.length>0&&Object.prototype.hasOwnProperty.call(n,n.length-1))}function Yr(n){let e=BigInt(n);const t=[];let r=0;if(e===0n)return[0];for(;e>0;)t[r]=Number(e&0x7fn),(e>>=7n)&&(t[r]|=128),r+=1;return t}function vp(n){let e=0n,t=0n,r=0;for(;;){if(r>=n.length)throw new Error("ULEB decode error: buffer overflow");const s=n[r];if(r+=1,e+=BigInt(s&127)<<t,(s&128)===0)break;t+=7n}if(e>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("ULEB decode error: value exceeds MAX_SAFE_INTEGER");return{value:Number(e),length:r}}class Sp{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength)}shift(e){return this.bytePosition+=e,this}read8(){const e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){const e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){const e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){const e=this.read32(),r=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){const e=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){const e=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(e){const t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){const e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:s}=vp(t);return this.shift(s),r}readVec(e){const t=this.readULEB(),r=[];for(let s=0;s<t;s++)r.push(e(this,s,t));return r}}function kp(n,e){switch(e){case"base58":return hs(n);case"base64":return W(n);case"hex":return wn(n);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function bc(n,e=["<",">"]){const[t,r]=e,s=[];let i="",a=0;for(let u=0;u<n.length;u++){const d=n[u];if(d===t&&a++,d===r&&a--,a===0&&d===","){s.push(i.trim()),i="";continue}i+=d}return s.push(i.trim()),s}class Op{constructor({initialSize:e=1024,maxSize:t=1/0,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const r=Math.min(this.maxSize,Math.max(this.size+t,this.size+this.allocateSize));if(t>r)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=r;const s=new ArrayBuffer(this.size);new Uint8Array(s).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(s)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}writeBytes(e){this.ensureSizeOrGrow(e.length);for(let t=0;t<e.length;t++)this.dataView.setUint8(this.bytePosition+t,e[t]);return this.shift(e.length)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return Ms(BigInt(e),8).forEach(t=>this.write8(t)),this}write128(e){return Ms(BigInt(e),16).forEach(t=>this.write8(t)),this}write256(e){return Ms(BigInt(e),32).forEach(t=>this.write8(t)),this}writeULEB(e){return Yr(e).forEach(t=>this.write8(t)),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach((r,s)=>t(this,r,s,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return kp(this.toBytes(),e)}}function Ms(n,e){const t=new Uint8Array(e);let r=0;for(;n>0;)t[r]=Number(n%BigInt(256)),n=n/BigInt(256),r+=1;return t}var vc=n=>{throw TypeError(n)},Sc=(n,e,t)=>e.has(n)||vc("Cannot "+t),Re=(n,e,t)=>(Sc(n,e,"read from private field"),t?t.call(n):e.get(n)),Xr=(n,e,t)=>e.has(n)?vc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),es=(n,e,t,r)=>(Sc(n,e,"write to private field"),e.set(n,t),t),hn,Dn,Cr,Ot;const Ip=class kc{constructor(e){Xr(this,hn),Xr(this,Dn),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),es(this,hn,e.write),es(this,Dn,e.serialize??((t,r)=>{const s=new Op({initialSize:this.serializedSize(t)??void 0,...r});return Re(this,hn).call(this,t,s),s.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),Re(this,hn).call(this,e,t)}serialize(e,t){return this.validate(e),new $p(this,Re(this,Dn).call(this,e,t))}parse(e){const t=new Sp(e);return this.read(t)}fromHex(e){return this.parse(mc(e))}fromBase58(e){return this.parse(si(e))}fromBase64(e){return this.parse(N(e))}transform({name:e,input:t,output:r,validate:s}){return new kc({name:e??this.name,read:i=>r?r(this.read(i)):this.read(i),write:(i,a)=>Re(this,hn).call(this,t?t(i):i,a),serializedSize:i=>this.serializedSize(t?t(i):i),serialize:(i,a)=>Re(this,Dn).call(this,t?t(i):i,a),validate:i=>{s?.(i),this.validate(t?t(i):i)}})}};hn=new WeakMap;Dn=new WeakMap;let rt=Ip;const Oc=Symbol.for("@mysten/serialized-bcs");function Li(n){return!!n&&typeof n=="object"&&n[Oc]===!0}class $p{constructor(e,t){Xr(this,Cr),Xr(this,Ot),es(this,Cr,e),es(this,Ot,t)}get[Oc](){return!0}toBytes(){return Re(this,Ot)}toHex(){return wn(Re(this,Ot))}toBase64(){return W(Re(this,Ot))}toBase58(){return hs(Re(this,Ot))}parse(){return Re(this,Cr).parse(Re(this,Ot))}}Cr=new WeakMap;Ot=new WeakMap;function ts({size:n,...e}){return new rt({...e,serializedSize:()=>n})}function js({readMethod:n,writeMethod:e,...t}){return ts({...t,read:r=>r[n](),write:(r,s)=>s[e](r),validate:r=>{if(r<0||r>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${r}. Expected value in range 0-${t.maxValue}`);t.validate?.(r)}})}function Cs({readMethod:n,writeMethod:e,...t}){return ts({...t,read:r=>r[n](),write:(r,s)=>s[e](BigInt(r)),validate:r=>{const s=BigInt(r);if(s<0||s>t.maxValue)throw new TypeError(`Invalid ${t.name} value: ${s}. Expected value in range 0-${t.maxValue}`);t.validate?.(s)}})}function Ep({serialize:n,...e}){const t=new rt({...e,serialize:n,write:(r,s)=>{for(const i of t.serialize(r).toBytes())s.write8(i)}});return t}function Tp({toBytes:n,fromBytes:e,...t}){return new rt({...t,read:r=>{const s=r.readULEB(),i=r.readBytes(s);return e(i)},write:(r,s)=>{const i=n(r);s.writeULEB(i.length);for(let a=0;a<i.length;a++)s.write8(i[a])},serialize:r=>{const s=n(r),i=Yr(s.length),a=new Uint8Array(i.length+s.length);return a.set(i,0),a.set(s,i.length),a},validate:r=>{if(typeof r!="string")throw new TypeError(`Invalid ${t.name} value: ${r}. Expected string`);t.validate?.(r)}})}function Mp(n){let e=null;function t(){return e||(e=n()),e}return new rt({name:"lazy",read:r=>t().read(r),serializedSize:r=>t().serializedSize(r),write:(r,s)=>t().write(r,s),serialize:(r,s)=>t().serialize(r,s).toBytes()})}class jp extends rt{constructor({name:e,fields:t,...r}){const s=Object.entries(t);super({name:e,serializedSize:i=>{let a=0;for(const[u,d]of s){const b=d.serializedSize(i[u]);if(b==null)return null;a+=b}return a},read:i=>{const a={};for(const[u,d]of s)a[u]=d.read(i);return a},write:(i,a)=>{for(const[u,d]of s)d.write(i[u],a)},...r,validate:i=>{if(r?.validate?.(i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})}}class Cp extends rt{constructor({fields:e,...t}){const r=Object.entries(e);super({read:s=>{const i=s.readULEB(),a=r[i];if(!a)throw new TypeError(`Unknown value ${i} for enum ${t.name}`);const[u,d]=a;return{[u]:d?.read(s)??!0,$kind:u}},write:(s,i)=>{const[a,u]=Object.entries(s).filter(([d])=>Object.hasOwn(e,d))[0];for(let d=0;d<r.length;d++){const[b,h]=r[d];if(b===a){i.writeULEB(d),h?.write(u,i);return}}},...t,validate:s=>{if(t?.validate?.(s),typeof s!="object"||s==null)throw new TypeError(`Expected object, found ${typeof s}`);const i=Object.keys(s).filter(u=>s[u]!==void 0&&Object.hasOwn(e,u));if(i.length!==1)throw new TypeError(`Expected object with one key, but found ${i.length} for type ${t.name}}`);const[a]=i;if(!Object.hasOwn(e,a))throw new TypeError(`Invalid enum variant ${a}`)}})}}class Ap extends rt{constructor({fields:e,name:t,...r}){super({name:t??`(${e.map(s=>s.name).join(", ")})`,serializedSize:s=>{let i=0;for(let a=0;a<e.length;a++){const u=e[a].serializedSize(s[a]);if(u==null)return null;i+=u}return i},read:s=>{const i=[];for(const a of e)i.push(a.read(s));return i},write:(s,i)=>{for(let a=0;a<e.length;a++)e[a].write(s[a],i)},...r,validate:s=>{if(r?.validate?.(s),!Array.isArray(s))throw new TypeError(`Expected array, found ${typeof s}`);if(s.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${s.length}`)}})}}function _p(n,e,t){return new rt({read:r=>{const s=new Array(n);for(let i=0;i<n;i++)s[i]=e.read(r);return s},write:(r,s)=>{for(const i of r)e.write(i,s)},...t,name:t?.name??`${e.name}[${n}]`,validate:r=>{if(t?.validate?.(r),!r||typeof r!="object"||!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==n)throw new TypeError(`Expected array of length ${n}, found ${r.length}`)}})}function Pp(n){return c.enum(`Option<${n.name}>`,{None:null,Some:n}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>e.$kind==="Some"?e.Some:null})}function xp(n,e){return new rt({read:t=>{const r=t.readULEB(),s=new Array(r);for(let i=0;i<r;i++)s[i]=n.read(t);return s},write:(t,r)=>{r.writeULEB(t.length);for(const s of t)n.write(s,r)},...e,name:e?.name??`vector<${n.name}>`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`)}})}function Np(n,e){return c.vector(c.tuple([n,e])).transform({name:`Map<${n.name}, ${e.name}>`,input:t=>[...t.entries()],output:t=>{const r=new Map;for(const[s,i]of t)r.set(s,i);return r}})}const c={u8(n){return js({readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...n,name:n?.name??"u8"})},u16(n){return js({readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...n,name:n?.name??"u16"})},u32(n){return js({readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...n,name:n?.name??"u32"})},u64(n){return Cs({readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...n,name:n?.name??"u64"})},u128(n){return Cs({readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...n,name:n?.name??"u128"})},u256(n){return Cs({readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...n,name:n?.name??"u256"})},bool(n){return ts({size:1,read:e=>e.read8()===1,write:(e,t)=>t.write8(e?1:0),...n,name:n?.name??"bool",validate:e=>{if(n?.validate?.(e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(n){return Ep({read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Yr(e)),...n,name:n?.name??"uleb128"})},bytes(n,e){return ts({size:n,read:t=>t.readBytes(n),write:(t,r)=>{r.writeBytes(new Uint8Array(t))},...e,name:e?.name??`bytes[${n}]`,validate:t=>{if(e?.validate?.(t),!t||typeof t!="object"||!("length"in t))throw new TypeError(`Expected array, found ${typeof t}`);if(t.length!==n)throw new TypeError(`Expected array of length ${n}, found ${t.length}`)}})},byteVector(n){return new rt({read:e=>{const t=e.readULEB();return e.readBytes(t)},write:(e,t)=>{const r=new Uint8Array(e);t.writeULEB(r.length),t.writeBytes(r)},...n,name:n?.name??"vector<u8>",serializedSize:e=>{const t="length"in e?e.length:null;return t==null?null:Yr(t).length+t},validate:e=>{if(n?.validate?.(e),!e||typeof e!="object"||!("length"in e))throw new TypeError(`Expected array, found ${typeof e}`)}})},string(n){return Tp({toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...n,name:n?.name??"string"})},fixedArray:_p,option:Pp,vector:xp,tuple(n,e){return new Ap({fields:n,...e})},struct(n,e,t){return new jp({name:n,fields:e,...t})},enum(n,e,t){return new Cp({name:n,fields:e,...t})},map:Np,lazy(n){return Mp(n)}},Up=/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i,Rp=/^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i,Bp=235;function Dp(n){return n.length>Bp?!1:n.includes("@")?Up.test(n):Rp.test(n)}const zp=/^([a-z0-9]+(?:-[a-z0-9]+)*)$/,Vp=/^\d+$/,Lp=64,Ic="/",ps=n=>{const e=n.split(Ic);if(e.length<2||e.length>3)return!1;const[t,r,s]=e;return s!==void 0&&!Vp.test(s)||!Dp(t)?!1:zp.test(r)&&r.length<Lp},Wp=n=>{const e=n.split(/::|<|>|,/);for(const t of e)if(t.includes(Ic)&&!ps(t))return!1;return!0},kn=32;function ns(n){return Gp(n)&&Kp(n)===kn}function Fp(n){return n.includes("::")?en(n):n}function en(n){const[e,t]=n.split("::"),r=ps(e),s=n.slice(e.length+t.length+4),i=s.includes("<")?s.slice(0,s.indexOf("<")):s,a=s.includes("<")?bc(s.slice(s.indexOf("<")+1,s.lastIndexOf(">"))).map(u=>Fp(u.trim())):[];return{address:r?e:A(e),module:t,name:i,typeParams:a}}function nr(n){const{address:e,module:t,name:r,typeParams:s}=typeof n=="string"?en(n):n,i=s?.length>0?`<${s.map(a=>typeof a=="string"?a:nr(a)).join(",")}>`:"";return`${e}::${t}::${r}${i}`}function A(n,e=!1){let t=n.toLowerCase();return!e&&t.startsWith("0x")&&(t=t.slice(2)),`0x${t.padStart(kn*2,"0")}`}function bn(n,e=!1){return A(n,e)}function Gp(n){return/^(0x|0X)?[a-fA-F0-9]+$/.test(n)&&n.length%2===0}function Kp(n){return/^(0x|0X)/.test(n)?(n.length-2)/2:n.length/2}const qp=/^vector<(.+)>$/,Jp=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class De{static parseFromStr(e,t=!1){if(e==="address")return{address:null};if(e==="bool")return{bool:null};if(e==="u8")return{u8:null};if(e==="u16")return{u16:null};if(e==="u32")return{u32:null};if(e==="u64")return{u64:null};if(e==="u128")return{u128:null};if(e==="u256")return{u256:null};if(e==="signer")return{signer:null};const r=e.match(qp);if(r)return{vector:De.parseFromStr(r[1],t)};const s=e.match(Jp);if(s)return{struct:{address:t?A(s[1]):s[1],module:s[2],name:s[3],typeParams:s[5]===void 0?[]:De.parseStructTypeArgs(s[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return bc(e).map(r=>De.parseFromStr(r,t))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${De.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(De.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}function Zp(n){return c.u64({name:"unsafe_u64",...n}).transform({input:e=>e,output:e=>Number(e)})}function Hp(n){return c.enum("Option",{None:null,Some:n})}const D=c.bytes(kn).transform({validate:n=>{const e=typeof n=="string"?n:wn(n);if(!e||!ns(A(e)))throw new Error(`Invalid Sui address ${e}`)},input:n=>typeof n=="string"?mc(A(n)):n,output:n=>A(wn(n))}),Le=c.byteVector().transform({name:"ObjectDigest",input:n=>si(n),output:n=>hs(new Uint8Array(n)),validate:n=>{if(si(n).length!==32)throw new Error("ObjectDigest must be 32 bytes")}}),Oe=c.struct("SuiObjectRef",{objectId:D,version:c.u64(),digest:Le}),$c=c.struct("SharedObjectRef",{objectId:D,initialSharedVersion:c.u64(),mutable:c.bool()}),Ec=c.enum("ObjectArg",{ImmOrOwnedObject:Oe,SharedObject:$c,Receiving:Oe}),qt=c.enum("Owner",{AddressOwner:D,ObjectOwner:D,Shared:c.struct("Shared",{initialSharedVersion:c.u64()}),Immutable:null,ConsensusAddressOwner:c.struct("ConsensusAddressOwner",{owner:D,startVersion:c.u64()})}),Tc=c.enum("CallArg",{Pure:c.struct("Pure",{bytes:c.byteVector().transform({input:n=>typeof n=="string"?N(n):n,output:n=>W(new Uint8Array(n))})}),Object:Ec}),Wi=c.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:c.lazy(()=>Wi),struct:c.lazy(()=>Pc),u16:null,u32:null,u256:null}),Fi=Wi.transform({input:n=>typeof n=="string"?De.parseFromStr(n,!0):n,output:n=>De.tagToString(n)}),Ze=c.enum("Argument",{GasCoin:null,Input:c.u16(),Result:c.u16(),NestedResult:c.tuple([c.u16(),c.u16()])}),Mc=c.struct("ProgrammableMoveCall",{package:D,module:c.string(),function:c.string(),typeArguments:c.vector(Fi),arguments:c.vector(Ze)}),jc=c.enum("Command",{MoveCall:Mc,TransferObjects:c.struct("TransferObjects",{objects:c.vector(Ze),address:Ze}),SplitCoins:c.struct("SplitCoins",{coin:Ze,amounts:c.vector(Ze)}),MergeCoins:c.struct("MergeCoins",{destination:Ze,sources:c.vector(Ze)}),Publish:c.struct("Publish",{modules:c.vector(c.byteVector().transform({input:n=>typeof n=="string"?N(n):n,output:n=>W(new Uint8Array(n))})),dependencies:c.vector(D)}),MakeMoveVec:c.struct("MakeMoveVec",{type:Hp(Fi).transform({input:n=>n===null?{None:!0}:{Some:n},output:n=>n.Some??null}),elements:c.vector(Ze)}),Upgrade:c.struct("Upgrade",{modules:c.vector(c.byteVector().transform({input:n=>typeof n=="string"?N(n):n,output:n=>W(new Uint8Array(n))})),dependencies:c.vector(D),package:D,ticket:Ze})}),Cc=c.struct("ProgrammableTransaction",{inputs:c.vector(Tc),commands:c.vector(jc)}),Ac=c.enum("TransactionKind",{ProgrammableTransaction:Cc,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),_c=c.enum("TransactionExpiration",{None:null,Epoch:Zp()}),Pc=c.struct("StructTag",{address:D,module:c.string(),name:c.string(),typeParams:c.vector(Wi)}),xc=c.struct("GasData",{payment:c.vector(Oe),owner:D,price:c.u64(),budget:c.u64()}),Nc=c.struct("TransactionDataV1",{kind:Ac,sender:D,gasData:xc,expiration:_c}),Uc=c.enum("TransactionData",{V1:Nc}),Rc=c.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),Bc=c.enum("IntentVersion",{V0:null}),Dc=c.enum("AppId",{Sui:null}),zc=c.struct("Intent",{scope:Rc,version:Bc,appId:Dc});function Vc(n){return c.struct(`IntentMessage<${n.name}>`,{intent:zc,value:n})}const Lc=c.enum("CompressedSignature",{ED25519:c.bytes(64),Secp256k1:c.bytes(64),Secp256r1:c.bytes(64),ZkLogin:c.byteVector(),Passkey:c.byteVector()}),Wc=c.enum("PublicKey",{ED25519:c.bytes(32),Secp256k1:c.bytes(33),Secp256r1:c.bytes(33),ZkLogin:c.byteVector(),Passkey:c.bytes(33)}),Fc=c.struct("MultiSigPkMap",{pubKey:Wc,weight:c.u8()}),Gc=c.struct("MultiSigPublicKey",{pk_map:c.vector(Fc),threshold:c.u16()}),Qp=c.struct("MultiSig",{sigs:c.vector(Lc),bitmap:c.u16(),multisig_pk:Gc}),Yp=c.byteVector().transform({input:n=>typeof n=="string"?N(n):n,output:n=>W(new Uint8Array(n))}),Kc=c.struct("SenderSignedTransaction",{intentMessage:Vc(Uc),txSignatures:c.vector(Yp)}),Xp=c.vector(Kc,{name:"SenderSignedData"}),qc=c.struct("PasskeyAuthenticator",{authenticatorData:c.byteVector(),clientDataJson:c.string(),userSignature:c.byteVector()}),eg=c.enum("PackageUpgradeError",{UnableToFetchPackage:c.struct("UnableToFetchPackage",{packageId:D}),NotAPackage:c.struct("NotAPackage",{objectId:D}),IncompatibleUpgrade:null,DigestDoesNotMatch:c.struct("DigestDoesNotMatch",{digest:c.byteVector()}),UnknownUpgradePolicy:c.struct("UnknownUpgradePolicy",{policy:c.u8()}),PackageIDDoesNotMatch:c.struct("PackageIDDoesNotMatch",{packageId:D,ticketId:D})}),tg=c.struct("ModuleId",{address:D,name:c.string()}),Oa=c.struct("MoveLocation",{module:tg,function:c.u16(),instruction:c.u16(),functionName:c.option(c.string())}),ng=c.enum("CommandArgumentError",{TypeMismatch:null,InvalidBCSBytes:null,InvalidUsageOfPureArg:null,InvalidArgumentToPrivateEntryFunction:null,IndexOutOfBounds:c.struct("IndexOutOfBounds",{idx:c.u16()}),SecondaryIndexOutOfBounds:c.struct("SecondaryIndexOutOfBounds",{resultIdx:c.u16(),secondaryIdx:c.u16()}),InvalidResultArity:c.struct("InvalidResultArity",{resultIdx:c.u16()}),InvalidGasCoinUsage:null,InvalidValueUsage:null,InvalidObjectByValue:null,InvalidObjectByMutRef:null,SharedObjectOperationNotAllowed:null}),rg=c.enum("TypeArgumentError",{TypeNotFound:null,ConstraintNotSatisfied:null}),sg=c.enum("ExecutionFailureStatus",{InsufficientGas:null,InvalidGasObject:null,InvariantViolation:null,FeatureNotYetSupported:null,MoveObjectTooBig:c.struct("MoveObjectTooBig",{objectSize:c.u64(),maxObjectSize:c.u64()}),MovePackageTooBig:c.struct("MovePackageTooBig",{objectSize:c.u64(),maxObjectSize:c.u64()}),CircularObjectOwnership:c.struct("CircularObjectOwnership",{object:D}),InsufficientCoinBalance:null,CoinBalanceOverflow:null,PublishErrorNonZeroAddress:null,SuiMoveVerificationError:null,MovePrimitiveRuntimeError:c.option(Oa),MoveAbort:c.tuple([Oa,c.u64()]),VMVerificationOrDeserializationError:null,VMInvariantViolation:null,FunctionNotFound:null,ArityMismatch:null,TypeArityMismatch:null,NonEntryFunctionInvoked:null,CommandArgumentError:c.struct("CommandArgumentError",{argIdx:c.u16(),kind:ng}),TypeArgumentError:c.struct("TypeArgumentError",{argumentIdx:c.u16(),kind:rg}),UnusedValueWithoutDrop:c.struct("UnusedValueWithoutDrop",{resultIdx:c.u16(),secondaryIdx:c.u16()}),InvalidPublicFunctionReturnType:c.struct("InvalidPublicFunctionReturnType",{idx:c.u16()}),InvalidTransferObject:null,EffectsTooLarge:c.struct("EffectsTooLarge",{currentSize:c.u64(),maxSize:c.u64()}),PublishUpgradeMissingDependency:null,PublishUpgradeDependencyDowngrade:null,PackageUpgradeError:c.struct("PackageUpgradeError",{upgradeError:eg}),WrittenObjectsTooLarge:c.struct("WrittenObjectsTooLarge",{currentSize:c.u64(),maxSize:c.u64()}),CertificateDenied:null,SuiMoveVerificationTimedout:null,SharedObjectOperationNotAllowed:null,InputObjectDeleted:null,ExecutionCancelledDueToSharedObjectCongestion:c.struct("ExecutionCancelledDueToSharedObjectCongestion",{congestedObjects:c.vector(D)}),AddressDeniedForCoin:c.struct("AddressDeniedForCoin",{address:D,coinType:c.string()}),CoinTypeGlobalPause:c.struct("CoinTypeGlobalPause",{coinType:c.string()}),ExecutionCancelledDueToRandomnessUnavailable:null}),Jc=c.enum("ExecutionStatus",{Success:null,Failed:c.struct("ExecutionFailed",{error:sg,command:c.option(c.u64())})}),Zc=c.struct("GasCostSummary",{computationCost:c.u64(),storageCost:c.u64(),storageRebate:c.u64(),nonRefundableStorageFee:c.u64()}),ig=c.struct("TransactionEffectsV1",{status:Jc,executedEpoch:c.u64(),gasUsed:Zc,modifiedAtVersions:c.vector(c.tuple([D,c.u64()])),sharedObjects:c.vector(Oe),transactionDigest:Le,created:c.vector(c.tuple([Oe,qt])),mutated:c.vector(c.tuple([Oe,qt])),unwrapped:c.vector(c.tuple([Oe,qt])),deleted:c.vector(Oe),unwrappedThenDeleted:c.vector(Oe),wrapped:c.vector(Oe),gasObject:c.tuple([Oe,qt]),eventsDigest:c.option(Le),dependencies:c.vector(Le)}),Gi=c.tuple([c.u64(),Le]),ag=c.enum("ObjectIn",{NotExist:null,Exist:c.tuple([Gi,qt])}),og=c.enum("ObjectOut",{NotExist:null,ObjectWrite:c.tuple([Le,qt]),PackageWrite:Gi}),cg=c.enum("IDOperation",{None:null,Created:null,Deleted:null}),ug=c.struct("EffectsObjectChange",{inputState:ag,outputState:og,idOperation:cg}),lg=c.enum("UnchangedSharedKind",{ReadOnlyRoot:Gi,MutateDeleted:c.u64(),ReadDeleted:c.u64(),Cancelled:c.u64(),PerEpochConfig:null}),dg=c.struct("TransactionEffectsV2",{status:Jc,executedEpoch:c.u64(),gasUsed:Zc,transactionDigest:Le,gasObjectIndex:c.option(c.u32()),eventsDigest:c.option(Le),dependencies:c.vector(Le),lamportVersion:c.u64(),changedObjects:c.vector(c.tuple([D,ug])),unchangedSharedObjects:c.vector(c.tuple([D,lg])),auxDataDigest:c.option(Le)}),hg=c.enum("TransactionEffects",{V1:ig,V2:dg});function Zn(n){switch(n){case"u8":return c.u8();case"u16":return c.u16();case"u32":return c.u32();case"u64":return c.u64();case"u128":return c.u128();case"u256":return c.u256();case"bool":return c.bool();case"string":return c.string();case"id":case"address":return D}const e=n.match(/^(vector|option)<(.+)>$/);if(e){const[t,r]=e.slice(1);return t==="vector"?c.vector(Zn(r)):c.option(Zn(r))}throw new Error(`Invalid Pure type name: ${n}`)}const M={...c,U8:c.u8(),U16:c.u16(),U32:c.u32(),U64:c.u64(),U128:c.u128(),U256:c.u256(),ULEB128:c.uleb128(),Bool:c.bool(),String:c.string(),Address:D,AppId:Dc,Argument:Ze,CallArg:Tc,Command:jc,CompressedSignature:Lc,GasData:xc,Intent:zc,IntentMessage:Vc,IntentScope:Rc,IntentVersion:Bc,MultiSig:Qp,MultiSigPkMap:Fc,MultiSigPublicKey:Gc,ObjectArg:Ec,ObjectDigest:Le,Owner:qt,PasskeyAuthenticator:qc,ProgrammableMoveCall:Mc,ProgrammableTransaction:Cc,PublicKey:Wc,SenderSignedData:Xp,SenderSignedTransaction:Kc,SharedObjectRef:$c,StructTag:Pc,SuiObjectRef:Oe,TransactionData:Uc,TransactionDataV1:Nc,TransactionEffects:hg,TransactionExpiration:_c,TransactionKind:Ac,TypeTag:Fi};function Hc(n,e){return M.IntentMessage(M.bytes(e.length)).serialize({intent:{scope:{[n]:!0},version:{V0:!0},appId:{Sui:!0}},value:e}).toBytes()}const rn={ED25519:0,Secp256k1:1,Secp256r1:2,MultiSig:3,ZkLogin:5,Passkey:6},pg={ED25519:32,Secp256k1:33,Secp256r1:33,Passkey:33},Qc={0:"ED25519",1:"Secp256k1",2:"Secp256r1",3:"MultiSig",5:"ZkLogin",6:"Passkey"};function rs(n,e){if(n===e)return!0;if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}class Ki{equals(e){return rs(this.toRawBytes(),e.toRawBytes())}toBase64(){return W(this.toRawBytes())}toString(){throw new Error("`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.")}toSuiPublicKey(){const e=this.toSuiBytes();return W(e)}verifyWithIntent(e,t,r){const s=Hc(r,e),i=Fe(s,{dkLen:32});return this.verify(i,t)}verifyPersonalMessage(e,t){return this.verifyWithIntent(M.byteVector().serialize(e).toBytes(),t,"PersonalMessage")}verifyTransaction(e,t){return this.verifyWithIntent(e,t,"TransactionData")}verifyAddress(e){return this.toSuiAddress()===e}toSuiBytes(){const e=this.toRawBytes(),t=new Uint8Array(e.length+1);return t.set([this.flag()]),t.set(e,1),t}toSuiAddress(){return A(Ii(Fe(this.toSuiBytes(),{dkLen:32})).slice(0,kn*2))}}function gg(n){const e=N(n),t=Qc[e[0]];switch(t){case"ED25519":case"Secp256k1":case"Secp256r1":const r=pg[t],s=e.slice(1,e.length-r),i=e.slice(1+s.length);return{serializedSignature:n,signatureScheme:t,signature:s,publicKey:i,bytes:e};default:throw new Error("Unsupported signature scheme")}}const ai=33,oi=64;class fg extends Ki{constructor(e){if(super(),typeof e=="string"?this.data=N(e):e instanceof Uint8Array?this.data=e:this.data=Uint8Array.from(e),this.data.length!==ai)throw new Error(`Invalid public key input. Expected ${ai} bytes, got ${this.data.length}`)}equals(e){return super.equals(e)}toRawBytes(){return this.data}flag(){return rn.Passkey}async verify(e,t){const r=Yc(t),s=JSON.parse(r.clientDataJson);if(s.type!=="webauthn.get")return!1;const i=N(s.challenge.replace(/-/g,"+").replace(/_/g,"/"));if(!rs(e,i))return!1;const a=r.userSignature.slice(1+oi);if(!rs(this.toRawBytes(),a))return!1;const u=new Uint8Array([...r.authenticatorData,...Ns(r.clientDataJson)]),d=r.userSignature.slice(1,oi+1);return Vr.verify(d,Ns(u),a)}}fg.SIZE=ai;function Yc(n){const e=typeof n=="string"?N(n):n;if(e[0]!==rn.Passkey)throw new Error("Invalid signature scheme");const t=qc.parse(e.slice(1));return{signatureScheme:"Passkey",serializedSignature:W(e),signature:e,authenticatorData:t.authenticatorData,clientDataJson:t.clientDataJson,userSignature:new Uint8Array(t.userSignature),publicKey:new Uint8Array(t.userSignature.slice(1+oi))}}var Xc=n=>{throw TypeError(n)},eu=(n,e,t)=>e.has(n)||Xc("Cannot "+t),te=(n,e,t)=>(eu(n,e,"read from private field"),e.get(n)),Ia=(n,e,t)=>e.has(n)?Xc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),$a=(n,e,t,r)=>(eu(n,e,"write to private field"),e.set(n,t),t),Vt,oe;const mg=class tu{constructor({prefix:e,cache:t}={}){Ia(this,Vt),Ia(this,oe),$a(this,Vt,e??[]),$a(this,oe,t??new Map)}read(e,t){const r=[te(this,Vt),...e].join(":");if(te(this,oe).has(r))return te(this,oe).get(r);const s=t();return te(this,oe).set(r,s),typeof s=="object"&&s!==null&&"then"in s?Promise.resolve(s).then(i=>(te(this,oe).set(r,i),i)).catch(i=>{throw te(this,oe).delete(r),i}):s}readSync(e,t){const r=[te(this,Vt),...e].join(":");if(te(this,oe).has(r))return te(this,oe).get(r);const s=t();return te(this,oe).set(r,s),s}clear(e){const t=[...te(this,Vt),...e??[]].join(":");if(!t){te(this,oe).clear();return}for(const r of te(this,oe).keys())r.startsWith(t)&&te(this,oe).delete(r)}scope(e){return new tu({prefix:[...te(this,Vt),...Array.isArray(e)?e:[e]],cache:te(this,oe)})}};Vt=new WeakMap;oe=new WeakMap;let yg=mg;class nu{constructor({network:e,base:t,cache:r=t?.cache??new yg}){this.network=e,this.base=t??this,this.cache=r}$extend(...e){return Object.create(this,Object.fromEntries(e.map(t=>[t.name,{value:t.register(this)}])))}}function ru(n,e,t){const r=M.Address.serialize(n).toBytes(),s=M.TypeTag.serialize(e).toBytes(),i=M.u64().serialize(t.length).toBytes(),a=Fe.create({dkLen:32});return a.update(new Uint8Array([240])),a.update(r),a.update(i),a.update(t),a.update(s),`0x${wn(a.digest().slice(0,32))}`}const wg="1.43.1";var su=n=>{throw TypeError(n)},qi=(n,e,t)=>e.has(n)||su("Cannot "+t),Y=(n,e,t)=>(qi(n,e,"read from private field"),t?t.call(n):e.get(n)),Tn=(n,e,t)=>e.has(n)?su("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),dr=(n,e,t,r)=>(qi(n,e,"write to private field"),e.set(n,t),t),gs=(n,e,t)=>(qi(n,e,"access private method"),t),rr,yt,sr,Tt,Qe,ci,ui,iu,au,Ji;const bg="/",vg={"Mvr-Source":`@mysten/sui@${wg}`};class Sg{constructor({cache:e,url:t,pageSize:r=50,overrides:s}){Tn(this,Qe),Tn(this,rr),Tn(this,yt),Tn(this,sr),Tn(this,Tt),dr(this,rr,e),dr(this,yt,t),dr(this,sr,r),dr(this,Tt,{packages:s?.packages,types:s?.types}),kg(Y(this,Tt))}async resolvePackage({package:e}){return Ye(e)?{package:await Y(this,Qe,ci).load(e)}:{package:e}}async resolveType({type:e}){if(!Ye(e))return{type:e};const t=[...li(e)],r=await Y(this,Qe,ui).loadMany(t),s={};for(let i=0;i<t.length;i++){const a=r[i];if(a instanceof Error)throw a;s[t[i]]=a}return{type:di(e,s)}}async resolve({types:e=[],packages:t=[]}){const r=new Set;for(const h of e??[])li(h,r);const s=[...r],[i,a]=await Promise.all([s.length>0?Y(this,Qe,ui).loadMany(s):[],t.length>0?Y(this,Qe,ci).loadMany(t):[]]),u={...Y(this,Tt)?.types};for(const[h,w]of s.entries()){const j=i[h];if(j instanceof Error)throw j;u[w]=j}const d={};for(const h of e??[]){const w=di(h,u);d[h]={type:w}}const b={};for(const[h,w]of(t??[]).entries()){const j=Y(this,Tt)?.packages?.[w]??a[h];if(j instanceof Error)throw j;b[w]={package:j}}return{types:d,packages:b}}}rr=new WeakMap;yt=new WeakMap;sr=new WeakMap;Tt=new WeakMap;Qe=new WeakSet;ci=function(){return Y(this,rr).readSync(["#mvrPackageDataLoader",Y(this,yt)??""],()=>{const n=new yc(async t=>{if(!Y(this,yt))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await gs(this,Qe,iu).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve package: ${s}`))}),e=Y(this,Tt)?.packages;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})};ui=function(){return Y(this,rr).readSync(["#mvrTypeDataLoader",Y(this,yt)??""],()=>{const n=new yc(async t=>{if(!Y(this,yt))throw new Error(`MVR Api URL is not set for the current client (resolving ${t.join(", ")})`);const r=await gs(this,Qe,au).call(this,t);return t.map(s=>r[s]??new Error(`Failed to resolve type: ${s}`))}),e=Y(this,Tt)?.types;if(e)for(const[t,r]of Object.entries(e))n.prime(t,r);return n})};iu=async function(n){if(n.length===0)return{};const e=Vi(n,Y(this,sr)),t={};return await Promise.all(e.map(async r=>{const s=await gs(this,Qe,Ji).call(this,"/v1/resolution/bulk",{names:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.package_id;a&&(t[i]=a)}})),t};au=async function(n){if(n.length===0)return{};const e=Vi(n,Y(this,sr)),t={};return await Promise.all(e.map(async r=>{const s=await gs(this,Qe,Ji).call(this,"/v1/struct-definition/bulk",{types:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.type_tag;a&&(t[i]=a)}})),t};Ji=async function(n,e){if(!Y(this,yt))throw new Error("MVR Api URL is not set for the current client");const t=await fetch(`${Y(this,yt)}${n}`,{method:"POST",headers:{"Content-Type":"application/json",...vg},body:JSON.stringify(e)});if(!t.ok){const r=await t.json().catch(()=>({}));throw new Error(`Failed to resolve types: ${r?.message}`)}return t.json()};function kg(n){if(n?.packages)for(const[e,t]of Object.entries(n.packages)){if(!ps(e))throw new Error(`Invalid package name: ${e}`);if(!ns(A(t)))throw new Error(`Invalid package ID: ${t}`)}if(n?.types)for(const[e,t]of Object.entries(n.types)){if(en(e).typeParams.length>0)throw new Error("Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.");const r=en(t);if(!ns(r.address))throw new Error(`Invalid type: ${t}`)}}function li(n,e=new Set){if(typeof n=="string"&&!Ye(n))return e;const t=ou(n)?n:en(n);Ye(t.address)&&e.add(`${t.address}::${t.module}::${t.name}`);for(const r of t.typeParams)li(r,e);return e}function di(n,e){const t=ou(n)?n:en(n),r=`${t.address}::${t.module}::${t.name}`,s=e[r];return nr({...t,address:s?s.split("::")[0]:t.address,typeParams:t.typeParams.map(i=>di(i,e))})}function Ye(n){return n.includes(bg)||n.includes("@")||n.includes(".sui")}function ou(n){return typeof n=="object"&&"address"in n&&"module"in n&&"name"in n&&"typeParams"in n}function Og(n){const e=new Set,t=new Set;for(const r of n.commands)switch(r.$kind){case"MakeMoveVec":r.MakeMoveVec.type&&Ea([r.MakeMoveVec.type]).forEach(a=>{t.add(a)});break;case"MoveCall":const s=r.MoveCall,i=s.package.split("::")[0];if(Ye(i)){if(!ps(i))throw new Error(`Invalid package name: ${i}`);e.add(i)}Ea(s.typeArguments??[]).forEach(a=>{t.add(a)});break}return{packages:[...e],types:[...t]}}function Ig(n,e){for(const t of n.commands){if(t.MakeMoveVec?.type){if(!Ye(t.MakeMoveVec.type))continue;if(!e.types[t.MakeMoveVec.type])throw new Error(`No resolution found for type: ${t.MakeMoveVec.type}`);t.MakeMoveVec.type=e.types[t.MakeMoveVec.type].type}const r=t.MoveCall;if(!r)continue;const s=r.package.split("::"),i=s[0];if(Ye(i)&&!e.packages[i])throw new Error(`No address found for package: ${i}`);Ye(i)&&(s[0]=e.packages[i].package,r.package=s.join("::"));const a=r.typeArguments;if(a){for(let u=0;u<a.length;u++)if(Ye(a[u])){if(!e.types[a[u]])throw new Error(`No resolution found for type: ${a[u]}`);a[u]=e.types[a[u]].type}r.typeArguments=a}}}function Ea(n){const e=new Set;for(const t of n)if(Ye(t)){if(!Wp(t))throw new Error(`Invalid type with names: ${t}`);e.add(t)}return e}const $g={mainnet:"https://mainnet.mvr.mystenlabs.com",testnet:"https://testnet.mvr.mystenlabs.com"};class Eg extends nu{constructor(e){super(e),this.core=this,this.mvr=new Sg({cache:this.cache.scope("core.mvr"),url:e.mvr?.url??$g[this.network],pageSize:e.mvr?.pageSize,overrides:e.mvr?.overrides})}async getObject(e){const{objectId:t}=e,{objects:[r]}=await this.getObjects({objectIds:[t],signal:e.signal});if(r instanceof Error)throw r;return{object:r}}async getDynamicField(e){const t=De.parseFromStr((await this.core.mvr.resolveType({type:e.name.type})).type),r=ru(e.parentId,t,e.name.bcs),{objects:[s]}=await this.getObjects({objectIds:[r],signal:e.signal});if(s instanceof Error)throw s;const i=en(s.type),a=await s.content;return{dynamicField:{id:s.id,digest:s.digest,version:s.version,type:s.type,previousTransaction:s.previousTransaction,name:{type:typeof i.typeParams[0]=="string"?i.typeParams[0]:nr(i.typeParams[0]),bcs:e.name.bcs},value:{type:typeof i.typeParams[1]=="string"?i.typeParams[1]:nr(i.typeParams[1]),bcs:a.slice(kn+e.name.bcs.length)}}}}async waitForTransaction({signal:e,timeout:t=60*1e3,...r}){const s=e?AbortSignal.any([AbortSignal.timeout(t),e]):AbortSignal.timeout(t),i=new Promise((a,u)=>{s.addEventListener("abort",()=>u(s.reason))});for(i.catch(()=>{});;){s.throwIfAborted();try{return await this.getTransaction({...r,signal:s})}catch{await Promise.race([new Promise(a=>setTimeout(a,2e3)),i])}}}}function sn(n){const e=Object.entries(n).map(([t,r])=>l({[t]:r}));return S(_(e),vn(t=>({...t,$kind:Object.keys(t)[0]})))}const On=S(f(),vn(n=>A(n)),xt(ns)),ve=On,tn=f(),pe=S(_([f(),S(E(),T())]),xt(n=>{try{return BigInt(n),BigInt(n)>=0&&BigInt(n)<=18446744073709551615n}catch{return!1}},"Invalid u64")),Pt=l({objectId:On,version:pe,digest:f()}),L=S(_([l({GasCoin:p(!0)}),l({Input:S(E(),T()),type:C(p("pure"))}),l({Input:S(E(),T()),type:C(p("object"))}),l({Result:S(E(),T())}),l({NestedResult:os([S(E(),T()),S(E(),T())])})]),vn(n=>({...n,$kind:Object.keys(n)[0]}))),Tg=l({budget:v(pe),price:v(pe),owner:v(On),payment:v(g(Pt))}),hi=_([p("address"),p("bool"),p("u8"),p("u16"),p("u32"),p("u64"),p("u128"),p("u256"),l({vector:Ct(()=>hi)}),l({datatype:l({package:f(),module:f(),type:f(),typeParameters:g(Ct(()=>hi))})}),l({typeParameter:S(E(),T())})]),Mg=l({ref:v(_([p("&"),p("&mut")])),body:hi}),jg=l({package:ve,module:f(),function:f(),typeArguments:g(f()),arguments:g(L),_argumentTypes:C(v(g(Mg)))}),Cg=l({name:f(),inputs:At(f(),_([L,g(L)])),data:At(f(),je())}),Ag=sn({MoveCall:jg,TransferObjects:l({objects:g(L),address:L}),SplitCoins:l({coin:L,amounts:g(L)}),MergeCoins:l({destination:L,sources:g(L)}),Publish:l({modules:g(tn),dependencies:g(ve)}),MakeMoveVec:l({type:v(f()),elements:g(L)}),Upgrade:l({modules:g(tn),dependencies:g(ve),package:ve,ticket:L}),$Intent:Cg}),cu=sn({ImmOrOwnedObject:Pt,SharedObject:l({objectId:ve,initialSharedVersion:pe,mutable:bt()}),Receiving:Pt}),_g=sn({Object:cu,Pure:l({bytes:tn}),UnresolvedPure:l({value:je()}),UnresolvedObject:l({objectId:ve,version:C(v(pe)),digest:C(v(f())),initialSharedVersion:C(v(pe)),mutable:C(v(bt()))})}),Ta=sn({Object:cu,Pure:l({bytes:tn})}),uu=sn({None:p(!0),Epoch:pe}),Ar=l({version:p(2),sender:tt(On),expiration:tt(uu),gasData:Tg,inputs:g(_g),commands:g(Ag)}),pi=l({digest:f(),objectId:f(),version:_([S(E(),T()),f(),cs()])}),Pg=sn({ImmOrOwned:pi,Shared:l({objectId:ve,initialSharedVersion:pe,mutable:bt()}),Receiving:pi}),Ma=sn({Object:Pg,Pure:g(S(E(),T()))}),lu=_([l({kind:p("Input"),index:S(E(),T()),value:je(),type:C(p("object"))}),l({kind:p("Input"),index:S(E(),T()),value:je(),type:p("pure")})]),xg=_([l({Epoch:S(E(),T())}),l({None:v(p(!0))})]),ja=S(_([E(),f(),cs()]),xt(n=>{if(!["string","number","bigint"].includes(typeof n))return!1;try{return BigInt(n),!0}catch{return!1}})),Zi=_([l({bool:v(p(!0))}),l({u8:v(p(!0))}),l({u64:v(p(!0))}),l({u128:v(p(!0))}),l({address:v(p(!0))}),l({signer:v(p(!0))}),l({vector:Ct(()=>Zi)}),l({struct:Ct(()=>Ng)}),l({u16:v(p(!0))}),l({u32:v(p(!0))}),l({u256:v(p(!0))})]),Ng=l({address:f(),module:f(),name:f(),typeParams:g(Zi)}),Ug=l({budget:C(ja),price:C(ja),payment:C(g(pi)),owner:C(f())}),Rg=[lu,l({kind:p("GasCoin")}),l({kind:p("Result"),index:S(E(),T())}),l({kind:p("NestedResult"),index:S(E(),T()),resultIndex:S(E(),T())})],wt=_([...Rg]),Bg=l({kind:p("MoveCall"),target:S(f(),xt(n=>n.split("::").length===3)),typeArguments:g(f()),arguments:g(wt)}),Dg=l({kind:p("TransferObjects"),objects:g(wt),address:wt}),zg=l({kind:p("SplitCoins"),coin:wt,amounts:g(wt)}),Vg=l({kind:p("MergeCoins"),destination:wt,sources:g(wt)}),Lg=l({kind:p("MakeMoveVec"),type:_([l({Some:Zi}),l({None:v(p(!0))})]),objects:g(wt)}),Wg=l({kind:p("Publish"),modules:g(g(S(E(),T()))),dependencies:g(f())}),Fg=l({kind:p("Upgrade"),modules:g(g(S(E(),T()))),dependencies:g(f()),packageId:f(),ticket:wt}),Gg=[Bg,Dg,zg,Vg,Wg,Fg,Lg],Kg=_([...Gg]);l({version:p(1),sender:C(f()),expiration:tt(xg),gasConfig:Ug,inputs:g(lu),transactions:g(Kg)});function Ca(n){const e=n.inputs.map((t,r)=>{if(t.Object)return{kind:"Input",index:r,value:{Object:t.Object.ImmOrOwnedObject?{ImmOrOwned:t.Object.ImmOrOwnedObject}:t.Object.Receiving?{Receiving:{digest:t.Object.Receiving.digest,version:t.Object.Receiving.version,objectId:t.Object.Receiving.objectId}}:{Shared:{mutable:t.Object.SharedObject.mutable,initialSharedVersion:t.Object.SharedObject.initialSharedVersion,objectId:t.Object.SharedObject.objectId}}},type:"object"};if(t.Pure)return{kind:"Input",index:r,value:{Pure:Array.from(N(t.Pure.bytes))},type:"pure"};if(t.UnresolvedPure)return{kind:"Input",type:"pure",index:r,value:t.UnresolvedPure.value};if(t.UnresolvedObject)return{kind:"Input",type:"object",index:r,value:t.UnresolvedObject.objectId};throw new Error("Invalid input")});return{version:1,sender:n.sender??void 0,expiration:n.expiration?.$kind==="Epoch"?{Epoch:Number(n.expiration.Epoch)}:n.expiration?{None:!0}:null,gasConfig:{owner:n.gasData.owner??void 0,budget:n.gasData.budget??void 0,price:n.gasData.price??void 0,payment:n.gasData.payment??void 0},inputs:e,transactions:n.commands.map(t=>{if(t.MakeMoveVec)return{kind:"MakeMoveVec",type:t.MakeMoveVec.type===null?{None:!0}:{Some:De.parseFromStr(t.MakeMoveVec.type)},objects:t.MakeMoveVec.elements.map(r=>ot(r,e))};if(t.MergeCoins)return{kind:"MergeCoins",destination:ot(t.MergeCoins.destination,e),sources:t.MergeCoins.sources.map(r=>ot(r,e))};if(t.MoveCall)return{kind:"MoveCall",target:`${t.MoveCall.package}::${t.MoveCall.module}::${t.MoveCall.function}`,typeArguments:t.MoveCall.typeArguments,arguments:t.MoveCall.arguments.map(r=>ot(r,e))};if(t.Publish)return{kind:"Publish",modules:t.Publish.modules.map(r=>Array.from(N(r))),dependencies:t.Publish.dependencies};if(t.SplitCoins)return{kind:"SplitCoins",coin:ot(t.SplitCoins.coin,e),amounts:t.SplitCoins.amounts.map(r=>ot(r,e))};if(t.TransferObjects)return{kind:"TransferObjects",objects:t.TransferObjects.objects.map(r=>ot(r,e)),address:ot(t.TransferObjects.address,e)};if(t.Upgrade)return{kind:"Upgrade",modules:t.Upgrade.modules.map(r=>Array.from(N(r))),dependencies:t.Upgrade.dependencies,packageId:t.Upgrade.package,ticket:ot(t.Upgrade.ticket,e)};throw new Error(`Unknown transaction ${Object.keys(t)}`)})}}function ot(n,e){if(n.$kind==="GasCoin")return{kind:"GasCoin"};if(n.$kind==="Result")return{kind:"Result",index:n.Result};if(n.$kind==="NestedResult")return{kind:"NestedResult",index:n.NestedResult[0],resultIndex:n.NestedResult[1]};if(n.$kind==="Input")return e[n.Input];throw new Error(`Invalid argument ${Object.keys(n)}`)}function qg(n){return $(Ar,{version:2,sender:n.sender??null,expiration:n.expiration?"Epoch"in n.expiration?{Epoch:n.expiration.Epoch}:{None:!0}:null,gasData:{owner:n.gasConfig.owner??null,budget:n.gasConfig.budget?.toString()??null,price:n.gasConfig.price?.toString()??null,payment:n.gasConfig.payment?.map(e=>({digest:e.digest,objectId:e.objectId,version:e.version.toString()}))??null},inputs:n.inputs.map(e=>{if(e.kind==="Input"){if(yn(Ma,e.value)){const t=$(Ma,e.value);if(t.Object){if(t.Object.ImmOrOwned)return{Object:{ImmOrOwnedObject:{objectId:t.Object.ImmOrOwned.objectId,version:String(t.Object.ImmOrOwned.version),digest:t.Object.ImmOrOwned.digest}}};if(t.Object.Shared)return{Object:{SharedObject:{mutable:t.Object.Shared.mutable??null,initialSharedVersion:t.Object.Shared.initialSharedVersion,objectId:t.Object.Shared.objectId}}};if(t.Object.Receiving)return{Object:{Receiving:{digest:t.Object.Receiving.digest,version:String(t.Object.Receiving.version),objectId:t.Object.Receiving.objectId}}};throw new Error("Invalid object input")}return{Pure:{bytes:W(new Uint8Array(t.Pure))}}}return e.type==="object"?{UnresolvedObject:{objectId:e.value}}:{UnresolvedPure:{value:e.value}}}throw new Error("Invalid input")}),commands:n.transactions.map(e=>{switch(e.kind){case"MakeMoveVec":return{MakeMoveVec:{type:"Some"in e.type?De.tagToString(e.type.Some):null,elements:e.objects.map(t=>ct(t))}};case"MergeCoins":return{MergeCoins:{destination:ct(e.destination),sources:e.sources.map(t=>ct(t))}};case"MoveCall":{const[t,r,s]=e.target.split("::");return{MoveCall:{package:t,module:r,function:s,typeArguments:e.typeArguments,arguments:e.arguments.map(i=>ct(i))}}}case"Publish":return{Publish:{modules:e.modules.map(t=>W(Uint8Array.from(t))),dependencies:e.dependencies}};case"SplitCoins":return{SplitCoins:{coin:ct(e.coin),amounts:e.amounts.map(t=>ct(t))}};case"TransferObjects":return{TransferObjects:{objects:e.objects.map(t=>ct(t)),address:ct(e.address)}};case"Upgrade":return{Upgrade:{modules:e.modules.map(t=>W(Uint8Array.from(t))),dependencies:e.dependencies,package:e.packageId,ticket:ct(e.ticket)}}}throw new Error(`Unknown transaction ${Object.keys(e)}`)})})}function ct(n){switch(n.kind){case"GasCoin":return{GasCoin:!0};case"Result":return{Result:n.index};case"NestedResult":return{NestedResult:[n.index,n.resultIndex]};case"Input":return{Input:n.index}}}function Jg(n,e){const t=Array.from(`${n}::`).map(s=>s.charCodeAt(0)),r=new Uint8Array(t.length+e.length);return r.set(t),r.set(e,t.length),Fe(r,{dkLen:32})}function Aa(n){return A(n).replace("0x","")}class ye{constructor(e){this.version=2,this.sender=e?.sender??null,this.expiration=e?.expiration??null,this.inputs=e?.inputs??[],this.commands=e?.commands??[],this.gasData=e?.gasData??{budget:null,price:null,owner:null,payment:null}}static fromKindBytes(e){const r=M.TransactionKind.parse(e).ProgrammableTransaction;if(!r)throw new Error("Unable to deserialize from bytes.");return ye.restore({version:2,sender:null,expiration:null,gasData:{budget:null,owner:null,payment:null,price:null},inputs:r.inputs,commands:r.commands})}static fromBytes(e){const r=M.TransactionData.parse(e)?.V1,s=r.kind.ProgrammableTransaction;if(!r||!s)throw new Error("Unable to deserialize from bytes.");return ye.restore({version:2,sender:r.sender,expiration:r.expiration,gasData:r.gasData,inputs:s.inputs,commands:s.commands})}static restore(e){return e.version===2?new ye($(Ar,e)):new ye($(Ar,qg(e)))}static getDigestFromBytes(e){const t=Jg("TransactionData",e);return hs(t)}get gasConfig(){return this.gasData}set gasConfig(e){this.gasData=e}build({maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}={}){const s=this.inputs,i=this.commands,a={ProgrammableTransaction:{inputs:s,commands:i}};if(r)return M.TransactionKind.serialize(a,{maxSize:e}).toBytes();const u=t?.expiration??this.expiration,d=t?.sender??this.sender,b={...this.gasData,...t?.gasConfig,...t?.gasData};if(!d)throw new Error("Missing transaction sender");if(!b.budget)throw new Error("Missing gas budget");if(!b.payment)throw new Error("Missing gas payment");if(!b.price)throw new Error("Missing gas price");const h={sender:Aa(d),expiration:u||{None:!0},gasData:{payment:b.payment,owner:Aa(this.gasData.owner??d),price:BigInt(b.price),budget:BigInt(b.budget)},kind:{ProgrammableTransaction:{inputs:s,commands:i}}};return M.TransactionData.serialize({V1:h},{maxSize:e}).toBytes()}addInput(e,t){const r=this.inputs.length;return this.inputs.push(t),{Input:r,type:e,$kind:"Input"}}getInputUses(e,t){this.mapArguments((r,s)=>(r.$kind==="Input"&&r.Input===e&&t(r,s),r))}mapCommandArguments(e,t){const r=this.commands[e];switch(r.$kind){case"MoveCall":r.MoveCall.arguments=r.MoveCall.arguments.map(i=>t(i,r,e));break;case"TransferObjects":r.TransferObjects.objects=r.TransferObjects.objects.map(i=>t(i,r,e)),r.TransferObjects.address=t(r.TransferObjects.address,r,e);break;case"SplitCoins":r.SplitCoins.coin=t(r.SplitCoins.coin,r,e),r.SplitCoins.amounts=r.SplitCoins.amounts.map(i=>t(i,r,e));break;case"MergeCoins":r.MergeCoins.destination=t(r.MergeCoins.destination,r,e),r.MergeCoins.sources=r.MergeCoins.sources.map(i=>t(i,r,e));break;case"MakeMoveVec":r.MakeMoveVec.elements=r.MakeMoveVec.elements.map(i=>t(i,r,e));break;case"Upgrade":r.Upgrade.ticket=t(r.Upgrade.ticket,r,e);break;case"$Intent":const s=r.$Intent.inputs;r.$Intent.inputs={};for(const[i,a]of Object.entries(s))r.$Intent.inputs[i]=Array.isArray(a)?a.map(u=>t(u,r,e)):t(a,r,e);break;case"Publish":break;default:throw new Error(`Unexpected transaction kind: ${r.$kind}`)}}mapArguments(e){for(const t of this.commands.keys())this.mapCommandArguments(t,e)}replaceCommand(e,t,r=e){if(!Array.isArray(t)){this.commands[e]=t;return}const s=t.length-1;this.commands.splice(e,1,...t),s!==0&&this.mapArguments((i,a,u)=>{if(u<e+t.length)return i;switch(i.$kind){case"Result":i.Result===e&&(i.Result=r),i.Result>e&&(i.Result+=s);break;case"NestedResult":i.NestedResult[0]===e&&(i.NestedResult[0]=r),i.NestedResult[0]>e&&(i.NestedResult[0]+=s);break}return i})}getDigest(){const e=this.build({onlyTransactionKind:!1});return ye.getDigestFromBytes(e)}snapshot(){return $(Ar,this)}shallowClone(){return new ye({version:this.version,sender:this.sender,expiration:this.expiration,gasData:{...this.gasData},inputs:[...this.inputs],commands:[...this.commands]})}applyResolvedData(e){this.sender||(this.sender=e.sender??null),this.expiration||(this.expiration=e.expiration??null),this.gasData.budget||(this.gasData.budget=e.gasData.budget),this.gasData.owner||(this.gasData.owner=e.gasData.owner??null),this.gasData.payment||(this.gasData.payment=e.gasData.payment),this.gasData.price||(this.gasData.price=e.gasData.price);for(let t=0;t<this.inputs.length;t++){const r=this.inputs[t],s=e.inputs[t];switch(r.$kind){case"UnresolvedPure":if(s.$kind!=="Pure")throw new Error(`Expected input at index ${t} to resolve to a Pure argument, but got ${JSON.stringify(s)}`);this.inputs[t]=s;break;case"UnresolvedObject":if(s.$kind!=="Object")throw new Error(`Expected input at index ${t} to resolve to an Object argument, but got ${JSON.stringify(s)}`);if(s.Object.$kind==="ImmOrOwnedObject"||s.Object.$kind==="Receiving"){const i=r.UnresolvedObject,a=s.Object.ImmOrOwnedObject??s.Object.Receiving;if(A(i.objectId)!==A(a.objectId)||i.version!=null&&i.version!==a.version||i.digest!=null&&i.digest!==a.digest||i.mutable!=null||i.initialSharedVersion!=null)throw new Error(`Input at index ${t} did not match unresolved object. ${JSON.stringify(i)} is not compatible with ${JSON.stringify(a)}`)}else if(s.Object.$kind==="SharedObject"){const i=r.UnresolvedObject,a=s.Object.SharedObject;if(A(i.objectId)!==A(a.objectId)||i.initialSharedVersion!=null&&i.initialSharedVersion!==a.initialSharedVersion||i.mutable!=null&&i.mutable!==a.mutable||i.version!=null||i.digest!=null)throw new Error(`Input at index ${t} did not match unresolved object. ${JSON.stringify(i)} is not compatible with ${JSON.stringify(a)}`)}else throw new Error(`Input at index ${t} resolved to an unexpected Object kind: ${JSON.stringify(s.Object)}`);this.inputs[t]=s;break}}}}function Zg(n){return{...ye.fromBytes(n).snapshot(),bcs:n}}function Hg(n){const e=M.TransactionEffects.parse(n);switch(e.$kind){case"V1":return Qg({effects:e.V1});case"V2":return Yg({bytes:n,effects:e.V2});default:throw new Error(`Unknown transaction effects version: ${e.$kind}`)}}function Qg(n){throw new Error("V1 effects are not supported yet")}function Yg({bytes:n,effects:e}){const t=e.changedObjects.map(([r,s])=>({id:r,inputState:s.inputState.$kind==="Exist"?"Exists":"DoesNotExist",inputVersion:s.inputState.Exist?.[0][0]??null,inputDigest:s.inputState.Exist?.[0][1]??null,inputOwner:s.inputState.Exist?.[1]??null,outputState:s.outputState.$kind==="NotExist"?"DoesNotExist":s.outputState.$kind,outputVersion:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[0]:s.outputState.ObjectWrite?e.lamportVersion:null,outputDigest:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[1]:s.outputState.ObjectWrite?.[0]??null,outputOwner:s.outputState.ObjectWrite?s.outputState.ObjectWrite[1]:null,idOperation:s.idOperation.$kind}));return{bcs:n,digest:e.transactionDigest,version:2,status:e.status.$kind==="Success"?{success:!0,error:null}:{success:!1,error:e.status.Failed.error.$kind},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:e.gasObjectIndex===null?null:t[e.gasObjectIndex]??null,eventsDigest:e.eventsDigest,dependencies:e.dependencies,lamportVersion:e.lamportVersion,changedObjects:t,unchangedConsensusObjects:e.unchangedSharedObjects.map(([r,s])=>({kind:s.$kind==="MutateDeleted"?"MutateConsensusStreamEnded":s.$kind==="ReadDeleted"?"ReadConsensusStreamEnded":s.$kind,objectId:r,version:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[0]:s[s.$kind],digest:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[1]:null})),auxiliaryDataDigest:e.auxDataDigest}}var gi=(n=>(n.PersonalMessage="PERSONAL_MESSAGE",n.TransactionData="TRANSACTION_DATA",n))(gi||{});class X extends String{constructor(e,t){super(e),this.value=e,this.__meta__=t}toString(){return this.value}}new X(`
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}
    `,{fragmentName:"OBJECT_OWNER_FIELDS"});new X(`
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`,{fragmentName:"OBJECT_FIELDS"});new X(`
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`,{fragmentName:"MOVE_OBJECT_FIELDS"});new X(`
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}
    `,{fragmentName:"TRANSACTION_FIELDS"});const Xg=new X(`
    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $owner) {
    balances(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinType {
          repr
        }
        coinObjectCount
        totalBalance
      }
    }
  }
}
    `),ef=new X(`
    query getBalance($owner: SuiAddress!, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    balance(type: $type) {
      coinType {
        repr
      }
      coinObjectCount
      totalBalance
    }
  }
}
    `),tf=new X(`
    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String = "0x2::sui::SUI") {
  address(address: $owner) {
    address
    coins(first: $first, after: $cursor, type: $type) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        coinBalance
        owner {
          ...OBJECT_OWNER_FIELDS
        }
        contents {
          bcs
          type {
            repr
          }
        }
        address
        version
        digest
        previousTransactionBlock {
          digest
        }
      }
    }
  }
}
    fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`),nf=new X(`
    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {
  owner(address: $parentId) {
    dynamicFields(first: $first, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        name {
          bcs
          type {
            repr
          }
        }
        value {
          __typename
          ... on MoveValue {
            type {
              repr
            }
          }
          ... on MoveObject {
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
  }
}
    `),rf=new X(`
    query getMoveFunction($package: SuiAddress!, $module: String!, $function: String!) {
  package(address: $package) {
    module(name: $module) {
      function(name: $function) {
        name
        visibility
        isEntry
        typeParameters {
          constraints
        }
        parameters {
          signature
        }
        return {
          signature
        }
      }
    }
  }
}
    `),sf=new X(`
    query getReferenceGasPrice {
  epoch {
    referenceGasPrice
  }
}
    `),af=new X(`
    query resolveNameServiceNames($address: SuiAddress!, $limit: Int, $cursor: String) {
  address(address: $address) {
    suinsRegistrations(first: $limit, after: $cursor) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        domain
      }
    }
  }
}
    `),of=new X(`
    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {
  address(address: $owner) {
    objects(first: $limit, after: $cursor, filter: $filter) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        ...MOVE_OBJECT_FIELDS
      }
    }
  }
}
    fragment MOVE_OBJECT_FIELDS on MoveObject {
  address
  digest
  version
  contents {
    bcs
    type {
      repr
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`),cf=new X(`
    query multiGetObjects($objectIds: [SuiAddress!]!, $limit: Int, $cursor: String) {
  objects(first: $limit, after: $cursor, filter: {objectIds: $objectIds}) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ...OBJECT_FIELDS
    }
  }
}
    fragment OBJECT_FIELDS on Object {
  address
  digest
  version
  asMoveObject {
    contents {
      bcs
      type {
        repr
      }
    }
  }
  owner {
    ...OBJECT_OWNER_FIELDS
  }
  previousTransactionBlock {
    digest
  }
}
fragment OBJECT_OWNER_FIELDS on ObjectOwner {
  __typename
  ... on AddressOwner {
    owner {
      asObject {
        address
      }
      asAddress {
        address
      }
    }
  }
  ... on Parent {
    parent {
      address
    }
  }
  ... on Shared {
    initialSharedVersion
  }
  ... on ConsensusAddressOwner {
    startVersion
    owner {
      address
    }
  }
}`),uf=new X(`
    query dryRunTransactionBlock($txBytes: String!) {
  dryRunTransactionBlock(txBytes: $txBytes) {
    error
    transaction {
      ...TRANSACTION_FIELDS
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`),lf=new X(`
    mutation executeTransactionBlock($txBytes: String!, $signatures: [String!]!) {
  executeTransactionBlock(txBytes: $txBytes, signatures: $signatures) {
    errors
    effects {
      transactionBlock {
        ...TRANSACTION_FIELDS
      }
    }
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`),df=new X(`
    query getTransactionBlock($digest: String!) {
  transactionBlock(digest: $digest) {
    ...TRANSACTION_FIELDS
  }
}
    fragment TRANSACTION_FIELDS on TransactionBlock {
  digest
  bcs
  signatures
  effects {
    bcs
    epoch {
      epochId
    }
    unchangedConsensusObjects {
      nodes {
        __typename
        ... on ConsensusObjectRead {
          object {
            asMoveObject {
              address
              contents {
                type {
                  repr
                }
              }
            }
          }
        }
      }
    }
    objectChanges {
      nodes {
        address
        inputState {
          version
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
        outputState {
          asMoveObject {
            address
            contents {
              type {
                repr
              }
            }
          }
        }
      }
    }
    balanceChanges(first: 50) {
      pageInfo {
        hasNextPage
      }
      nodes {
        owner {
          address
        }
        coinType {
          repr
        }
        amount
      }
    }
  }
}`),hf=new X(`
    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {
  verifyZkloginSignature(
    bytes: $bytes
    signature: $signature
    intentScope: $intentScope
    author: $author
  ) {
    success
    errors
  }
}
    `);class pf extends Error{}class Mt extends pf{constructor(e,t){super(t),this.code=e}static fromResponse(e,t){switch(e.code){case"notExists":return new Mt(e.code,`Object ${e.object_id} does not exist`);case"dynamicFieldNotFound":return new Mt(e.code,`Dynamic field not found for object ${e.parent_object_id}`);case"deleted":return new Mt(e.code,`Object ${e.object_id} has been deleted`);case"displayError":return new Mt(e.code,`Display error: ${e.error}`);case"unknown":default:return new Mt(e.code,`Unknown error while loading object${t?` ${t}`:""}`)}}}var du=n=>{throw TypeError(n)},Hi=(n,e,t)=>e.has(n)||du("Cannot "+t),gf=(n,e,t)=>(Hi(n,e,"read from private field"),t?t.call(n):e.get(n)),_a=(n,e,t)=>e.has(n)?du("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),ff=(n,e,t,r)=>(Hi(n,e,"write to private field"),e.set(n,t),t),fe=(n,e,t)=>(Hi(n,e,"access private method"),t),ss,ce,le;class mf extends Eg{constructor({graphqlClient:e,mvr:t}){super({network:e.network,base:e,mvr:t}),_a(this,ce),_a(this,ss),ff(this,ss,e)}async getObjects(e){const t=[];let r=!0,s=null;for(;r;){const i=await fe(this,ce,le).call(this,{query:cf,variables:{objectIds:e.objectIds,cursor:s}},a=>a.objects);t.push(...i.nodes),r=i.pageInfo.hasNextPage,s=i.pageInfo.endCursor??null}return{objects:e.objectIds.map(i=>A(i)).map(i=>t.find(a=>a.address===i)??new Mt("notFound",`Object ${i} not found`)).map(i=>i instanceof Mt?i:{id:i.address,version:i.version.toString(),digest:i.digest,owner:As(i.owner),type:i.asMoveObject?.contents?.type?.repr,content:Promise.resolve(i.asMoveObject?.contents?.bcs?N(i.asMoveObject.contents.bcs):new Uint8Array),previousTransaction:i.previousTransactionBlock?.digest??null})}}async getOwnedObjects(e){const t=await fe(this,ce,le).call(this,{query:of,variables:{owner:e.address,limit:e.limit,cursor:e.cursor,filter:e.type?{type:(await this.mvr.resolveType({type:e.type})).type}:void 0}},r=>r.address?.objects);return{objects:t.nodes.map(r=>({id:r.address,version:r.version.toString(),digest:r.digest,owner:As(r.owner),type:r.contents?.type?.repr,content:Promise.resolve(r.contents?.bcs?N(r.contents.bcs):new Uint8Array),previousTransaction:r.previousTransactionBlock?.digest??null})),hasNextPage:t.pageInfo.hasNextPage,cursor:t.pageInfo.endCursor??null}}async getCoins(e){const t=await fe(this,ce,le).call(this,{query:tf,variables:{owner:e.address,cursor:e.cursor,first:e.limit,type:(await this.mvr.resolveType({type:e.coinType})).type}},r=>r.address?.coins);return{cursor:t.pageInfo.endCursor??null,hasNextPage:t.pageInfo.hasNextPage,objects:t.nodes.map(r=>({id:r.address,version:r.version.toString(),digest:r.digest,owner:As(r.owner),type:r.contents?.type?.repr,balance:r.coinBalance,content:Promise.resolve(r.contents?.bcs?N(r.contents.bcs):new Uint8Array),previousTransaction:r.previousTransactionBlock?.digest??null}))}}async getBalance(e){const t=await fe(this,ce,le).call(this,{query:ef,variables:{owner:e.address,type:(await this.mvr.resolveType({type:e.coinType})).type}},r=>r.address?.balance);return{balance:{coinType:t.coinType.repr,balance:t.totalBalance}}}async getAllBalances(e){const t=await fe(this,ce,le).call(this,{query:Xg,variables:{owner:e.address}},r=>r.address?.balances);return{cursor:t.pageInfo.endCursor??null,hasNextPage:t.pageInfo.hasNextPage,balances:t.nodes.map(r=>({coinType:r.coinType.repr,balance:r.totalBalance}))}}async getTransaction(e){const t=await fe(this,ce,le).call(this,{query:df,variables:{digest:e.digest}},r=>r.transactionBlock);return{transaction:_s(t)}}async executeTransaction(e){const t=await fe(this,ce,le).call(this,{query:lf,variables:{txBytes:W(e.transaction),signatures:e.signatures}},r=>r.executeTransactionBlock);if(t.errors)throw t.errors.length===1?new Error(t.errors[0]):new AggregateError(t.errors.map(r=>new Error(r)));return{transaction:_s(t.effects.transactionBlock)}}async dryRunTransaction(e){const t=await fe(this,ce,le).call(this,{query:uf,variables:{txBytes:W(e.transaction)}},r=>r.dryRunTransactionBlock);if(t.error)throw new Error(t.error);return{transaction:_s(t.transaction)}}async getReferenceGasPrice(){return{referenceGasPrice:await fe(this,ce,le).call(this,{query:sf},t=>t.epoch?.referenceGasPrice)}}async getDynamicFields(e){const t=await fe(this,ce,le).call(this,{query:nf,variables:{parentId:e.parentId}},r=>r.owner?.dynamicFields);return{dynamicFields:t.nodes.map(r=>{const s=r.value?.__typename==="MoveObject"?r.value.contents?.type?.repr:r.value?.type.repr;return{id:ru(e.parentId,r.name?.type.repr,N(r.name?.bcs)),type:nr(r.value?.__typename==="MoveObject"?`0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${r.name?.type.repr}>,0x2::object::ID>`:`0x2::dynamic_field::Field<${r.name?.type.repr},${s}>`),name:{type:r.name?.type.repr,bcs:N(r.name?.bcs)},valueType:s}}),cursor:t.pageInfo.endCursor??null,hasNextPage:t.pageInfo.hasNextPage}}async verifyZkLoginSignature(e){const t=e.intentScope==="TransactionData"?gi.TransactionData:gi.PersonalMessage,r=await fe(this,ce,le).call(this,{query:hf,variables:{bytes:e.bytes,signature:e.signature,intentScope:t,author:e.author}},s=>s.verifyZkloginSignature);return{success:r.success,errors:r.errors}}async resolveNameServiceNames(e){const t=await fe(this,ce,le).call(this,{query:af,signal:e.signal,variables:{address:e.address,cursor:e.cursor,limit:e.limit}},r=>r.address?.suinsRegistrations);return{hasNextPage:t.pageInfo.hasNextPage,nextCursor:t.pageInfo.endCursor??null,data:t.nodes.map(r=>r.domain)??[]}}async getMoveFunction(e){const t=await fe(this,ce,le).call(this,{query:rf,variables:{package:(await this.mvr.resolvePackage({package:e.packageId})).package,module:e.moduleName,function:e.name}},s=>s.package?.module?.function);let r="unknown";switch(t.visibility){case"PUBLIC":r="public";break;case"PRIVATE":r="private";break;case"FRIEND":r="friend";break}return{function:{packageId:A(e.packageId),moduleName:e.moduleName,name:t.name,visibility:r,isEntry:t.isEntry??!1,typeParameters:t.typeParameters?.map(({constraints:s})=>({isPhantom:!1,constraints:s.map(i=>{switch(i){case"COPY":return"copy";case"DROP":return"drop";case"STORE":return"store";case"KEY":return"key";default:return"unknown"}})??[]}))??[],parameters:t.parameters?.map(s=>Pa(s.signature))??[],returns:t.return?.map(({signature:s})=>Pa(s))??[]}}}resolveTransactionPlugin(){throw new Error("GraphQL client does not support transaction resolution yet")}}ss=new WeakMap;ce=new WeakSet;le=async function(n,e){const{data:t,errors:r}=await gf(this,ss).query(n);yf(r);const s=t&&(e?e(t):t);if(s==null)throw new Error("Missing response data");return s};function yf(n){if(!n||n.length===0)return;const e=n.map(t=>new wf(t));throw e.length===1?e[0]:new AggregateError(e)}class wf extends Error{constructor(e){super(e.message),this.locations=e.locations}}function As(n){switch(n.__typename){case"AddressOwner":return{$kind:"AddressOwner",AddressOwner:n.owner?.asAddress?.address};case"ConsensusAddressOwner":return{$kind:"ConsensusAddressOwner",ConsensusAddressOwner:{owner:n.owner?.address,startVersion:String(n.startVersion)}};case"Immutable":return{$kind:"Immutable",Immutable:!0};case"Parent":return{$kind:"ObjectOwner",ObjectOwner:n.parent?.address};case"Shared":return{$kind:"Shared",Shared:{initialSharedVersion:String(n.initialSharedVersion)}}}}function _s(n){const e={};if(n.effects?.unchangedConsensusObjects.nodes.forEach(t=>{if(t.__typename==="ConsensusObjectRead"){const r=t.object?.asMoveObject?.contents?.type.repr,s=t.object?.asMoveObject?.address;r&&s&&(e[s]=r)}}),n.effects?.objectChanges.nodes.forEach(t=>{const r=t.address,s=t.inputState?.asMoveObject?.contents?.type.repr??t.outputState?.asMoveObject?.contents?.type.repr;r&&s&&(e[r]=s)}),n.effects?.balanceChanges.pageInfo.hasNextPage)throw new Error("Pagination for balance changes is not supported");return{digest:n.digest,effects:Hg(N(n.effects?.bcs)),epoch:n.effects?.epoch?.epochId?.toString()??null,objectTypes:Promise.resolve(e),transaction:Zg(N(n.bcs)),signatures:n.signatures,balanceChanges:n.effects?.balanceChanges.nodes.map(t=>({coinType:t?.coinType?.repr,address:t.owner?.address,amount:t.amount}))??[]}}function Pa(n){let e=null;return n.ref==="&"?e="immutable":n.ref==="&mut"&&(e="mutable"),{reference:e,body:fi(n.body)}}function fi(n){switch(n){case"address":return{$kind:"address"};case"bool":return{$kind:"bool"};case"u8":return{$kind:"u8"};case"u16":return{$kind:"u16"};case"u32":return{$kind:"u32"};case"u64":return{$kind:"u64"};case"u128":return{$kind:"u128"};case"u256":return{$kind:"u256"}}if(typeof n=="string")throw new Error(`Unknown type: ${n}`);if("vector"in n)return{$kind:"vector",vector:fi(n.vector)};if("datatype"in n)return{$kind:"datatype",datatype:{typeName:`${A(n.datatype.package)}::${n.datatype.module}::${n.datatype.type}`,typeParameters:n.datatype.typeParameters.map(e=>fi(e))}};if("typeParameter"in n)return{$kind:"typeParameter",index:n.typeParameter};throw new Error(`Unknown type: ${JSON.stringify(n)}`)}var hu=n=>{throw TypeError(n)},pu=(n,e,t)=>e.has(n)||hu("Cannot "+t),hr=(n,e,t)=>(pu(n,e,"read from private field"),t?t.call(n):e.get(n)),pr=(n,e,t)=>e.has(n)?hu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),gr=(n,e,t,r)=>(pu(n,e,"write to private field"),e.set(n,t),t),_r,Pr,xr,Nr;class bf extends Error{}class vf extends nu{constructor({url:e,fetch:t=fetch,headers:r={},queries:s={},network:i="unknown",mvr:a}){super({network:i}),pr(this,_r),pr(this,Pr),pr(this,xr),pr(this,Nr),gr(this,_r,e),gr(this,Pr,s),gr(this,xr,r),gr(this,Nr,(...u)=>t(...u)),this.core=new mf({graphqlClient:this,mvr:a})}async query(e){const t=await hr(this,Nr).call(this,hr(this,_r),{method:"POST",headers:{"Content-Type":"application/json",...hr(this,xr)},body:JSON.stringify({query:typeof e.query=="string"||e.query instanceof String?String(e.query):Bu(e.query),variables:e.variables,extensions:e.extensions,operationName:e.operationName}),signal:e.signal});if(!t.ok)throw new bf(`GraphQL request failed: ${t.statusText} (${t.status})`);return await t.json()}async execute(e,t){return this.query({...t,query:hr(this,Pr)[e]})}}_r=new WeakMap;Pr=new WeakMap;xr=new WeakMap;Nr=new WeakMap;class zn extends Error{}zn.prototype.name="InvalidTokenError";function Sf(n){return decodeURIComponent(atob(n).replace(/(.)/g,(e,t)=>{let r=t.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r}))}function kf(n){let e=n.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return Sf(e)}catch{return atob(e)}}function Of(n,e){if(typeof n!="string")throw new zn("Invalid token specified: must be a string");e||(e={});const t=e.header===!0?0:1,r=n.split(".")[t];if(typeof r!="string")throw new zn(`Invalid token specified: missing part #${t+1}`);let s;try{s=kf(r)}catch(i){throw new zn(`Invalid token specified: invalid base64 for part #${t+1} (${i.message})`)}try{return JSON.parse(s)}catch(i){throw new zn(`Invalid token specified: invalid json for part #${t+1} (${i.message})`)}}function If(n){for(let e=0;e<n.length;e++)if(n[e]!==0)return e;return-1}function Qi(n,e){const t=n.toString(16);return Du(t.padStart(e*2,"0").slice(-e*2))}function gu(n,e){const t=Qi(n,e),r=If(t);return r===-1?new Uint8Array([0]):t.slice(r)}function fu(n){return n==="accounts.google.com"?"https://accounts.google.com":n}function $f(n){if(n.length!==1)throw new Error("Invalid base64Url character: "+n);const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".indexOf(n);if(t===-1)throw new Error("Invalid base64Url character: "+n);const r=t.toString(2).padStart(6,"0");return Array.from(r).map(Number)}function Ef(n){let e=[];for(let t=0;t<n.length;t++){const r=n.charAt(t),s=$f(r);e=e.concat(s)}return e}function Tf(n,e){if(n.length<2)throw new Error(`Input (s = ${n}) is not tightly packed because s.length < 2`);let t=Ef(n);const r=e%4;if(r!==0)if(r===1)t=t.slice(2);else if(r===2)t=t.slice(4);else throw new Error(`Input (s = ${n}) is not tightly packed because i%4 = 3 (i = ${e}))`);const s=(e+n.length-1)%4;if(s!==3)if(s===2)t=t.slice(0,t.length-2);else if(s===1)t=t.slice(0,t.length-4);else throw new Error(`Input (s = ${n}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${e}))`);if(t.length%8!==0)throw new Error("We should never reach here...");const i=new Uint8Array(Math.floor(t.length/8));let a=0;for(let u=0;u<t.length;u+=8){const d=t.slice(u,u+8),b=parseInt(d.join(""),2);i[a++]=b}return new TextDecoder().decode(i)}function Mf(n){if(!(n.slice(-1)==="}"||n.slice(-1)===","))throw new Error("Invalid claim");const e=JSON.parse("{"+n.slice(0,-1)+"}");if(Object.keys(e).length!==1)throw new Error("Invalid claim");const t=Object.keys(e)[0];return[t,e[t]]}function mu(n,e){const t=Tf(n.value,n.indexMod4),[r,s]=Mf(t);if(r!==e)throw new Error(`Invalid field name: found ${r} expected ${e}`);return s}function Zm(n){const{iss:e,aud:t,sub:r,...s}=Of(n);if(!r||!e||!t)throw new Error("Missing jwt data");if(Array.isArray(t))throw new Error("Not supported aud. Aud is an array, string was expected.");return{...s,iss:fu(e),rawIss:e,aud:t,sub:r}}const yu=c.struct("ZkLoginSignature",{inputs:c.struct("ZkLoginSignatureInputs",{proofPoints:c.struct("ZkLoginSignatureInputsProofPoints",{a:c.vector(c.string()),b:c.vector(c.vector(c.string())),c:c.vector(c.string())}),issBase64Details:c.struct("ZkLoginSignatureInputsClaim",{value:c.string(),indexMod4:c.u8()}),headerBase64:c.string(),addressSeed:c.string()}),maxEpoch:c.u64(),userSignature:c.byteVector()});function jf({inputs:n,maxEpoch:e,userSignature:t}){return yu.serialize({inputs:n,maxEpoch:e,userSignature:typeof t=="string"?N(t):t},{maxSize:2048}).toBytes()}function Hm({inputs:n,maxEpoch:e,userSignature:t}){const r=jf({inputs:n,maxEpoch:e,userSignature:t}),s=new Uint8Array(r.length+1);return s.set([rn.ZkLogin]),s.set(r,1),W(s)}function Cf(n){return yu.parse(typeof n=="string"?N(n):n)}var wu=n=>{throw TypeError(n)},Yi=(n,e,t)=>e.has(n)||wu("Cannot "+t),lt=(n,e,t)=>(Yi(n,e,"read from private field"),t?t.call(n):e.get(n)),fr=(n,e,t)=>e.has(n)?wu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),an=(n,e,t,r)=>(Yi(n,e,"write to private field"),e.set(n,t),t),xa=(n,e,t)=>(Yi(n,e,"access private method"),t),Ae,Vn,Ln,Ur,mi;const Af=class It extends Ki{constructor(e,{client:t}={}){super(),fr(this,Ur),fr(this,Ae),fr(this,Vn),fr(this,Ln),an(this,Vn,t),typeof e=="string"?an(this,Ae,N(e)):e instanceof Uint8Array?an(this,Ae,e):an(this,Ae,Uint8Array.from(e)),an(this,Ln,lt(this,Ae).length!==lt(this,Ae)[0]+1+32),lt(this,Ln)&&an(this,Ae,pn(lt(this,Ae)))}static fromBytes(e,{client:t,address:r,legacyAddress:s}={}){let i;if(s===!0?i=new It(pn(e,!0),{client:t}):s===!1?i=new It(pn(e,!1),{client:t}):r?(i=new It(pn(e,!1),{client:t}),i.toSuiAddress()!==r&&(i=new It(pn(e,!0),{client:t}))):i=new It(e,{client:t}),r&&i.toSuiAddress()!==r)throw new Error("Public key bytes do not match the provided address");return i}static fromProof(e,t){const{issBase64Details:r,addressSeed:s}=t,i=mu(r,"iss"),a=yi(BigInt(s),i,{legacyAddress:!0});if(a.toSuiAddress()===e)return a;const u=yi(BigInt(s),i,{legacyAddress:!1});if(u.toSuiAddress()!==e)throw new Error("Proof does not match address");return u}equals(e){return super.equals(e)}toSuiAddress(){return lt(this,Ln)?xa(this,Ur,mi).call(this):super.toSuiAddress()}toRawBytes(){return lt(this,Ae)}flag(){return rn.ZkLogin}async verify(e,t){throw Error("does not support")}verifyPersonalMessage(e,t){const r=wi(t),s=new It(r.publicKey).toSuiAddress();return Na({address:s,bytes:W(e),signature:r.serializedSignature,intentScope:"PersonalMessage",client:lt(this,Vn)})}verifyTransaction(e,t){const r=wi(t),s=new It(r.publicKey).toSuiAddress();return Na({address:s,bytes:W(e),signature:r.serializedSignature,intentScope:"TransactionData",client:lt(this,Vn)})}verifyAddress(e){return e===super.toSuiAddress()||e===xa(this,Ur,mi).call(this)}};Ae=new WeakMap;Vn=new WeakMap;Ln=new WeakMap;Ur=new WeakSet;mi=function(){const n=pn(lt(this,Ae),!0),e=new Uint8Array(n.length+1);return e[0]=this.flag(),e.set(n,1),A(Ii(Fe(e,{dkLen:32})).slice(0,kn*2))};let _f=Af;function yi(n,e,t){const r=t?.legacyAddress?gu(n,32):Qi(n,32),s=new TextEncoder().encode(fu(e)),i=new Uint8Array(1+s.length+r.length);return i.set([s.length],0),i.set(s,1),i.set(r,1+s.length),new _f(i,t)}function pn(n,e=!1){const t=n[0]+1,r=BigInt(`0x${wn(n.slice(t))}`),s=e?gu(r,32):Qi(r,32),i=new Uint8Array(t+s.length);return i.set(n.slice(0,t),0),i.set(s,t),i}async function Na({address:n,bytes:e,signature:t,intentScope:r,client:s=new vf({url:"https://sui-mainnet.mystenlabs.com/graphql"})}){const i=await s.core.verifyZkLoginSignature({bytes:e,signature:t,intentScope:r,author:n});return i.success===!0&&i.errors.length===0}function wi(n){const e=typeof n=="string"?N(n):n;if(e[0]!==rn.ZkLogin)throw new Error("Invalid signature scheme");const t=e.slice(1),{inputs:r,maxEpoch:s,userSignature:i}=Cf(t),{issBase64Details:a,addressSeed:u}=r,d=mu(a,"iss"),b=yi(BigInt(u),d);return{serializedSignature:W(e),signatureScheme:"ZkLogin",zkLogin:{inputs:r,maxEpoch:s,userSignature:i,iss:d,addressSeed:BigInt(u)},signature:e,publicKey:b.toRawBytes()}}function Pf({signature:n,signatureScheme:e,publicKey:t}){if(!t)throw new Error("`publicKey` is required");const r=t.toRawBytes(),s=new Uint8Array(1+n.length+r.length);return s.set([rn[e]]),s.set(n,1),s.set(r,1+n.length),W(s)}function xf(n){const e=N(n),t=Qc[e[0]];switch(t){case"Passkey":return Yc(n);case"MultiSig":const r=M.MultiSig.parse(e.slice(1));return{serializedSignature:n,signatureScheme:t,multisig:r,bytes:e,signature:void 0};case"ZkLogin":return wi(n);case"ED25519":case"Secp256k1":case"Secp256r1":return gg(n);default:throw new Error("Unsupported signature scheme")}}class Nf{async signWithIntent(e,t){const r=Hc(t,e),s=Fe(r,{dkLen:32});return{signature:Pf({signature:await this.sign(s),signatureScheme:this.getKeyScheme(),publicKey:this.getPublicKey()}),bytes:W(e)}}async signTransaction(e){return this.signWithIntent(e,"TransactionData")}async signPersonalMessage(e){const{signature:t}=await this.signWithIntent(c.byteVector().serialize(e).toBytes(),"PersonalMessage");return{bytes:W(e),signature:t}}async signAndExecuteTransaction({transaction:e,client:t}){const r=await e.build({client:t}),{signature:s}=await this.signTransaction(r);return(await t.core.executeTransaction({transaction:r,signatures:[s]})).transaction}toSuiAddress(){return this.getPublicKey().toSuiAddress()}}const bi=33;class Xi extends Ki{constructor(e){if(super(),typeof e=="string"?this.data=N(e):e instanceof Uint8Array?this.data=e:this.data=Uint8Array.from(e),this.data.length!==bi)throw new Error(`Invalid public key input. Expected ${bi} bytes, got ${this.data.length}`)}equals(e){return super.equals(e)}toRawBytes(){return this.data}flag(){return rn.Secp256r1}async verify(e,t){let r;if(typeof t=="string"){const s=xf(t);if(s.signatureScheme!=="Secp256r1")throw new Error("Invalid signature scheme");if(!rs(this.toRawBytes(),s.publicKey))throw new Error("Signature does not match public key");r=s.signature}else r=t;return Vr.verify(Vr.Signature.fromCompact(r),Ns(e),this.toRawBytes())}}Xi.SIZE=bi;var bu=n=>{throw TypeError(n)},vu=(n,e,t)=>e.has(n)||bu("Cannot "+t),Ua=(n,e,t)=>(vu(n,e,"read from private field"),t?t.call(n):e.get(n)),Uf=(n,e,t)=>e.has(n)?bu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),Rf=(n,e,t,r)=>(vu(n,e,"write to private field"),e.set(n,t),t),Wn;function Bf(n){const e=new Uint8Array(n),t=e.slice(1,33),s=(e.slice(33,65)[31]&1)===0?2:3,i=new Uint8Array(Xi.SIZE);return i[0]=s,i.set(t,1),i}const Df=class vi extends Nf{constructor(e,t){super(),Uf(this,Wn),this.privateKey=e,Rf(this,Wn,new Xi(t))}static async generate({extractable:e=!1}={}){const t=await globalThis.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},e,["sign","verify"]),r=await globalThis.crypto.subtle.exportKey("raw",t.publicKey);return new vi(t.privateKey,Bf(new Uint8Array(r)))}static import(e){return new vi(e.privateKey,e.publicKey)}getKeyScheme(){return"Secp256r1"}export(){const e={privateKey:this.privateKey,publicKey:Ua(this,Wn).toRawBytes()};return Object.defineProperty(e,"toJSON",{enumerable:!1,value:()=>{throw new Error("The exported keypair must not be serialized. It must be stored in IndexedDB directly.")}}),e}getPublicKey(){return Ua(this,Wn)}async sign(e){const t=await globalThis.crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},this.privateKey,e);return Vr.Signature.fromCompact(new Uint8Array(t)).normalizeS().toCompactRawBytes()}};Wn=new WeakMap;let Qm=Df;BigInt(1e9);const zf="0x1",Su="0x2";bn("0x6");const Vf=`${Su}::sui::SUI`;bn("0x5");bn("0x8");const Lf="object",Wf="ID",Ff="ascii",Gf="String",Kf="string",qf="String",Jf="option",Zf="Option";function Hf(n){const e=typeof n.body=="object"&&"datatype"in n.body?n.body.datatype:null;return!!e&&A(e.package)===A("0x2")&&e.module==="tx_context"&&e.type==="TxContext"}function Si(n){if(typeof n=="string")switch(n){case"address":return M.Address;case"bool":return M.Bool;case"u8":return M.U8;case"u16":return M.U16;case"u32":return M.U32;case"u64":return M.U64;case"u128":return M.U128;case"u256":return M.U256;default:throw new Error(`Unknown type signature ${n}`)}if("vector"in n){if(n.vector==="u8")return M.byteVector().transform({input:t=>typeof t=="string"?new TextEncoder().encode(t):t,output:t=>t});const e=Si(n.vector);return e?M.vector(e):null}if("datatype"in n){const e=A(n.datatype.package);if(e===A(zf)){if(n.datatype.module===Ff&&n.datatype.type===Gf||n.datatype.module===Kf&&n.datatype.type===qf)return M.String;if(n.datatype.module===Jf&&n.datatype.type===Zf){const t=Si(n.datatype.typeParameters[0]);return t?M.vector(t):null}}if(e===A(Su)&&n.datatype.module===Lf&&n.datatype.type===Wf)return M.Address}return null}function Qf(n){return typeof n=="object"&&"Reference"in n?{ref:"&",body:Hn(n.Reference)}:typeof n=="object"&&"MutableReference"in n?{ref:"&mut",body:Hn(n.MutableReference)}:{ref:null,body:Hn(n)}}function Hn(n){if(typeof n=="string")switch(n){case"Address":return"address";case"Bool":return"bool";case"U8":return"u8";case"U16":return"u16";case"U32":return"u32";case"U64":return"u64";case"U128":return"u128";case"U256":return"u256";default:throw new Error(`Unexpected type ${n}`)}if("Vector"in n)return{vector:Hn(n.Vector)};if("Struct"in n)return{datatype:{package:n.Struct.address,module:n.Struct.module,type:n.Struct.name,typeParameters:n.Struct.typeArguments.map(Hn)}};if("TypeParameter"in n)return{typeParameter:n.TypeParameter};throw new Error(`Unexpected type ${JSON.stringify(n)}`)}function Yf(n){return{$kind:"Pure",Pure:{bytes:n instanceof Uint8Array?W(n):n.toBase64()}}}const We={Pure:Yf,ObjectRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"ImmOrOwnedObject",ImmOrOwnedObject:{digest:e,version:t,objectId:A(n)}}}},SharedObjectRef({objectId:n,mutable:e,initialSharedVersion:t}){return{$kind:"Object",Object:{$kind:"SharedObject",SharedObject:{mutable:e,initialSharedVersion:t,objectId:A(n)}}}},ReceivingRef({objectId:n,digest:e,version:t}){return{$kind:"Object",Object:{$kind:"Receiving",Receiving:{digest:e,version:t,objectId:A(n)}}}}},Rt={MoveCall(n){const[e,t="",r=""]="target"in n?n.target.split("::"):[n.package,n.module,n.function];return{$kind:"MoveCall",MoveCall:{package:e,module:t,function:r,typeArguments:n.typeArguments??[],arguments:n.arguments??[]}}},TransferObjects(n,e){return{$kind:"TransferObjects",TransferObjects:{objects:n.map(t=>$(L,t)),address:$(L,e)}}},SplitCoins(n,e){return{$kind:"SplitCoins",SplitCoins:{coin:$(L,n),amounts:e.map(t=>$(L,t))}}},MergeCoins(n,e){return{$kind:"MergeCoins",MergeCoins:{destination:$(L,n),sources:e.map(t=>$(L,t))}}},Publish({modules:n,dependencies:e}){return{$kind:"Publish",Publish:{modules:n.map(t=>typeof t=="string"?t:W(new Uint8Array(t))),dependencies:e.map(t=>bn(t))}}},Upgrade({modules:n,dependencies:e,package:t,ticket:r}){return{$kind:"Upgrade",Upgrade:{modules:n.map(s=>typeof s=="string"?s:W(new Uint8Array(s))),dependencies:e.map(s=>bn(s)),package:t,ticket:$(L,r)}}},MakeMoveVec({type:n,elements:e}){return{$kind:"MakeMoveVec",MakeMoveVec:{type:n??null,elements:e.map(t=>$(L,t))}}},Intent({name:n,inputs:e={},data:t={}}){return{$kind:"$Intent",$Intent:{name:n,inputs:Object.fromEntries(Object.entries(e).map(([r,s])=>[r,Array.isArray(s)?s.map(i=>$(L,i)):$(L,s)])),data:t}}}};function or(n){return _(Object.entries(n).map(([e,t])=>l({[e]:t})))}const Pe=or({GasCoin:p(!0),Input:S(E(),T()),Result:S(E(),T()),NestedResult:os([S(E(),T()),S(E(),T())])}),Xf=l({budget:v(pe),price:v(pe),owner:v(On),payment:v(g(Pt))}),em=l({package:ve,module:f(),function:f(),typeArguments:g(f()),arguments:g(Pe)}),tm=l({name:f(),inputs:At(f(),_([Pe,g(Pe)])),data:At(f(),je())}),nm=or({MoveCall:em,TransferObjects:l({objects:g(Pe),address:Pe}),SplitCoins:l({coin:Pe,amounts:g(Pe)}),MergeCoins:l({destination:Pe,sources:g(Pe)}),Publish:l({modules:g(tn),dependencies:g(ve)}),MakeMoveVec:l({type:v(f()),elements:g(Pe)}),Upgrade:l({modules:g(tn),dependencies:g(ve),package:ve,ticket:Pe}),$Intent:tm}),rm=or({ImmOrOwnedObject:Pt,SharedObject:l({objectId:ve,initialSharedVersion:pe,mutable:bt()}),Receiving:Pt}),sm=or({Object:rm,Pure:l({bytes:tn}),UnresolvedPure:l({value:je()}),UnresolvedObject:l({objectId:ve,version:C(v(pe)),digest:C(v(f())),initialSharedVersion:C(v(pe)),mutable:C(v(bt()))})}),im=or({None:p(!0),Epoch:pe}),am=l({version:p(2),sender:tt(On),expiration:tt(im),gasData:Xf,inputs:g(sm),commands:g(nm),digest:C(v(f()))}),om=50,cm=1000n,um=5e10;function lm(n){return async function(t,r,s){return await fm(t,n),await gm(t,n),r.onlyTransactionKind||(await dm(t,n),await hm(t,n),await pm(t,n)),await s()}}async function dm(n,e){n.gasConfig.price||(n.gasConfig.price=String(await e.getReferenceGasPrice()))}async function hm(n,e){if(n.gasConfig.budget)return;const t=await e.dryRunTransactionBlock({transactionBlock:n.build({overrides:{gasData:{budget:String(um),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=cm*BigInt(n.gasConfig.price||1n),s=BigInt(t.effects.gasUsed.computationCost)+r,i=s+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);n.gasConfig.budget=String(i>s?i:s)}async function pm(n,e){if(!n.gasConfig.payment){const r=(await e.getCoins({owner:n.gasConfig.owner||n.sender,coinType:Vf})).data.filter(s=>!n.inputs.find(a=>a.Object?.ImmOrOwnedObject?s.coinObjectId===a.Object.ImmOrOwnedObject.objectId:!1)).map(s=>({objectId:s.coinObjectId,digest:s.digest,version:s.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");n.gasConfig.payment=r.map(s=>$(Pt,s))}}async function gm(n,e){const t=n.inputs.filter(h=>h.UnresolvedObject&&!(h.UnresolvedObject.version||h.UnresolvedObject?.initialSharedVersion)),r=[...new Set(t.map(h=>bn(h.UnresolvedObject.objectId)))],s=r.length?Vi(r,om):[],i=(await Promise.all(s.map(h=>e.multiGetObjects({ids:h,options:{showOwner:!0}})))).flat(),a=new Map(r.map((h,w)=>[h,i[w]])),u=Array.from(a).filter(([h,w])=>w.error).map(([h,w])=>JSON.stringify(w.error));if(u.length)throw new Error(`The following input objects are invalid: ${u.join(", ")}`);const d=i.map(h=>{if(h.error||!h.data)throw new Error(`Failed to fetch object: ${h.error}`);const w=h.data.owner,j=w&&typeof w=="object"?"Shared"in w?w.Shared.initial_shared_version:"ConsensusAddressOwner"in w?w.ConsensusAddressOwner.start_version:null:null;return{objectId:h.data.objectId,digest:h.data.digest,version:h.data.version,initialSharedVersion:j}}),b=new Map(r.map((h,w)=>[h,d[w]]));for(const[h,w]of n.inputs.entries()){if(!w.UnresolvedObject)continue;let j;const G=A(w.UnresolvedObject.objectId),x=b.get(G);w.UnresolvedObject.initialSharedVersion??x?.initialSharedVersion?j=We.SharedObjectRef({objectId:G,initialSharedVersion:w.UnresolvedObject.initialSharedVersion||x?.initialSharedVersion,mutable:w.UnresolvedObject.mutable||mm(n,h)}):ym(n,h)&&(j=We.ReceivingRef({objectId:G,digest:w.UnresolvedObject.digest??x?.digest,version:w.UnresolvedObject.version??x?.version})),n.inputs[n.inputs.indexOf(w)]=j??We.ObjectRef({objectId:G,digest:w.UnresolvedObject.digest??x?.digest,version:w.UnresolvedObject.version??x?.version})}}async function fm(n,e){const{inputs:t,commands:r}=n,s=[],i=new Set;r.forEach(u=>{if(u.MoveCall){if(u.MoveCall._argumentTypes)return;if(u.MoveCall.arguments.map(h=>h.$kind==="Input"?n.inputs[h.Input]:null).some(h=>h?.UnresolvedPure||h?.UnresolvedObject&&typeof h?.UnresolvedObject.mutable!="boolean")){const h=`${u.MoveCall.package}::${u.MoveCall.module}::${u.MoveCall.function}`;i.add(h),s.push(u.MoveCall)}}});const a=new Map;i.size>0&&await Promise.all([...i].map(async u=>{const[d,b,h]=u.split("::"),w=await e.getNormalizedMoveFunction({package:d,module:b,function:h});a.set(u,w.parameters.map(j=>Qf(j)))})),s.length&&await Promise.all(s.map(async u=>{const d=a.get(`${u.package}::${u.module}::${u.function}`);if(!d)return;const h=d.length>0&&Hf(d.at(-1))?d.slice(0,d.length-1):d;u._argumentTypes=h})),r.forEach(u=>{if(!u.MoveCall)return;const d=u.MoveCall,b=`${d.package}::${d.module}::${d.function}`,h=d._argumentTypes;if(h){if(h.length!==u.MoveCall.arguments.length)throw new Error(`Incorrect number of arguments for ${b}`);h.forEach((w,j)=>{const G=d.arguments[j];if(G.$kind!=="Input")return;const x=t[G.Input];if(!x.UnresolvedPure&&!x.UnresolvedObject)return;const st=x.UnresolvedPure?.value??x.UnresolvedObject?.objectId,In=Si(w.body);if(In){G.type="pure",t[t.indexOf(x)]=We.Pure(In.serialize(st));return}if(typeof st!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(st,null,2)}`);G.type="object";const fs=x.UnresolvedPure?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:st}}:x;t[G.Input]=fs})}})}function mm(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=s.MoveCall._argumentTypes[i].ref!=="&"||t}(s.$kind==="MakeMoveVec"||s.$kind==="MergeCoins"||s.$kind==="SplitCoins"||s.$kind==="TransferObjects")&&(t=!0)}),t}function ym(n,e){let t=!1;return n.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);t=wm(s.MoveCall._argumentTypes[i])||t}}),t}function wm(n){return typeof n.body!="object"||!("datatype"in n.body)?!1:n.body.datatype.package==="0x2"&&n.body.datatype.module==="transfer"&&n.body.datatype.type==="Receiving"}function ku(n,e){return!!(n.inputs.some(t=>t.UnresolvedObject||t.UnresolvedPure)||!e.onlyTransactionKind&&(!n.gasConfig.price||!n.gasConfig.budget||!n.gasConfig.payment))}async function bm(n,e,t){if(Sm(n),!ku(n,e))return await Ra(n),t();const r=vm(e);return(r.core?.resolveTransactionPlugin()??lm(r))(n,e,async()=>{await Ra(n),await t()})}function Ra(n){n.inputs.forEach((e,t)=>{if(e.$kind!=="Object"&&e.$kind!=="Pure")throw new Error(`Input at index ${t} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(e)}`)})}function vm(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}function Sm(n){for(const e of n.commands)switch(e.$kind){case"SplitCoins":e.SplitCoins.amounts.forEach(t=>{Ba(t,M.U64,n)});break;case"TransferObjects":Ba(e.TransferObjects.address,M.Address,n);break}}function Ba(n,e,t){if(n.$kind!=="Input")return;const r=t.inputs[n.Input];r.$kind==="UnresolvedPure"&&(t.inputs[n.Input]=We.Pure(e.serialize(r.UnresolvedPure.value)))}function km(n){function e(t){return n(t)}return e.system=t=>{const r=t?.mutable;return e(r!==void 0?We.SharedObjectRef({objectId:"0x5",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x5",initialSharedVersion:1}})},e.clock=()=>e(We.SharedObjectRef({objectId:"0x6",initialSharedVersion:1,mutable:!1})),e.random=()=>e({$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x8",mutable:!1}}),e.denyList=t=>e({$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x403",mutable:t?.mutable}}),e.option=({type:t,value:r})=>s=>s.moveCall({typeArguments:[t],target:`0x1::option::${r===null?"none":"some"}`,arguments:r===null?[]:[s.object(r)]}),e}function Om(n){function e(t,r){if(typeof t=="string")return n(Zn(t).serialize(r));if(t instanceof Uint8Array||Li(t))return n(t);throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value")}return e.u8=t=>n(M.U8.serialize(t)),e.u16=t=>n(M.U16.serialize(t)),e.u32=t=>n(M.U32.serialize(t)),e.u64=t=>n(M.U64.serialize(t)),e.u128=t=>n(M.U128.serialize(t)),e.u256=t=>n(M.U256.serialize(t)),e.bool=t=>n(M.Bool.serialize(t)),e.string=t=>n(M.String.serialize(t)),e.address=t=>n(M.Address.serialize(t)),e.id=e.address,e.vector=(t,r)=>n(M.vector(Zn(t)).serialize(r)),e.option=(t,r)=>n(M.option(Zn(t)).serialize(r)),e}function Da(n){if(typeof n=="string")return A(n);if(n.Object)return n.Object.ImmOrOwnedObject?A(n.Object.ImmOrOwnedObject.objectId):n.Object.Receiving?A(n.Object.Receiving.objectId):A(n.Object.SharedObject.objectId);if(n.UnresolvedObject)return A(n.UnresolvedObject.objectId)}const Im=n=>async(e,t,r)=>{const s=Og(e);if(s.types.length===0&&s.packages.length===0)return r();const i=await $m(t).core.mvr.resolve({types:s.types,packages:s.packages});Ig(e,i),await r()};function $m(n){if(!n.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return n.client}var Ou=n=>{throw TypeError(n)},ea=(n,e,t)=>e.has(n)||Ou("Cannot "+t),y=(n,e,t)=>(ea(n,e,"read from private field"),t?t.call(n):e.get(n)),Ke=(n,e,t)=>e.has(n)?Ou("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),R=(n,e,t,r)=>(ea(n,e,"write to private field"),e.set(n,t),t),H=(n,e,t)=>(ea(n,e,"access private method"),t),Jt,Ht,pt,et,Te,Me,ze,jt,O,q,Iu,Rr,Br,Dr,is,ki,ta,$u,Eu;function Ps(n,e=1/0){const t={$kind:"Result",get Result(){return typeof n=="function"?n():n}},r=[],s=i=>r[i]??(r[i]={$kind:"NestedResult",get NestedResult(){return[typeof n=="function"?n():n,i]}});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,a){if(a in i)return Reflect.get(i,a);if(a===Symbol.iterator)return function*(){let d=0;for(;d<e;)yield s(d),d++};if(typeof a=="symbol")return;const u=parseInt(a,10);if(!(Number.isNaN(u)||u<0))return s(u)}})}const Tu=Symbol.for("@mysten/transaction");function Em(n){return!!n&&typeof n=="object"&&n[Tu]===!0}const za={buildPlugins:new Map,serializationPlugins:new Map},xs=Symbol.for("@mysten/transaction/registry");function Mn(){try{const n=globalThis;return n[xs]||(n[xs]=za),n[xs]}catch{return za}}const Mu=class Oi{constructor(){Ke(this,q),Ke(this,Jt),Ke(this,Ht),Ke(this,pt,new Map),Ke(this,et,[]),Ke(this,Te,[]),Ke(this,Me,new Set),Ke(this,ze,new Set),Ke(this,jt,new Map),Ke(this,O),this.object=km(t=>{if(typeof t=="function")return this.object(this.add(t));if(typeof t=="object"&&yn(L,t))return t;const r=Da(t),s=y(this,O).inputs.find(i=>r===Da(i));return s?.Object?.SharedObject&&typeof t=="object"&&t.Object?.SharedObject&&(s.Object.SharedObject.mutable=s.Object.SharedObject.mutable||t.Object.SharedObject.mutable),s?{$kind:"Input",Input:y(this,O).inputs.indexOf(s),type:"object"}:H(this,q,Br).call(this,"object",typeof t=="string"?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:A(t)}}:t)});const e=Mn();R(this,O,new ye),R(this,Ht,[...e.buildPlugins.values()]),R(this,Jt,[...e.serializationPlugins.values()])}static fromKind(e){const t=new Oi;return R(t,O,ye.fromKindBytes(typeof e=="string"?N(e):e)),R(t,et,y(t,O).inputs.slice()),R(t,Te,y(t,O).commands.slice()),R(t,Me,new Set(y(t,Te).map((r,s)=>s))),t}static from(e){const t=new Oi;return Em(e)?R(t,O,ye.restore(e.getData())):typeof e!="string"||!e.startsWith("{")?R(t,O,ye.fromBytes(typeof e=="string"?N(e):e)):R(t,O,ye.restore(JSON.parse(e))),R(t,et,y(t,O).inputs.slice()),R(t,Te,y(t,O).commands.slice()),R(t,Me,new Set(y(t,Te).map((r,s)=>s))),t}static registerGlobalSerializationPlugin(e,t){Mn().serializationPlugins.set(e,t??e)}static unregisterGlobalSerializationPlugin(e){Mn().serializationPlugins.delete(e)}static registerGlobalBuildPlugin(e,t){Mn().buildPlugins.set(e,t??e)}static unregisterGlobalBuildPlugin(e){Mn().buildPlugins.delete(e)}addSerializationPlugin(e){y(this,Jt).push(e)}addBuildPlugin(e){y(this,Ht).push(e)}addIntentResolver(e,t){if(y(this,pt).has(e)&&y(this,pt).get(e)!==t)throw new Error(`Intent resolver for ${e} already exists`);y(this,pt).set(e,t)}setSender(e){y(this,O).sender=e}setSenderIfNotSet(e){y(this,O).sender||(y(this,O).sender=e)}setExpiration(e){y(this,O).expiration=e?$(uu,e):null}setGasPrice(e){y(this,O).gasConfig.price=String(e)}setGasBudget(e){y(this,O).gasConfig.budget=String(e)}setGasBudgetIfNotSet(e){y(this,O).gasData.budget==null&&(y(this,O).gasConfig.budget=String(e))}setGasOwner(e){y(this,O).gasConfig.owner=e}setGasPayment(e){y(this,O).gasConfig.payment=e.map(t=>$(Pt,t))}get blockData(){return Ca(y(this,O).snapshot())}getData(){return y(this,O).snapshot()}get[Tu](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Om(e=>Li(e)?H(this,q,Br).call(this,"pure",{$kind:"Pure",Pure:{bytes:e.toBase64()}}):H(this,q,Br).call(this,"pure",yn(Ta,e)?$(Ta,e):e instanceof Uint8Array?We.Pure(e):{$kind:"UnresolvedPure",UnresolvedPure:{value:e}}))}),this.pure}get gas(){return{$kind:"GasCoin",GasCoin:!0}}objectRef(...e){return this.object(We.ObjectRef(...e))}receivingRef(...e){return this.object(We.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(We.SharedObjectRef(...e))}add(e){if(typeof e=="function"){if(y(this,jt).has(e))return y(this,jt).get(e);const t=H(this,q,Iu).call(this),r=e(t);if(!(r&&typeof r=="object"&&"then"in r))return R(this,Me,y(t,Me)),y(this,jt).set(e,r),r;const s=H(this,q,Rr).call(this,{$kind:"$Intent",$Intent:{name:"AsyncTransactionThunk",inputs:{},data:{resultIndex:y(this,O).commands.length,result:null}}});y(this,ze).add(Promise.resolve(r).then(a=>{s.$Intent.data.result=a}));const i=Ps(()=>s.$Intent.data.resultIndex);return y(this,jt).set(e,i),i}else H(this,q,Rr).call(this,e);return Ps(y(this,O).commands.length-1)}splitCoins(e,t){const r=Rt.SplitCoins(typeof e=="string"?this.object(e):H(this,q,is).call(this,e),t.map(s=>typeof s=="number"||typeof s=="bigint"||typeof s=="string"?this.pure.u64(s):H(this,q,Dr).call(this,s)));return H(this,q,Rr).call(this,r),Ps(y(this,O).commands.length-1,t.length)}mergeCoins(e,t){return this.add(Rt.MergeCoins(this.object(e),t.map(r=>this.object(r))))}publish({modules:e,dependencies:t}){return this.add(Rt.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,package:r,ticket:s}){return this.add(Rt.Upgrade({modules:e,dependencies:t,package:r,ticket:this.object(s)}))}moveCall({arguments:e,...t}){return this.add(Rt.MoveCall({...t,arguments:e?.map(r=>H(this,q,Dr).call(this,r))}))}transferObjects(e,t){return this.add(Rt.TransferObjects(e.map(r=>this.object(r)),typeof t=="string"?this.pure.address(t):H(this,q,Dr).call(this,t)))}makeMoveVec({type:e,elements:t}){return this.add(Rt.MakeMoveVec({type:e,elements:t.map(r=>this.object(r))}))}serialize(){return JSON.stringify(Ca(y(this,O).snapshot()))}async toJSON(e={}){await this.prepareForSerialization(e);const t=this.isFullyResolved();return JSON.stringify($(am,t?{...y(this,O).snapshot(),digest:y(this,O).getDigest()}:y(this,O).snapshot()),(r,s)=>typeof s=="bigint"?s.toString():s,2)}async sign(e){const{signer:t,...r}=e,s=await this.build(r);return t.signTransaction(s)}isFullyResolved(){return!(!y(this,O).sender||y(this,ze).size>0||y(this,O).commands.some(e=>e.$Intent)||ku(y(this,O),{}))}async build(e={}){return await this.prepareForSerialization(e),await H(this,q,ki).call(this,e),y(this,O).build({onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await this.prepareForSerialization(e),await H(this,q,ki).call(this,e),y(this,O).getDigest()}async prepareForSerialization(e){await H(this,q,$u).call(this),H(this,q,Eu).call(this);const t=new Set;for(const s of y(this,O).commands)s.$Intent&&t.add(s.$Intent.name);const r=[...y(this,Jt)];for(const s of t)if(!e.supportedIntents?.includes(s)){if(!y(this,pt).has(s))throw new Error(`Missing intent resolver for ${s}`);r.push(y(this,pt).get(s))}r.push(Im()),await H(this,q,ta).call(this,r,e)}};Jt=new WeakMap;Ht=new WeakMap;pt=new WeakMap;et=new WeakMap;Te=new WeakMap;Me=new WeakMap;ze=new WeakMap;jt=new WeakMap;O=new WeakMap;q=new WeakSet;Iu=function(){const n=new Mu;return R(n,O,y(this,O)),R(n,Jt,y(this,Jt)),R(n,Ht,y(this,Ht)),R(n,pt,y(this,pt)),R(n,ze,y(this,ze)),R(n,Me,new Set(y(this,Me))),R(n,jt,y(this,jt)),y(this,et).push(y(n,et)),y(this,Te).push(y(n,Te)),n};Rr=function(n){const e=y(this,O).commands.length;return y(this,Te).push(n),y(this,Me).add(e),y(this,O).commands.push(n),y(this,O).mapCommandArguments(e,t=>{if(t.$kind==="Result"&&!y(this,Me).has(t.Result))throw new Error(`Result { Result: ${t.Result} } is not available to use the current transaction`);if(t.$kind==="NestedResult"&&!y(this,Me).has(t.NestedResult[0]))throw new Error(`Result { NestedResult: [${t.NestedResult[0]}, ${t.NestedResult[1]}] } is not available to use the current transaction`);if(t.$kind==="Input"&&t.Input>=y(this,O).inputs.length)throw new Error(`Input { Input: ${t.Input} } references an input that does not exist in the current transaction`);return t}),n};Br=function(n,e){return y(this,et).push(e),y(this,O).addInput(n,e)};Dr=function(n){return Li(n)?this.pure(n):H(this,q,is).call(this,n)};is=function(n){if(typeof n=="function"){const e=this.add(n);return typeof e=="function"?H(this,q,is).call(this,e):$(L,e)}return $(L,n)};ki=async function(n){if(!n.onlyTransactionKind&&!y(this,O).sender)throw new Error("Missing transaction sender");await H(this,q,ta).call(this,[...y(this,Ht),bm],n)};ta=async function(n,e){try{const t=r=>{if(r>=n.length)return()=>{};const s=n[r];return async()=>{const i=t(r+1);let a=!1,u=!1;if(await s(y(this,O),e,async()=>{if(a)throw new Error(`next() was call multiple times in TransactionPlugin ${r}`);a=!0,await i(),u=!0}),!a)throw new Error(`next() was not called in TransactionPlugin ${r}`);if(!u)throw new Error(`next() was not awaited in TransactionPlugin ${r}`)}};await t(0)()}finally{R(this,et,y(this,O).inputs.slice()),R(this,Te,y(this,O).commands.slice())}};$u=async function(){for(;y(this,ze).size>0;){const n=Promise.all(y(this,ze));y(this,ze).clear(),y(this,ze).add(n),await n,y(this,ze).delete(n)}};Eu=function(){const n=y(this,O).commands,e=y(this,O).inputs,t=y(this,Te).flat(1/0),r=y(this,et).flat(1/0);if(t.length!==n.length)throw new Error("Unexpected number of commands found in transaction data");if(r.length!==e.length)throw new Error("Unexpected number of inputs found in transaction data");const s=t.filter(a=>a.$Intent?.name!=="AsyncTransactionThunk");y(this,O).commands=s,y(this,O).inputs=r,R(this,Te,s),R(this,et,r),R(this,Me,new Set(s.map((a,u)=>u)));function i(a){const u=n[a];if(u.$Intent?.name==="AsyncTransactionThunk"){const b=u.$Intent.data.result;if(b==null)throw new Error("AsyncTransactionThunk has not been resolved");return i(b.Result)}const d=s.indexOf(u);if(d===-1)throw new Error("Unable to find original index for command");return d}y(this,O).mapArguments(a=>{if(a.$kind==="Input"){const u=r.indexOf(e[a.Input]);if(u===-1)throw new Error("Input has not been resolved");return{...a,Input:u}}else if(a.$kind==="Result"){const u=i(a.Result);return{...a,Result:u}}else if(a.$kind==="NestedResult"){const u=i(a.NestedResult[0]);return{...a,NestedResult:[u,a.NestedResult[1]]}}return a});for(const[a,u]of n.entries())if(u.$Intent?.name==="AsyncTransactionThunk")try{u.$Intent.data.resultIndex=i(a)}catch{}};let Ym=Mu;const Xm="sui:signTransaction",ey="sui:signAndExecuteTransaction",ty="sui:signPersonalMessage";export{Bn as E,Km as S,Ko as T,Qm as W,_f as Z,Dm as a,Bm as b,qo as c,N as d,W as e,Mm as f,Vm as g,Nf as h,Gm as i,Hm as j,ty as k,ey as l,Xm as m,Ym as n,Zm as o,I as p,zm as r,Rm as s,F as t};
